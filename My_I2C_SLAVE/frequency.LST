C51 COMPILER V9.00   FREQUENCY                                                             06/26/2014 09:13:09 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE FREQUENCY
OBJECT MODULE PLACED IN frequency.OBJ
COMPILER INVOKED BY: C:\Program Files\Keil\C51\BIN\C51.EXE frequency.c LARGE OPTIMIZE(9,SPEED) BROWSE ORDER NOAREGS MODA
                    -B2 DEBUG OBJECTEXTEND

line level    source

   1          #include "frequency.h"
   2          #include "channels.h"
   3          
   4          #define FREQ_CHANNELS   1
   5          
   6          
   7          #define FRAME_TIME_1    511  //границы кадров захвата
   8          #define FRAME_TIME_2    1023
   9          #define FRAME_TIME_3    1535
  10          #define FRAME_TIME_4    2047
  11          
  12          #define SHEAR                   9         //рассчитываетс€ из максимума кадра захвата, как Nбит-2
  13          
  14          # define CLI_EXT  EX1=0; EX0=0; ET0=0;
  15          # define STI_EXT  EX1=1; EX0=1; ET0=1;
  16          
  17          #define TH1_VAL 0xFF //1000Hz
  18          #define TL1_VAL 0xFF
  19          
  20          //------------------------------------------
  21          volatile struct Frequency xdata frequency[FREQ_CHANNELS]={0}; //структура частотных каналов
  22          //------------------------------------------
  23          #define FRQ_CHNL_1 0
  24          #define FRQ_CHNL_2 1
  25          #define FRQ_CHNL_3 2
  26          //--------------------------------------------------------
  27          #define Hz  10
  28          
  29          #define kol_izmer_data 3
  30          #define kol_sec_sred 3
  31          #define kol_sec_mgnov 1
  32          #define Period_sred 200
  33          #define Period_mgnov 100
  34          
  35          volatile unsigned long data temp_Hz_kanal_sred=0;
  36          volatile unsigned long data temp_Hz_kanal_mgnov=0;
  37          
  38          volatile unsigned int idata sec_kanal_sred=0;
  39          volatile unsigned int idata sec_kanal_mgnov=0;
  40          volatile unsigned int idata cycl_kanal=0;
  41          
  42          volatile unsigned long idata Hz_data_sred=0;
  43          volatile unsigned long idata Hz_data_mgnov=0;
  44          
  45          volatile unsigned int xdata period_kanal_sred=0;
  46          volatile unsigned int xdata period_kanal_mgnov=0;
  47          //volatile unsigned long xdata Hz_kanal_mgnov[kol_sec_mgnov][1000/Period_mgnov]={0};
  48          volatile unsigned long xdata Hz_kanal_sred[kol_sec_sred][1000/Period_sred]={0};
  49          
  50          volatile unsigned long data sym_kanal_sred=0;
  51          volatile unsigned long data sym_kanal_mgnov=0;
  52          unsigned char poschet_intervalov=0; 
  53          
  54          volatile unsigned char handle_freq_flag=0;
C51 COMPILER V9.00   FREQUENCY                                                             06/26/2014 09:13:09 PAGE 2   

  55          //--------------------------------------------------------
  56          #pragma OT(9,Speed)
  57          void Frequency_Init(unsigned char frequency_modific) //инициализаци€ частотных каналов
  58          {
  59   1              unsigned char i=0,j=0;
  60   1      
  61   1              if(frequency_modific==CHNL_FREQ_256) //режим измерени€ низкой частоты
  62   1              {       
  63   2                      //---------Timer1-входное прерывание--------------
  64   2                      TMOD &= 0xF; // 0000 1111  очищаем
  65   2                      TMOD |= 0x50; // таймер в режим счетчика 16 разр€дов 
  66   2              
  67   2                      TH1     = TH1_VAL; /// 
  68   2                      TL1 = TL1_VAL;//
  69   2                      
  70   2              
  71   2                      ET1=1;
  72   2                      TR1=1;
  73   2                      //---------Timer2-опорна€ частота-----------------
  74   2                      ET2 = 1;
  75   2                      T2CON=0x00;
  76   2                      TL2 = 0xFF;
  77   2                      TH2 = 0xE7;
  78   2                      RCAP2L = 0xFF;
  79   2                  RCAP2H = 0xE7; //1024Hz
  80   2                      TR2=1;
  81   2                      //-----------------------
  82   2              
  83   2                      for(i=0;i<FREQ_CHANNELS;i++) //обнуление структуры
  84   2                      {
  85   3                              frequency[i].time_counter=0;
  86   3                              for(j=0;j<4;j++)
  87   3                              {
  88   4                                      frequency[i].frame[j].event_counter=0;
  89   4                                      frequency[i].frame[j].timestamp=0;
  90   4                                      frequency[i].frame[j].time_copy=0;
  91   4                                      frequency[i].frame[j].event_copy=0;
  92   4                              }
  93   3                      }
  94   2              }
  95   1              else  //режим измерени€ высокой частоты
  96   1              {
  97   2                      
  98   2                      //-----------Timer1-счетный таймер----------
  99   2                              TMOD=0x50;//счетчик 16 бит
 100   2                              TH1     = 0; /// 
 101   2                              TL1 = 0;//
 102   2                              TR1=1;
 103   2                      //-----------Timer2-опорный таймер----------
 104   2                              ET2 = 1;
 105   2                              PT2=0;//приоритет низкий
 106   2                              T2CON=0x00;                       // таймер периода сбора частоты (0.01)
 107   2                              RCAP2H=TH2=0x86;//0xC3;//0x86;//0x0B;   - дл€ 6,29 ћ√ц  //0x0A 
 108   2                              RCAP2L=TL2=0x07;//0x03;//0x07;//0xF0; - дл€ 6,29 ћ√ц   //0x3C 
 109   2                              TR2=1;
 110   2                      //------------------------------------------
 111   2      
 112   2      
 113   2              }
 114   1              return;
 115   1      }
 116          //--------------------------------------------------------
C51 COMPILER V9.00   FREQUENCY                                                             06/26/2014 09:13:09 PAGE 3   

 117          void INT_TIM1_ISR(void) interrupt 3 //using 3//обработчик внешнего прерывани€ 2-использует внешний вход та
             -ймера T1
 118          {
 119   1                      unsigned char cnt;
 120   1                              
 121   1                      TH1=0xFF;
 122   1                      TL1=0xFF;
 123   1              
 124   1                      cnt=(frequency[FRQ_CHNL_1].time_counter>>SHEAR)&0x3;
 125   1              
 126   1                      frequency[FRQ_CHNL_1].frame[cnt].event_counter++;
 127   1                      frequency[FRQ_CHNL_1].frame[cnt].timestamp=frequency[FRQ_CHNL_1].time_counter;
 128   1              return;
 129   1      }
 130          //--------------------------------------------------------
 131          void Timer2_ISR(void) interrupt 5 //using 3//обработчик прерывани€ счетного таймера частоты
 132          {
 133   1      
 134   1              if(channels.I2C_CHNL.channels.frequency_modific==CHNL_FREQ_256) //измерение низкой частоты
 135   1              {
 136   2                      TF2 = 0;
 137   2              //      TH2=0xE7;
 138   2              //      TL2=0xFF;
 139   2              
 140   2                      switch(frequency[FRQ_CHNL_1].time_counter)
 141   2                      {
 142   3                              case FRAME_TIME_1:
 143   3                              {
 144   4                                      frequency[FRQ_CHNL_1].frame[0].time_copy=frequency[FRQ_CHNL_1].frame[0].timestamp+FRAME_TIME_4-frequen
             -cy[FRQ_CHNL_1].frame[3].timestamp;
 145   4                                      frequency[FRQ_CHNL_1].frame[0].event_copy=frequency[FRQ_CHNL_1].frame[0].event_counter; 
 146   4              
 147   4              
 148   4                                      frequency[FRQ_CHNL_1].frame[3].event_counter=0;
 149   4                                      //---------------------------------------
 150   4                              }
 151   3                              break;
 152   3              
 153   3                              case FRAME_TIME_2:
 154   3                              {
 155   4                                      frequency[FRQ_CHNL_1].frame[1].time_copy=frequency[FRQ_CHNL_1].frame[1].timestamp-frequency[FRQ_CHNL_1
             -].frame[0].timestamp;
 156   4                                      frequency[FRQ_CHNL_1].frame[1].event_copy=frequency[FRQ_CHNL_1].frame[1].event_counter; 
 157   4              
 158   4                                      frequency[FRQ_CHNL_1].frame[0].event_counter=0;
 159   4                                      //----------------------------------------------
 160   4                              }
 161   3                              break;
 162   3              
 163   3                              case FRAME_TIME_3:
 164   3                              {
 165   4                                      frequency[FRQ_CHNL_1].frame[2].time_copy=frequency[FRQ_CHNL_1].frame[2].timestamp-frequency[FRQ_CHNL_1
             -].frame[1].timestamp;
 166   4                                      frequency[FRQ_CHNL_1].frame[2].event_copy=frequency[FRQ_CHNL_1].frame[2].event_counter; 
 167   4              
 168   4                                      frequency[FRQ_CHNL_1].frame[1].event_counter=0;
 169   4                                      //----------------------------------------------------
 170   4                              }
 171   3                              break;
 172   3              
 173   3                              case FRAME_TIME_4:
 174   3                              {
C51 COMPILER V9.00   FREQUENCY                                                             06/26/2014 09:13:09 PAGE 4   

 175   4                                      frequency[FRQ_CHNL_1].frame[3].time_copy=frequency[FRQ_CHNL_1].frame[3].timestamp-frequency[FRQ_CHNL_1
             -].frame[2].timestamp;
 176   4                                      frequency[FRQ_CHNL_1].frame[3].event_copy=frequency[FRQ_CHNL_1].frame[3].event_counter; 
 177   4              
 178   4                                      frequency[FRQ_CHNL_1].frame[2].event_counter=0; 
 179   4                                      //-----------------------------------------------------                 
 180   4                                      frequency[FRQ_CHNL_1].time_counter=0;
 181   4                              }
 182   3                              break;
 183   3                      }
 184   2              
 185   2                      frequency[FRQ_CHNL_1].time_counter++;
 186   2                      frequency[FRQ_CHNL_1].time_counter&=FRAME_TIME_4;
 187   2              }
 188   1              else //измерение высокой частоты
 189   1              {
 190   2                      char i=0;
 191   2                      char j=0;
 192   2      
 193   2                      TF2=0;
 194   2                      if(cycl_kanal<19)
 195   2                      {
 196   3                              cycl_kanal++;
 197   3                      }
 198   2                      else
 199   2                      {
 200   3                               temp_Hz_kanal_mgnov=((unsigned long)TH1*0x100)|TL1;
 201   3                               TH1=TL1=0;
 202   3                               handle_freq_flag=1;
 203   3                      }       
 204   2              }
 205   1              return;
 206   1      }
 207          //------------------------------------------------------------
 208          #pragma OT(0,Speed)
 209          void Frequency_Measure_Process(void)
 210           { 
 211   1              static unsigned char frq_chnl=0;
 212   1              static unsigned long temp_freq=0; 
 213   1      
 214   1              if(channels.I2C_CHNL.channels.frequency_modific==CHNL_FREQ_256) //измерение низкой частоты
 215   1              {
 216   2      
 217   2                      temp_freq=(((unsigned long)frequency[frq_chnl].frame[0].event_copy+(unsigned long)frequency[frq_chnl].fr
             -ame[1].event_copy+(unsigned long)frequency[frq_chnl].frame[2].event_copy+(unsigned long)frequency[frq_chnl].frame[3].eve
             -nt_copy)<<18)/((frequency[frq_chnl].frame[0].time_copy+frequency[frq_chnl].frame[1].time_copy+frequency[frq_chnl].frame[
             -2].time_copy+frequency[frq_chnl].frame[3].time_copy));
 218   2      
 219   2                      if(temp_freq<=0xFFFF)
 220   2                      {
 221   3                              channels.frequency_buf=temp_freq;
 222   3                      }
 223   2                      else
 224   2                      {
 225   3                              channels.frequency_buf=0xFFFF;
 226   3                      } 
 227   2              }
 228   1              else //измерение высокой частоты
 229   1              {
 230   2                      if(handle_freq_flag==0)
 231   2                      {
 232   3                              return;
C51 COMPILER V9.00   FREQUENCY                                                             06/26/2014 09:13:09 PAGE 5   

 233   3                      }
 234   2      
 235   2                      handle_freq_flag=0;
 236   2      
 237   2                      poschet_intervalov++;
 238   2              
 239   2                       
 240   2      
 241   2                       TH1=TL1=0;
 242   2                       temp_Hz_kanal_sred+=temp_Hz_kanal_mgnov;
 243   2                       Hz_data_mgnov+=temp_Hz_kanal_mgnov;//*=10;
 244   2                       
 245   2                       if(poschet_intervalov==2)
 246   2                       {
 247   3                               Hz_data_mgnov*=5;
 248   3      
 249   3                                      if(Hz_data_mgnov<=0xFFFF)       //частота превышена
 250   3                                      {
 251   4                                              channels.frequency_buf=Hz_data_mgnov;
 252   4                                      }
 253   3                                      else
 254   3                                      {
 255   4                                              channels.frequency_buf=0xFFFF;
 256   4                                      }
 257   3      
 258   3                               Hz_data_mgnov=0;
 259   3                       }
 260   2              
 261   2              
 262   2              
 263   2              
 264   2                      if(poschet_intervalov==2) // вычисл€етс€ среднее значение частоты за 10 сек
 265   2                      {
 266   3                                       poschet_intervalov=0;
 267   3                              
 268   3                                   if(sec_kanal_sred!=kol_sec_sred+1&&!(period_kanal_sred%(1000/Period_sred)))  
 269   3                                       {
 270   4                                                sec_kanal_sred++;
 271   4                                       }
 272   3              
 273   3                                       if(sec_kanal_sred==kol_sec_sred+1)
 274   3                                       {
 275   4                                                sym_kanal_sred-=Hz_kanal_sred[period_kanal_sred/(1000/Period_sred)][period_kanal_sred%(1000/Period_
             -sred)];
 276   4                                                sym_kanal_sred+=temp_Hz_kanal_sred;
 277   4                                                Hz_data_sred=(float)sym_kanal_sred/(float)kol_sec_sred;
 278   4      
 279   4      
 280   4                                                      if(Hz_data_sred<=0xFFFF) //частота превышена
 281   4                                                      {
 282   5                                                              channels.mid_frequency_buf=Hz_data_sred;
 283   5                                                      }
 284   4                                                      else
 285   4                                                      {
 286   5                                                               channels.mid_frequency_buf=0xFFFF;
 287   5                                                      }
 288   4                                       }
 289   3                                       else
 290   3                                       {
 291   4                                                      sym_kanal_sred=sym_kanal_sred+temp_Hz_kanal_sred;
 292   4                                       }
 293   3                                       
C51 COMPILER V9.00   FREQUENCY                                                             06/26/2014 09:13:09 PAGE 6   

 294   3                                       Hz_kanal_sred[period_kanal_sred/(1000/Period_sred)][period_kanal_sred%(1000/Period_sred)]=temp_Hz_kan
             -al_sred;
 295   3                              
 296   3                                       if(period_kanal_sred<(kol_sec_sred*(1000/Period_sred))-1)      // подсчет периодов в 10 секундный интервал
 297   3                                       {
 298   4                                              period_kanal_sred++;
 299   4                                       }
 300   3                                       else
 301   3                                       {
 302   4                                          period_kanal_sred=0;
 303   4                                       }
 304   3              
 305   3                                       temp_Hz_kanal_sred=0;
 306   3              
 307   3                      }
 308   2                  cycl_kanal=0;
 309   2              }
 310   1       }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1803    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    105       2
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     16    ----
   IDATA SIZE       =     14    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
