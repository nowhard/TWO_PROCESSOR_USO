C51 COMPILER V9.00   CALIBRATE                                                             06/20/2014 09:13:37 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE CALIBRATE
OBJECT MODULE PLACED IN calibrate.obj
COMPILER INVOKED BY: C:\Program Files\Keil\C51\BIN\C51.EXE calibrate\calibrate.c LARGE OPTIMIZE(6,SPEED) BROWSE ORDER NO
                    -AREGS DEBUG OBJECTEXTEND PRINT(.\calibrate.lst) OBJECT(calibrate.obj)

line level    source

   1          #include "calibrate.h"
   2          //#pragma OT(6,Speed)
   3          //------------------------------------------------------------
   4          unsigned long GetCalibrateVal(unsigned char channel_num,unsigned long ADC_Code)   //преобразование значени
             -я АЦП в калиброванное значение         ??? проверить && debug
   5          {
   6   1              float result=0;
   7   1      
   8   1              result=ADC_Code*channels[channel_num].calibrate.cal.K+channels[channel_num].calibrate.cal.C;
   9   1      
  10   1              if(result>(float)0xFFFFFF)
  11   1              {
  12   2                      return 0xFFFFFF;
  13   2              }
  14   1              else
  15   1              {
  16   2                      if(result<0)
  17   2                      {
  18   3                              return 0;
  19   3                      }
  20   2                      else
  21   2                      {
  22   3                              return (unsigned long)result; 
  23   3                      }
  24   2              }
  25   1      }
  26          //------------------------------------------------------------
  27          void RestoreCalibrate(void)              //восстановление точек калибровки из EEPROM
  28          {
  29   1              unsigned char i=0;
  30   1              unsigned long crc=0,true_crc=0;
  31   1      
  32   1              for(i=0;i<CHANNEL_NUMBER;i++)
  33   1              {
  34   2                      EEPROM_Read(&channels[i].calibrate.serialize[0],3,ADC_CALIBRATE_ADDR+i*3);
  35   2              }
  36   1      
  37   1              true_crc= (unsigned long)Calibrate_Get_CRC();//расчет текущей CRC калибровок
  38   1              EEPROM_Read(&crc,1,CALIBRATE_DEVICE_CRC_ADDR);//считаем CRC настроек
  39   1      
  40   1              if(true_crc!=crc)
  41   1              {
  42   2                      Calibrate_Set_Default();
  43   2              }
  44   1      
  45   1              return;
  46   1      }
  47          //---------------------------------------------------------------
  48          void Calibrate(unsigned char channel_num,float K,float C) //общая функция калибровки
  49          {
  50   1                      unsigned long true_crc=0;
  51   1                      channels[channel_num].calibrate.cal.K= K;
  52   1                      channels[channel_num].calibrate.cal.C= C;
  53   1                      EEPROM_Write(&channels[channel_num].calibrate.serialize,3,ADC_CALIBRATE_ADDR+channel_num*3);
C51 COMPILER V9.00   CALIBRATE                                                             06/20/2014 09:13:37 PAGE 2   

  54   1      
  55   1                      true_crc= (unsigned long)Calibrate_Get_CRC();//расчет текущей CRC калибровок
  56   1                      EEPROM_Write(&true_crc,1,CALIBRATE_DEVICE_CRC_ADDR);//запомним CRC      
  57   1      
  58   1                      return;
  59   1      }
  60          //---------------------------------------------------------------
  61          unsigned char Calibrate_Get_CRC(void)//расчет crc  в eerprom
  62          {
  63   1               unsigned char crc = 0x0;
  64   1               unsigned char i=0,j=0;
  65   1      
  66   1           for(i=0;i<CHANNEL_NUMBER;i++)
  67   1               {
  68   2                      for(j=0;j<(3*sizeof(unsigned long));j++)
  69   2                      {
  70   3                              crc = Crc8Table[crc ^ (((unsigned char *)(&channels[i].calibrate.serialize))[j])];
  71   3                      }
  72   2               }
  73   1      
  74   1           return crc;
  75   1      }
  76          //---------------------------------------------------------------
  77          void Calibrate_Set_Flag(unsigned char channel,unsigned char flag)//установить/снять флаг калиброванности к
             -анала
  78          {
  79   1          unsigned long true_crc=0;
  80   1      
  81   1              if(flag==SET)
  82   1              {
  83   2                              channels[channel].calibrate.cal.calibrate=1;//установим/снимем флаг калибровки
  84   2                              EEPROM_Write(&channels[channel].calibrate.serialize,3,ADC_CALIBRATE_ADDR+channel*3);            
  85   2              }
  86   1              else
  87   1              {
  88   2                      if(flag==RESET)
  89   2                      {
  90   3                              channels[channel].calibrate.cal.calibrate=0;//установим/снимем флаг калибровки
  91   3                              EEPROM_Write(&channels[channel].calibrate.serialize,3,ADC_CALIBRATE_ADDR+channel*3);
  92   3                      }
  93   2              }
  94   1      
  95   1              true_crc= (unsigned long)Calibrate_Get_CRC();//расчет текущей CRC калибровок
  96   1              EEPROM_Write(&true_crc,1,CALIBRATE_DEVICE_CRC_ADDR);//запомним CRC      
  97   1      }
  98          //----------------------------------------------------------------
  99          void Calibrate_Set_Default(void)//установка калибровки по умолчанию(отключена)
 100          {
 101   1                      unsigned char i=0;
 102   1                  unsigned long true_crc=0;           
 103   1      
 104   1                      for(i=0;i<CHANNEL_NUMBER;i++)
 105   1                      {
 106   2                              Calibrate_Set_Flag(i,RESET);
 107   2                      }
 108   1                      
 109   1                      true_crc= (unsigned long)Calibrate_Get_CRC();//расчет текущей CRC калибровок
 110   1                      EEPROM_Write(&true_crc,1,CALIBRATE_DEVICE_CRC_ADDR);//запомним CRC              
 111   1      }
 112          //----------------------------------------------------------------


C51 COMPILER V9.00   CALIBRATE                                                             06/20/2014 09:13:37 PAGE 3   

MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    867    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----      45
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
