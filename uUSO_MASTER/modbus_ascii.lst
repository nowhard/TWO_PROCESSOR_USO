C51 COMPILER V9.00   MODBUS_ASCII                                                          06/20/2014 14:22:56 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE MODBUS_ASCII
OBJECT MODULE PLACED IN modbus_ascii.obj
COMPILER INVOKED BY: C:\Program Files\Keil\C51\BIN\C51.EXE modbus\modbus_ascii.c LARGE OPTIMIZE(6,SPEED) BROWSE ORDER NO
                    -AREGS DEBUG OBJECTEXTEND PRINT(.\modbus_ascii.lst) OBJECT(modbus_ascii.obj)

line level    source

   1          #include "modbus_ascii.h"
   2          #include <intrins.h>
   3          #include "proto_uso/channels.h"
   4          //-----------------------------------------------------------------------------------
   5          extern volatile unsigned char xdata ADRESS_DEV;
   6          
   7          extern volatile unsigned char xdata  RecieveBuf[]; //буфер принимаемых данных
   8          extern volatile unsigned char xdata  TransferBuf[]; //буфер передаваемых данных
   9          
  10           extern struct Channel xdata channels[CHANNEL_NUMBER];//обобщенная структура каналов
  11          //-----------------------LRC----------------------------------------------------------------------
  12          unsigned char LRC_Check(unsigned char * pucFrame, unsigned int usLen )//
  13          {
  14   1          unsigned char   ucLRC=0;  /* LRC char initialized */
  15   1      
  16   1          while( usLen )        
  17   1          {
  18   2              ucLRC += (MBCHAR2BIN(*pucFrame++)<<4|MBCHAR2BIN(*pucFrame++))&0xFF;   /* Add buffer byte without c
             -arry */
  19   2                      ucLRC&=0xFF;
  20   2                      usLen-=2;
  21   2          }
  22   1          /* Return twos complement */
  23   1              ucLRC=((ucLRC^0xFF)+1)&0xFF;
  24   1      
  25   1          return ucLRC;       
  26   1      }
  27          //-------------------------------------------------------------------------------------------------------
  28          unsigned char MBCHAR2BIN( unsigned char ucCharacter )//
  29          {
  30   1          if( ( ucCharacter >= '0' ) && ( ucCharacter <= '9' ) )
  31   1          {
  32   2              return ( unsigned char )( ucCharacter - '0' );
  33   2          }
  34   1          else if( ( ucCharacter >= 'A' ) && ( ucCharacter <= 'F' ) )
  35   1          {
  36   2              return ( unsigned char )( ucCharacter - 'A' + 0x0A );
  37   2          }
  38   1          else
  39   1          {
  40   2              return 0xFF;
  41   2          }
  42   1      }
  43          //----------------------------------------------------------------------------------------------
  44          unsigned char MBBIN2CHAR( unsigned char ucByte ) //
  45          {
  46   1          if( ucByte <= 0x09 )
  47   1          {
  48   2              return ( unsigned char )( '0' + ucByte );
  49   2          }
  50   1          else if( ( ucByte >= 0x0A ) && ( ucByte <= 0x0F ) )
  51   1          {
  52   2              return ( unsigned char )( ucByte - 0x0A + 'A' );
  53   2          }
C51 COMPILER V9.00   MODBUS_ASCII                                                          06/20/2014 14:22:56 PAGE 2   

  54   1          else
  55   1          {
  56   2                      return 0xFF;
  57   2          }
  58   1          return '0';
  59   1      }
  60          //-----------------------------------------------------------------------------------------------
  61          unsigned int Sym_4_To_Int(unsigned char * pucFrame)//
  62          {
  63   1              union
  64   1              {
  65   1                      unsigned int result_int;
  66   1                      unsigned char result_char[2];
  67   1              }
  68   1              sym_4_to_int;
  69   1              sym_4_to_int.result_char[0]=(unsigned char)MBCHAR2BIN(pucFrame[0])<<4 | (unsigned char)MBCHAR2BIN(pucFram
             -e[1]);
  70   1              sym_4_to_int.result_char[1]=(unsigned char)MBCHAR2BIN(pucFrame[2])<<4 | (unsigned char)MBCHAR2BIN(pucFram
             -e[3]);
  71   1              
  72   1              return sym_4_to_int.result_int; 
  73   1      }
  74          //-----------------------------------------------------------------------------------------------
  75          unsigned char Sym_2_To_Char(unsigned char * pucFrame)//
  76          {
  77   1              unsigned char result_char;
  78   1      
  79   1              result_char= (unsigned char)MBCHAR2BIN(pucFrame[0])<<4 | (unsigned char)MBCHAR2BIN(pucFrame[1]);
  80   1              return result_char; 
  81   1      }
  82          //-----------------------------------------------------------------------------------------------
  83          void Int_To_Sym_4(unsigned int val, unsigned char* buf)//
  84          {
  85   1              union
  86   1              {
  87   1                      unsigned int int_num;
  88   1                      unsigned char result_char[2];
  89   1              }
  90   1              int_to_sym_4;
  91   1              
  92   1              int_to_sym_4.int_num=val;
  93   1      
  94   1              buf[1]=MBBIN2CHAR(int_to_sym_4.result_char[0]&0xF);
  95   1              buf[0]=MBBIN2CHAR((int_to_sym_4.result_char[0]>>4)&0xF);
  96   1              buf[3]=MBBIN2CHAR(int_to_sym_4.result_char[1]&0xF);
  97   1              buf[2]=MBBIN2CHAR((int_to_sym_4.result_char[1]>>4)&0xF);
  98   1      
  99   1              return;
 100   1      }
 101          //-----------------------------------------------------------------------------------------------
 102          void Char_To_Sym_2(unsigned char val, unsigned char* buf)//
 103          {       
 104   1              buf[0]=(unsigned char)MBBIN2CHAR( (unsigned char)((val>>4)&0xF));
 105   1              buf[1]=(unsigned char)MBBIN2CHAR( (unsigned char)(val&0xF));    
 106   1      }
 107          //-----------------------------------------------------------------------------------------------
 108          unsigned long Sym_8_To_Long(unsigned char * pucFrame)//
 109          {
 110   1              union
 111   1              {
 112   1                      unsigned long result_long;
 113   1                      unsigned char result_char[4];
C51 COMPILER V9.00   MODBUS_ASCII                                                          06/20/2014 14:22:56 PAGE 3   

 114   1              }
 115   1              sym_8_to_long;
 116   1      
 117   1              sym_8_to_long.result_char[0]=(unsigned char)MBCHAR2BIN(pucFrame[0])<<4 | (unsigned char)MBCHAR2BIN(pucFra
             -me[1]);
 118   1              sym_8_to_long.result_char[1]=(unsigned char)MBCHAR2BIN(pucFrame[2])<<4 | (unsigned char)MBCHAR2BIN(pucFra
             -me[3]);
 119   1              sym_8_to_long.result_char[2]=(unsigned char)MBCHAR2BIN(pucFrame[4])<<4 | (unsigned char)MBCHAR2BIN(pucFra
             -me[5]);
 120   1              sym_8_to_long.result_char[3]=(unsigned char)MBCHAR2BIN(pucFrame[6])<<4 | (unsigned char)MBCHAR2BIN(pucFra
             -me[7]);        
 121   1      
 122   1              return sym_8_to_long.result_long;                       
 123   1      }
 124          //-----------------------------------------------------------------------------------------------
 125          void Long_To_Sym_8(unsigned long val, unsigned char* buf)//
 126          {
 127   1         unsigned char i;
 128   1      
 129   1              for(i=0;i<8;i++)
 130   1              {
 131   2                      buf[i]=MBBIN2CHAR( (unsigned char)((val&0xF0000000)>>28));
 132   2                      val=val<<4;     
 133   2              }
 134   1      }
 135          
 136          //-----------------------------------------------------------------------------
 137          //unsigned char SetSingleRegister(void)
 138          //{
 139          //      static unsigned int   addr;
 140          //      static unsigned int   val;
 141          //      static unsigned char i;
 142          //
 143          //      addr=Sym_4_To_Int(&RecieveBuf[5]);
 144          //      num=Sym_4_To_Int(&RecieveBuf[9]);
 145          //
 146          //      if(addr>=REG_ADDR_MIN && addr<=REG_ADDR_MAX)
 147          //      {
 148          //              //controller_reg[addr]=val;     //устанавливаем значение регистра
 149          //      }
 150          //      else
 151          //      {
 152          //              return 0;
 153          //      }
 154          //
 155          //      for(i=0;i<buf_count;i++)
 156          //      {
 157          //              TransferBuf[i]= RecieveBuf[i];  
 158          //      }
 159          //
 160          //      return buf_count;//
 161          //      
 162          //      return;
 163          //}
 164          //-----------------------------------------------------------------------------
 165          unsigned char ReadHoldingReg(void)
 166          {
 167   1        #define HEAD_LEN      7
 168   1      //[addr_sym_1|addr_sym_2|func_sym_1|func_sym_2|1st|2st|3st|4st|1n|2n|3n|4n|lrc1|lrc2]
 169   1      //[             head       |............]       
 170   1              static unsigned char  i=0,count=0;
 171   1              static unsigned char  LRC=0x0;
C51 COMPILER V9.00   MODBUS_ASCII                                                          06/20/2014 14:22:56 PAGE 4   

 172   1              static unsigned int   addr;
 173   1              static unsigned int   len;
 174   1              
 175   1              count=0;
 176   1      
 177   1              addr=Sym_4_To_Int(&RecieveBuf[3]);
 178   1              len= Sym_4_To_Int(&RecieveBuf[5]);
 179   1      
 180   1              if(addr>=REG_ADDR_MIN && addr<=(REG_ADDR_MIN+CHANNEL_NUMBER) && len<=CHANNEL_NUMBER)  
 181   1              {                       
 182   2                      TransferBuf[0]=':';
 183   2                      count++;
 184   2      
 185   2                      Char_To_Sym_2(ADRESS_DEV,&TransferBuf[1]);
 186   2                      count+=2;
 187   2      
 188   2                      Char_To_Sym_2(MB_FUNC_READ_HOLDING_REGISTER,&TransferBuf[3]);
 189   2                      count+=2;
 190   2      
 191   2                      //----
 192   2                      count+=2;//счетчик байт, вставим после вставки данных
 193   2                      //----
 194   2      
 195   2                      for(i=addr;i<((addr+len)>>1);i++) //в устройстве все регистры 4-байтовые
 196   2                      {
 197   3                              Long_To_Sym_8(channels[i].channel_data,&TransferBuf[count]);
 198   3                              count+=8;
 199   3                      }               
 200   2      
 201   2                      Char_To_Sym_2(count-HEAD_LEN,&TransferBuf[5]);
 202   2                      
 203   2                      LRC=LRC_Check(&TransferBuf[1],(count-1));
 204   2                      
 205   2                      Char_To_Sym_2(LRC,&TransferBuf[count]);
 206   2                      count+=2;
 207   2                      
 208   2                      TransferBuf[count]='\r';
 209   2                      TransferBuf[count]='\n';
 210   2                      count+=2;                                                                            
 211   2              }
 212   1              else
 213   1              {
 214   2                      return 0;
 215   2              }
 216   1      
 217   1              return count;
 218   1      }
 219          //-----------------------------------------------------------------------------------
 220          //#pragma OT(0,Speed) 
 221          //PT_THREAD(ProtoProcess(struct pt *pt))
 222          // {
 223          // static unsigned char  LRC=0x0;
 224          //  PT_BEGIN(pt);
 225          //
 226          //  while(1) 
 227          //  {
 228          //  //----------restart------------
 229          //              recieve_count=0x0;//??
 230          //              REN=1;//recieve enqble
 231          //              DE_RE=0;//линия на прием
 232          //              ES=1;
 233          //  //-----------------------------
C51 COMPILER V9.00   MODBUS_ASCII                                                          06/20/2014 14:22:56 PAGE 5   

 234          //        // PT_WAIT_UNTIL(pt,RECIEVED); //ждем команды на старт
 235          //         wdt_count[Proto_Proc].process_state=IDLE;
 236          //
 237          //         PT_YIELD_UNTIL(pt,RECIEVED); //ждем команды на старт 
 238          //         wdt_count[Proto_Proc].count++;
 239          //
 240          //
 241          //        
 242          //          RECIEVED=0;
 243          //              
 244          //              if((unsigned char)(MBCHAR2BIN(RecieveBuf[1])<<4| MBCHAR2BIN(RecieveBuf[2]))!=DEV_ADDRESS)
 245          //              {
 246          //                      PT_RESTART(pt); 
 247          //              }       
 248          //                              
 249          //              
 250          //              LRC=((MBCHAR2BIN(RecieveBuf[buf_count-LRC_LEN])<<4)|(MBCHAR2BIN(RecieveBuf[buf_count-LRC_LEN+1])));
 251          //                                      
 252          //              if(LRC_Check(&RecieveBuf,(buf_count-LRC_LEN))!=LRC)
 253          //              {
 254          //                      PT_RESTART(pt);//если LRC не сошлось-перезапустим протокол                       
 255          //              }
 256          //
 257          //
 258          //      //      PT_YIELD(pt);//дадим другим процессам время
 259          //  //-----------------------------
 260          //              ProtoBufHandling();//процедура обработки сообщения      
 261          //              if(buf_len==0)//если в буфере пусто
 262          //              {
 263          //                      PT_RESTART(pt);//перезапустим протокол  
 264          //              }
 265          //              else
 266          //              {
 267          //                      DE_RE=1; //переключаем RS485 в режим передачи
 268          //                                                      
 269          //                      REN=0;  //запрет приема-только передача
 270          //                      transf_count=0;
 271          //                      CUT_OUT_NULL=0;
 272          //                      SBUF=TransferBuf[transf_count];//передача байта, остальным займется автомат
 273          //                      transf_count++;//инкрементируем счетчик переданных
 274          //                      ES=1; //включим прерывание уарт 
 275          //
 276          //                      PT_DELAY(pt,10);                        
 277          //              }               
 278          //  //-----------------------------
 279          //  }
 280          //
 281          // PT_END(pt);
 282          //}
 283          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    997    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      7      22
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
