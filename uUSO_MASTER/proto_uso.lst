C51 COMPILER V9.00   PROTO_USO                                                             06/20/2014 09:13:36 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE PROTO_USO
OBJECT MODULE PLACED IN proto_uso.obj
COMPILER INVOKED BY: C:\Program Files\Keil\C51\BIN\C51.EXE proto_uso\proto_uso.c LARGE OPTIMIZE(6,SPEED) BROWSE ORDER NO
                    -AREGS DEBUG OBJECTEXTEND PRINT(.\proto_uso.lst) OBJECT(proto_uso.obj)

line level    source

   1          #include "proto_uso.h"
   2          #include "calibrate\calibrate.h"
   3          #include "i2c.h"
   4          #include <intrins.h>
   5          #include "crc_table.h"
   6          #include "channels.h"
   7          #include "watchdog.h"
   8          //-----------------------------------------------------------------------------------
   9          
  10          sbit DE_RE=P3^5;
  11          
  12          //-----------------------------------------------------------------------------------
  13          volatile unsigned char xdata DEV_NAME[DEVICE_NAME_LENGTH_SYM] ="<<uUSO_2>>"; //имя устройства
  14          volatile unsigned char xdata NOTICE[DEVICE_DESC_MAX_LENGTH_SYM]="<-- GEOSPHERA_2012 -->";//примечание   
  15          volatile unsigned char xdata VERSION[DEVICE_VER_LENGTH_SYM] ="\x30\x30\x30\x30\x31";    // версия программы П
             -ЗУ        не больше 5 байт
  16          
  17          volatile unsigned char xdata ADRESS_DEV=0x1;
  18          
  19          volatile unsigned char xdata dev_desc_len=20;//длина описания устройства
  20          //--------------------------------global variable------------------------------------
  21          volatile unsigned char idata    RECIEVED=0;//принято
  22          volatile unsigned char xdata    recieve_count;//счетчик приемного буфера
  23          volatile unsigned char xdata    transf_count;//счетчик передаваемых байтов         
  24          volatile unsigned char xdata    buf_len;//длина передаваемого буфера
  25          
  26          //------------------------флаги ошибок--------------------------------
  27          volatile unsigned char idata  CUT_OUT_NULL;//флаг-вырезаем 0 после 0xD7
  28          volatile unsigned char xdata frame_len=0;//длина кадра, которую вытаскиваем из шестого байта кадра
  29          //--------------------------------------------------------------------
  30          volatile unsigned char xdata  RecieveBuf[MAX_LENGTH_REC_BUF]={0} ; //буфер принимаемых данных
  31          //volatile unsigned char xdata                  *TransferBuf;
  32          volatile unsigned char xdata  TransferBuf[MAX_LENGTH_TR_BUF]={0} ; //буфер передаваемых данных
  33          //--------------------------------------------------------------------
  34          volatile unsigned char xdata  STATE_BYTE=0xC0;//байт состояния устройства
  35          volatile unsigned char idata symbol=0xFF;//принятый символ
  36          
  37          volatile unsigned char xdata protocol_type=PROTO_TYPE_NEW;//тип протокола
  38          
  39          volatile struct pt pt_proto;
  40          //-----------------------------------------------------------------------------------
  41          union //объединение для конвертирования char->long
  42          {
  43                  float result_float;
  44                  unsigned char result_char[4];
  45          }
  46          sym_8_to_float;
  47          
  48          extern unsigned char idata i2c_buffer[6];
  49          extern unsigned char channel_number;//количество каналов
  50          
  51          //-----------------------------------------------------------------------------------
  52          //#pragma OT(0,Speed)
  53          void UART_ISR(void) interrupt 4 //using 1
C51 COMPILER V9.00   PROTO_USO                                                             06/20/2014 09:13:36 PAGE 2   

  54          {       
  55   1              EA=0;   //запрет прерывания
  56   1              
  57   1              if(RI)
  58   1              {
  59   2                      RI=0; 
  60   2      //----------------------обрабатываем возможные ошибки длины кадра-------------
  61   2                      if(recieve_count>MAX_LENGTH_REC_BUF)    //если посылка слишком длинная
  62   2                      {
  63   3                              PT_RESTART_OUT(pt_proto);  //внепроцессный рестарт
  64   3                              return;
  65   3                      } 
  66   2      
  67   2      
  68   2                      symbol=SBUF;
  69   2                      wdt_count[Proto_Proc].process_state=RUN;
  70   2                      switch(symbol)
  71   2                      {
  72   3                              case (char)(0xD7):
  73   3                              {
  74   4                                      RecieveBuf[recieve_count]=symbol;
  75   4                                      recieve_count++;
  76   4                                      CUT_OUT_NULL=1;          
  77   4                              }
  78   3                              break;
  79   3      
  80   3                              case (char)(0x29):
  81   3                              {
  82   4                                      if(CUT_OUT_NULL==1)
  83   4                                      {
  84   5                                              RecieveBuf[0]=0x0;
  85   5                                              RecieveBuf[1]=0xD7;
  86   5                                              RecieveBuf[2]=0x29;
  87   5                                              recieve_count=0x3;
  88   5                                              protocol_type=PROTO_TYPE_NEW;                   
  89   5                                      }
  90   4                                      else
  91   4                                      {
  92   5                                              RecieveBuf[recieve_count]=symbol;
  93   5                                              recieve_count++;        
  94   5                                      }
  95   4                                      CUT_OUT_NULL=0;
  96   4                              }
  97   3                              break;
  98   3      
  99   3                              case (char)(0x28):
 100   3                              {
 101   4                                      if(CUT_OUT_NULL==1)
 102   4                                      {
 103   5                                              RecieveBuf[0]=0x0;
 104   5                                              RecieveBuf[1]=0xD7;
 105   5                                              RecieveBuf[2]=0x28;
 106   5                                              recieve_count=0x3;
 107   5                                              protocol_type=PROTO_TYPE_OLD;                   
 108   5                                      }
 109   4                                      else
 110   4                                      {
 111   5                                              RecieveBuf[recieve_count]=symbol;
 112   5                                              recieve_count++;        
 113   5                                      }
 114   4                                      CUT_OUT_NULL=0;
 115   4                              }
C51 COMPILER V9.00   PROTO_USO                                                             06/20/2014 09:13:36 PAGE 3   

 116   3                              break;
 117   3      
 118   3                              case (char)(0x0):
 119   3                              {
 120   4                                      if(CUT_OUT_NULL==1)       //если после 0xD7-пропускаем
 121   4                                      {
 122   5                                              CUT_OUT_NULL=0;         
 123   5                                      }
 124   4                                      else
 125   4                                      {
 126   5                                              RecieveBuf[recieve_count]=symbol;
 127   5                                              recieve_count++;        
 128   5                                      }
 129   4                              }
 130   3                              break;
 131   3      
 132   3                              default :
 133   3                              {
 134   4                                      RecieveBuf[recieve_count]=symbol;
 135   4                                      recieve_count++;
 136   4                                      CUT_OUT_NULL=0;
 137   4                                      
 138   4                              }
 139   3                      }
 140   2      
 141   2                 if(recieve_count>6)
 142   2                 {
 143   3                                if(recieve_count==6+frame_len)          // принимаем указанное в frame_len число байт данные, 6 значит чт
             -о обмен идет с компом, надо ставаить 5 чтобы обмениваться с устройствами
 144   3                                {
 145   4                                              RECIEVED=1;//буфер принят
 146   4                                              ES=0;
 147   4                                              REN=0;  //recieve disable -запрещаем принимать в буфер  
 148   4                                              CUT_OUT_NULL=0;                                                 
 149   4                                }       
 150   3                 }
 151   2                 else
 152   2                 {
 153   3                                 if(recieve_count==6)
 154   3                                 {     
 155   4                                      
 156   4                                              frame_len=RecieveBuf[recieve_count-1];  // получаем длину данных после заголовка
 157   4                                              if(protocol_type==PROTO_TYPE_OLD)
 158   4                                              {
 159   5                                                      frame_len&=0x1F;//в старом протоколе только 5 младших бит -длина оставшейся части       
 160   5                                              }                                        
 161   4                                 }                    
 162   3                 }                                                                            
 163   2              }
 164   1      //----------------------------передача----------------------------------------------------------------
 165   1              if(TI)
 166   1              {
 167   2                      TI=0;
 168   2                       
 169   2                      if(transf_count<buf_len)
 170   2                      {
 171   3                              if((transf_count<3)||(protocol_type==PROTO_TYPE_OLD))//передаем заголовок или все подряд, если старый п
             -ротокол
 172   3                              {
 173   4                                      SBUF=TransferBuf[transf_count];                 
 174   4                                      transf_count++;
 175   4                              }
C51 COMPILER V9.00   PROTO_USO                                                             06/20/2014 09:13:36 PAGE 4   

 176   3                              else   //тело...   подставляем 0 после 0xD7
 177   3                              {
 178   4                                              if(CUT_OUT_NULL==0)
 179   4                                              {
 180   5                                                      if(TransferBuf[transf_count]==(unsigned char)0xD7)//проверим, это  ,0xD7 или другое
 181   5                                                      {                       
 182   6                                                              CUT_OUT_NULL=0x1;       
 183   6                                                      }
 184   5                                                      SBUF=TransferBuf[transf_count];                 
 185   5                                                      transf_count++;
 186   5                                              }
 187   4                                              else
 188   4                                              {
 189   5                                                      SBUF=(unsigned char)0x0;
 190   5                                                      CUT_OUT_NULL=0;         
 191   5                                              }       
 192   4                              }       
 193   3                      }
 194   2                      else
 195   2                      {
 196   3                              transf_count=0;         //обнуляем счетчик
 197   3                              CUT_OUT_NULL=0;
 198   3                              PT_RESTART_OUT(pt_proto);  //внепроцессный рестарт                      
 199   3                      }                                          
 200   2              }                       
 201   1              EA=1;
 202   1              return;
 203   1      }
 204          //------------------------------------------------------------------------------
 205          //#pragma OT(6,Speed)
 206          void Protocol_Init(void) //using 0
 207          {
 208   1              TI=0;
 209   1              RI=0;
 210   1              
 211   1      //      TransferBuf=&RecieveBuf[0];      //буфер ответа =буфер запроса
 212   1      
 213   1              Restore_Dev_Address_Desc();
 214   1      
 215   1      
 216   1              recieve_count=0x0;//счетчик буфера приема
 217   1              transf_count=0x0;//счетчик передаваемых байтов
 218   1              buf_len=0x0;//длина передаваемого буфера
 219   1              DE_RE=0;//линия на прием
 220   1              CUT_OUT_NULL=0;
 221   1              STATE_BYTE=0xC0;
 222   1              PT_INIT(&pt_proto);
 223   1              return;
 224   1      }
 225          //-----------------------------------------------------------------------------
 226          unsigned char Send_Info(void) //using 0    //посылка информации об устройстве
 227          {
 228   1                  unsigned char    i=0;
 229   1                                                                                      
 230   1                 //заголовок кадра---
 231   1                 TransferBuf[0]=0x00;
 232   1                 TransferBuf[1]=0xD7;
 233   1                 TransferBuf[2]=0x29;
 234   1                 //------------------
 235   1                 TransferBuf[3]=ADRESS_DEV;  // адрес узла
 236   1                 TransferBuf[4]=GET_DEV_INFO_RESP;  // код операции
 237   1                 TransferBuf[6]=STATE_BYTE;
C51 COMPILER V9.00   PROTO_USO                                                             06/20/2014 09:13:36 PAGE 5   

 238   1      
 239   1                 for(i=0;i<20;i++)
 240   1                 {                              // записываем наименование изделия
 241   2                                 if(i<DEVICE_NAME_LENGTH_SYM)
 242   2                                 {
 243   3                                      TransferBuf[i+7]=DEV_NAME[i];
 244   3                                 }
 245   2                                 else
 246   2                                 {
 247   3                                              TransferBuf[i+7]=0x00;
 248   3                                 }
 249   2                      }
 250   1              
 251   1                 for(i=0;i<5;i++)                   // записываем версию ПЗУ
 252   1                 {
 253   2                     if(i<DEVICE_VER_LENGTH_SYM)
 254   2                         {
 255   3                               TransferBuf[i+27]=VERSION[i];
 256   3                         }
 257   2                 }
 258   1      
 259   1                 TransferBuf[32]=channel_number;                 // количество каналов
 260   1      
 261   1                 for(i=0;i<channel_number;i++)                                   // данные по каналу
 262   1             {
 263   2                              TransferBuf[i*2+33]=((channels[i].settings.set.type)<<4)|channels[i].settings.set.modific; // байт да
             -нных
 264   2                              TransferBuf[i*2+33+1]=0x00;                                                     // резерв байт
 265   2                 }    
 266   1                 for(i=0;i<dev_desc_len;i++)                                  // записываем примечание
 267   1                 {
 268   2                               TransferBuf[i+33+channel_number*2]=NOTICE[i];
 269   2                 }
 270   1                              
 271   1                 TransferBuf[5]=28+channel_number*2+dev_desc_len;                     // подсчет длины данных 
 272   1                 TransferBuf[33+channel_number*2+dev_desc_len]=CRC_Check(&TransferBuf[1],32+channel_number*2+dev_desc_l
             -en); // подсчет контрольной суммы
 273   1      
 274   1              return (34+channel_number*2+dev_desc_len);
 275   1      }
 276          //-----------------------------------------------------------------------------
 277          unsigned char Node_Full_Init(void) //using 0 //полная инициализация узла
 278          {
 279   1              return 0;
 280   1      }
 281          //-----------------------------------------------------------------------------
 282          unsigned char Channel_List_Init(void) //using 0 //Инициализация списка каналов узла (без потери данных);
 283          {
 284   1              return 0;
 285   1      }
 286          //-----------------------------------------------------------------------------
 287          unsigned char Channel_Get_Data(void) //using 0 //Выдать данные по каналам, согласно абсолютной нумерации;
 288          {
 289   1              return 0;
 290   1      }
 291          //-----------------------------------------------------------------------------
 292          unsigned char  Channel_Set_Parameters(void) //using 0 //Установить параметры по каналам, согласно абсолютн
             -ой нумерации;
 293          {
 294   1             unsigned char  index=0, store_data=0;//i=0;
 295   1               
 296   1                 while(index<RecieveBuf[5]-1)                            // данные по каналам
C51 COMPILER V9.00   PROTO_USO                                                             06/20/2014 09:13:36 PAGE 6   

 297   1                    {
 298   2                                      if(RecieveBuf[6+index]<channel_number)
 299   2                                  {
 300   3                                              switch((RecieveBuf[6+index+1]>>4)&0xF)
 301   3                                              {
 302   4                                                              case CHNL_ADC://АЦП
 303   4                                                              {
 304   5                                                                      if((channels[RecieveBuf[6+index]].settings.set.modific!=RecieveBuf[6+index+1])||(channels[RecieveB
             -uf[6+index]].settings.set.state_byte_1!=RecieveBuf[6+index+2]) || (channels[RecieveBuf[6+index]].settings.set.state_byte
             -_2!=RecieveBuf[6+index+3]))
 305   5                                                                      {  
 306   6                                                                              channels[RecieveBuf[6+index]].settings.set.state_byte_1=RecieveBuf[6+index+2];
 307   6                                                                              channels[RecieveBuf[6+index]].settings.set.state_byte_2=RecieveBuf[6+index+3];
 308   6                                                                              channels[RecieveBuf[6+index]].settings.set.modific         =RecieveBuf[6+index+1]&0xF;
 309   6                                                                              store_data=1;
 310   6                                                                              
 311   6                                                                      }
 312   5                                                                      index++;
 313   5                                                              }
 314   4                                                              break;
 315   4      
 316   4      
 317   4                                                              default :
 318   4                                                              {
 319   5                                                                      _nop_();
 320   5                                                              }                       
 321   4                                              }
 322   3                                              index=index+3;
 323   3                                      }
 324   2                                      else
 325   2                                      {
 326   3                                              return Request_Error(FR_UNATTENDED_CHANNEL);
 327   3                                      }
 328   2                        }
 329   1                 if(store_data)
 330   1                 {
 331   2                              Store_Channels_Data();  //сохраним настройки каналов в ППЗУ
 332   2                 }
 333   1      
 334   1                 return Request_Error(FR_SUCCESFUL);
 335   1      }
 336          //-----------------------------------------------------------------------------
 337          unsigned char Channel_Set_Order_Query(void) //using 0 //Задать последовательность опроса;
 338          {
 339   1              return 0;
 340   1      }
 341          //-----------------------------------------------------------------------------
 342          unsigned char Channel_Get_Data_Order(void) //using 0 //Выдать данные по каналам, согласно последовательнос
             -ти опроса;
 343          {
 344   1              return 0;
 345   1      }
 346          //-----------------------------------------------------------------------------
 347          unsigned char Channel_Set_State(void) //using 0 //Установить состояния по каналам, согласно абсолютной нум
             -ерации;
 348          {
 349   1              return 0;
 350   1      }
 351          //-----------------------------------------------------------------------------
 352          unsigned char  Channel_Get_Data_Order_M2(void) //using 0 //Выдать данные по каналам, согласно последовател
             -ьности опроса;
 353          {
C51 COMPILER V9.00   PROTO_USO                                                             06/20/2014 09:13:36 PAGE 7   

 354   1              return 0;
 355   1      }
 356          //-----------------------------------------------------------------------------
 357          unsigned char Channel_Set_Reset_State_Flags(void) //using 0 //  Установка/Сброс флагов состояния 
 358          {
 359   1              STATE_BYTE=0x40;
 360   1              i2c_buffer[0]=0x12;//сбросим флаг инициализации ведомого
 361   1              ChannelsInit();
 362   1              return  Request_Error(FR_SUCCESFUL);//ошибки нет, подтверждение
 363   1      }
 364          //-----------------------------------------------------------------------------
 365          #pragma OT(9,Speed)
 366          unsigned char Channel_All_Get_Data(void) //using 0 //Выдать информацию по всем каналам узла (расширенный р
             -ежим);
 367          {
 368   1         unsigned char data index=0,i=0;
 369   1      
 370   1      
 371   1         TransferBuf[0]=0x00;TransferBuf[1]=0xD7;TransferBuf[2]=0x29;
 372   1         TransferBuf[3]=ADRESS_DEV;  // адрес узла
 373   1         TransferBuf[4]=CHANNEL_ALL_GET_DATA_RESP;  // код операции
 374   1         TransferBuf[6]=STATE_BYTE;
 375   1      
 376   1         index=7;//длина заголовка
 377   1       
 378   1          for(i=0;i<channel_number;i++)                                  // данные по каналам
 379   1          {
 380   2                        TransferBuf[index++]=i;
 381   2                        TransferBuf[index++]=((channels[i].settings.set.type)<<4)|channels[i].settings.set.modific; // тип и м
             -одификация канала
 382   2                        switch(channels[i].settings.set.type)
 383   2                          {
 384   3                                       case CHNL_ADC:  //аналоговый канал
 385   3                                       {
 386   4                                               switch(channels[i].settings.set.modific)
 387   4                               {
 388   5                                                        case CHNL_ADC_FIX_16:
 389   5                                                        {
 390   6                                                                      if(channels[i].calibrate.cal.calibrate==1)//калиброванный
 391   6                                                                      {                                                
 392   7                                                                                      TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data_calibrate))[2];
 393   7                                                                              TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data_calibrate))[1];
 394   7                                                                      }
 395   6                                                                      else
 396   6                                                                      {
 397   7                                                                                      TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data))[2];
 398   7                                                                              TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data))[1];  
 399   7                                                                      } 
 400   6      
 401   6                                                                        
 402   6                                                                       TransferBuf[index++]=channels[i].settings.set.state_byte_1;     // первый байт состояния канала
 403   6                                               TransferBuf[index++]=channels[i].settings.set.state_byte_2;     // второй байт сос
             -тояния канала
 404   6                                                        }
 405   5                                                        break; 
 406   5      
 407   5                                                        case CHNL_ADC_FIX_24:
 408   5                                                        {
 409   6                                                              if(channels[i].calibrate.cal.calibrate==1)//калиброванный
 410   6                                                                      {                                                                                                 
 411   7                                                                                      TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data_calibrate))[3];
 412   7                                                                                      TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data_calibrate))[2];
C51 COMPILER V9.00   PROTO_USO                                                             06/20/2014 09:13:36 PAGE 8   

 413   7                                                                              TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data_calibrate))[1];
 414   7                                                                      }
 415   6                                                                      else
 416   6                                                                      {                                                                        
 417   7                                                                                      TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data))[3];
 418   7                                                                                      TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data))[2];
 419   7                                                                              TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data))[1];  
 420   7                                                                      } 
 421   6                        
 422   6                                                                        TransferBuf[index++]=channels[i].settings.set.state_byte_1;    // первый байт состояния канала
 423   6                                                TransferBuf[index++]=channels[i].settings.set.state_byte_2;    // второй байт со
             -стояния канала
 424   6                                                        }
 425   5                                                        break;
 426   5                                                }
 427   4                                        }
 428   3                                        break;
 429   3      
 430   3                                      case CHNL_DOL:   //ДОЛ
 431   3                                      {
 432   4                                                switch(channels[i].settings.set.modific)
 433   4                                            {   
 434   5                                                                case CHNL_DOL_ENC:
 435   5                                                                {
 436   6                                                                                      TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data))[3];
 437   6                                                                                      TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data))[2];
 438   6                                                                              TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data))[1];
 439   6                                                                                      TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data))[0];
 440   6                                                                                  TransferBuf[index++]=channels[i].settings.set.state_byte_1;  // первый байт состояния канала
 441   6                                                                }
 442   5                                                                break; 
 443   5                                                 }
 444   4                                      }
 445   3                                      break;
 446   3      
 447   3                                       case CHNL_FREQ: //частотный
 448   3                                       { 
 449   4                                                switch(channels[i].settings.set.modific)
 450   4                                            {   
 451   5                                                                
 452   5                                                                case CHNL_FREQ_COUNT_T:
 453   5                                                                {
 454   6                                                                                      TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data))[3];
 455   6                                                                                      TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data))[2];
 456   6                                                                                TransferBuf[index++]=channels[i].settings.set.state_byte_1;    // первый байт состояния канала
 457   6                                                                }
 458   5                                                                break;
 459   5      
 460   5                                                                case CHNL_FREQ_256:
 461   5                                                                {
 462   6                                                                                      TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data))[3];
 463   6                                                                                      TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data))[2];
 464   6                                                                                  TransferBuf[index++]=channels[i].settings.set.state_byte_1;  // первый байт состояния канала
 465   6                                                                }
 466   5                                                                break; 
 467   5                                                 }
 468   4                                        }
 469   3                                        break;                 
 470   3                        }
 471   2                 }
 472   1      
 473   1                TransferBuf[5]=index+2-7;                                              // подсчет длины данных двойка это 1(байт статуса)+1(контрольная сумма
C51 COMPILER V9.00   PROTO_USO                                                             06/20/2014 09:13:36 PAGE 9   

             -)
 474   1                TransferBuf[index]=CRC_Check(&TransferBuf[1],(unsigned int)(index)-1); // подсчет кс
 475   1                return (unsigned char)(index+1);
 476   1      }
 477          //-----------------------------------------------------------------------------
 478          #pragma OT(0,Speed)
 479          unsigned char Channel_Set_Calibrate(void)//установить верхнюю или нижнюю точку калибровки
 480          {
 481   1      
 482   1              float K,C;      
 483   1      
 484   1              sym_8_to_float.result_char[0]=RecieveBuf[11];
 485   1              sym_8_to_float.result_char[1]=RecieveBuf[10];
 486   1              sym_8_to_float.result_char[2]=RecieveBuf[9];
 487   1              sym_8_to_float.result_char[3]=RecieveBuf[8];
 488   1      
 489   1              K=sym_8_to_float.result_float;
 490   1      
 491   1              sym_8_to_float.result_char[0]=RecieveBuf[15];
 492   1              sym_8_to_float.result_char[1]=RecieveBuf[14];
 493   1              sym_8_to_float.result_char[2]=RecieveBuf[13];
 494   1              sym_8_to_float.result_char[3]=RecieveBuf[12];
 495   1      
 496   1              C=sym_8_to_float.result_float;
 497   1      
 498   1              switch(RecieveBuf[7])
 499   1              {
 500   2                      case 0:
 501   2                      {
 502   3                              Calibrate(RecieveBuf[6],K,C);   
 503   3                      }
 504   2                      break;
 505   2      
 506   2                      case 1:
 507   2                      {
 508   3                              Calibrate_Set_Flag(RecieveBuf[6],RESET);
 509   3                      }
 510   2                      break;
 511   2      
 512   2                      case 2:
 513   2                      {
 514   3                              Calibrate_Set_Flag(RecieveBuf[6],SET);  
 515   3                      }
 516   2                      break;
 517   2      
 518   2                      default :
 519   2                      {
 520   3                              _nop_();
 521   3                      }
 522   2                      break;
 523   2              }
 524   1      
 525   1      
 526   1              return  Request_Error(FR_SUCCESFUL);//ошибки нет, подтверждение 
 527   1      }
 528          //------------------------------------------------------------------------------
 529          unsigned char Channel_Get_Calibrate_Value(void)//получить коэфициенты калибровки заданного канала
 530          {
 531   1         unsigned char data channel=0;
 532   1      
 533   1      
 534   1         TransferBuf[0]=0x00;TransferBuf[1]=0xD7;TransferBuf[2]=0x29;
C51 COMPILER V9.00   PROTO_USO                                                             06/20/2014 09:13:36 PAGE 10  

 535   1         TransferBuf[3]=ADRESS_DEV;  // адрес узла
 536   1         TransferBuf[4]=CHANNEL_GET_CALIBRATE_RESP;  // код операции
 537   1         TransferBuf[5]=0xB;//длина оставшейся части кадра
 538   1      
 539   1      
 540   1         channel=RecieveBuf[6];
 541   1      
 542   1         if(channel>=channel_number)
 543   1         {
 544   2                      return Request_Error(FR_COMMAND_STRUCT_ERROR);//непрвильный номер канала        
 545   2         }
 546   1      
 547   1         TransferBuf[6]=channel;
 548   1      
 549   1         TransferBuf[7]=channels[channel].calibrate.cal.calibrate;
 550   1      
 551   1         sym_8_to_float.result_float=channels[channel].calibrate.cal.K;
 552   1      
 553   1              TransferBuf[11]=sym_8_to_float.result_char[0];
 554   1              TransferBuf[10]=sym_8_to_float.result_char[1];
 555   1              TransferBuf[9]=sym_8_to_float.result_char[2];
 556   1              TransferBuf[8]=sym_8_to_float.result_char[3];
 557   1      
 558   1         sym_8_to_float.result_float=channels[channel].calibrate.cal.C;
 559   1      
 560   1              TransferBuf[15]=sym_8_to_float.result_char[0];
 561   1              TransferBuf[14]=sym_8_to_float.result_char[1];
 562   1              TransferBuf[13]=sym_8_to_float.result_char[2];
 563   1              TransferBuf[12]=sym_8_to_float.result_char[3];
 564   1      
 565   1              TransferBuf[16]=CRC_Check(&TransferBuf[1],15); // подсчет кс
 566   1              return 0x11;//17        
 567   1      }
 568          //------------------------------------------------------------------------------
 569          unsigned char Channel_Set_Address_Desc(void)//установить новый адрес устройства, имя, описание, версию про
             -шивки и комментарий
 570          {
 571   1              unsigned char  desc_len=0;
 572   1              desc_len=RecieveBuf[5]-27;
 573   1      
 574   1              if(desc_len)
 575   1              {       
 576   2                      Store_Dev_Address_Desc(RecieveBuf[6],&RecieveBuf[7],&RecieveBuf[27],&RecieveBuf[32],desc_len);
 577   2                      return    Request_Error(FR_SUCCESFUL);//ошибки нет, подтверждение
 578   2              }
 579   1              else
 580   1              {
 581   2                      return Request_Error(FR_COMMAND_STRUCT_ERROR);
 582   2              }
 583   1              return 0;
 584   1      }
 585          //-----------------------------------------------------------------------------
 586          unsigned char Channel_Set_All_Default(void)//установить настройки и калибровки каналов по умолчанию
 587          {
 588   1              Channels_Set_Default();
 589   1              Calibrate_Set_Default();
 590   1              return  Request_Error(FR_SUCCESFUL);//ошибки нет, подтверждение         
 591   1      }
 592          //-----------------------------------------------------------------------------
 593          unsigned char Request_Error(unsigned char error_code) //using 0 //      Ошибочный запрос/ответ;
 594          {
 595   1              TransferBuf[0]=0x00;TransferBuf[1]=0xD7;TransferBuf[2]=0x29;
C51 COMPILER V9.00   PROTO_USO                                                             06/20/2014 09:13:36 PAGE 11  

 596   1          TransferBuf[3]=ADRESS_DEV;  // адрес узла
 597   1          TransferBuf[7]=RecieveBuf[4]; // код сбойной команды
 598   1          TransferBuf[4]=0xFF;  // код операции
 599   1      
 600   1              TransferBuf[6]=STATE_BYTE; // байт статуса узла
 601   1          TransferBuf[8]=error_code;   
 602   1          TransferBuf[5]=0x04;          // длина данных
 603   1          TransferBuf[9]=CRC_Check(TransferBuf,9);
 604   1              return 10;
 605   1      }
 606          
 607          //-----------------------------------------------------------------------------
 608          unsigned char Old_CRC_Check(unsigned char xdata *Spool_pr,unsigned char Count_pr)
 609          {
 610   1           unsigned char crc = 0x0;
 611   1               unsigned char i=0;
 612   1      
 613   1               for(i=0;i<Count_pr;i++)
 614   1               {
 615   2                      CY=0;
 616   2                      crc+=Spool_pr[i];
 617   2                      if(CY)
 618   2                      {
 619   3                              crc++;
 620   3                      }
 621   2               }
 622   1               crc=0xFF-crc;
 623   1      
 624   1           return crc;        
 625   1      }
 626          //-----------------------------------------------------------------------------
 627          unsigned char Old_Channel_Get_Data(void)
 628          {
 629   1        unsigned char channel=0;
 630   1        unsigned char len=0;
 631   1        channel=((RecieveBuf[4]>>3)&0x1F);
 632   1        if(channel<CHANNEL_NUMBER)
 633   1        {  
 634   2                 TransferBuf[0]=0x00;TransferBuf[1]=0xD7;TransferBuf[2]=0x28;
 635   2                 TransferBuf[3]=0x0;  // 
 636   2                 TransferBuf[4]=RecieveBuf[4];
 637   2                 TransferBuf[5]=((OLD_CHANNEL_GET_DATA<<5)&0x1F)|0x3;//0x63;// код операции   
 638   2      
 639   2                              switch(channels[channel].settings.set.type)
 640   2                          {
 641   3                                       case CHNL_ADC:  //аналоговый канал
 642   3                                       {
 643   4                                               switch(channels[channel].settings.set.modific)
 644   4                               {
 645   5                                                        case CHNL_ADC_FIX_16:
 646   5                                                        {
 647   6                                                                      if(channels[channel].calibrate.cal.calibrate==1)//калиброванный
 648   6                                                                      {                                                
 649   7                                                                                      TransferBuf[6]=((unsigned char*)(&channels[channel].channel_data_calibrate))[1];
 650   7                                                                              TransferBuf[7]=((unsigned char*)(&channels[channel].channel_data_calibrate))[2];
 651   7                                                                      }
 652   6                                                                      else
 653   6                                                                      {
 654   7                                                                                      TransferBuf[6]=((unsigned char*)(&channels[channel].channel_data))[1];
 655   7                                                                              TransferBuf[7]=((unsigned char*)(&channels[channel].channel_data))[2];  
 656   7                                                                      }                                       
 657   6                                                        }
C51 COMPILER V9.00   PROTO_USO                                                             06/20/2014 09:13:36 PAGE 12  

 658   5                                                        break; 
 659   5      
 660   5                                                        case CHNL_ADC_FIX_24:
 661   5                                                        {
 662   6                                                              if(channels[channel].calibrate.cal.calibrate==1)//калиброванный
 663   6                                                                      {                                                                                                 
 664   7                                                                                      TransferBuf[channel]=((unsigned char*)(&channels[channel].channel_data_calibrate))[1];
 665   7                                                                              TransferBuf[channel]=((unsigned char*)(&channels[channel].channel_data_calibrate))[2];
 666   7                                                                      }
 667   6                                                                      else
 668   6                                                                      {                                                                        
 669   7                                                                                      TransferBuf[6]=((unsigned char*)(&channels[channel].channel_data))[1];
 670   7                                                                              TransferBuf[7]=((unsigned char*)(&channels[channel].channel_data))[2];  
 671   7                                                                      }
 672   6      
 673   6                                                        }
 674   5                                                        break;
 675   5                                                }                                       
 676   4                                        }
 677   3                                        break;
 678   3      
 679   3                                      case CHNL_DOL:   //ДОЛ
 680   3                                      {
 681   4                                                switch(channels[channel].settings.set.modific)
 682   4                                            {   
 683   5                                                                case CHNL_DOL_ENC:
 684   5                                                                {
 685   6                                                                                      TransferBuf[6]=((unsigned char*)(&channels[channel].channel_data))[2];
 686   6                                                                                      TransferBuf[7]=((unsigned char*)(&channels[channel].channel_data))[3];
 687   6      //                                                                      TransferBuf[channel]=((unsigned char*)(&channels[channel].channel_data))[0];
 688   6      //                                                                              TransferBuf[channel]=((unsigned char*)(&channels[channel].channel_data))[1];
 689   6                                                                }
 690   5                                                                break; 
 691   5                                                 }
 692   4                                      }
 693   3                                      break;
 694   3      
 695   3                                       case CHNL_FREQ: //частотный
 696   3                                       { 
 697   4                                                switch(channels[channel].settings.set.modific)
 698   4                                            {   
 699   5                                                                
 700   5                                                                case CHNL_FREQ_COUNT_T:
 701   5                                                                {
 702   6                                                                                      TransferBuf[6]=((unsigned char*)(&channels[channel].channel_data))[2];
 703   6                                                                                      TransferBuf[7]=((unsigned char*)(&channels[channel].channel_data))[3];
 704   6      
 705   6                                                                }
 706   5                                                                break;
 707   5      
 708   5                                                                case CHNL_FREQ_256:
 709   5                                                                {
 710   6                                                                                      TransferBuf[6]=((unsigned char*)(&channels[channel].channel_data))[2];
 711   6                                                                                      TransferBuf[7]=((unsigned char*)(&channels[channel].channel_data))[3];
 712   6                                                                }
 713   5                                                                break; 
 714   5                                                 }                                       
 715   4                                        }
 716   3                                        break;                 
 717   3                        }
 718   2                 
 719   2                 len=Old_Proto_Paste_Null(TransferBuf,8);
C51 COMPILER V9.00   PROTO_USO                                                             06/20/2014 09:13:36 PAGE 13  

 720   2      
 721   2                 TransferBuf[len]=Old_CRC_Check(TransferBuf,len);
 722   2                 return len+1;
 723   2         }
 724   1         return 0;    
 725   1      }
 726          //-----------------------------------------------------------------------------
 727          unsigned char Old_Channel_Get_Data_State(void)
 728          {
 729   1        unsigned char channel=0;
 730   1        unsigned char len=0;
 731   1        channel=((RecieveBuf[4]>>3)&0x1F);
 732   1        if(channel<CHANNEL_NUMBER)
 733   1        {
 734   2                 TransferBuf[0]=0x00;TransferBuf[1]=0xD7;TransferBuf[2]=0x28;
 735   2                 TransferBuf[3]=0x0;  // 
 736   2                 TransferBuf[4]=RecieveBuf[4];
 737   2                 TransferBuf[5]=((OLD_CHANNEL_GET_DATA_STATE<<5)&0x1F)|0x6;//0x66;// код операции     
 738   2      
 739   2                              switch(channels[channel].settings.set.type)
 740   2                          {
 741   3                                       case CHNL_ADC:  //аналоговый канал
 742   3                                       {
 743   4                                               switch(channels[channel].settings.set.modific)
 744   4                               {
 745   5                                                        case CHNL_ADC_FIX_16:
 746   5                                                        {
 747   6                                                                      if(channels[channel].calibrate.cal.calibrate==1)//калиброванный
 748   6                                                                      {                                                
 749   7                                                                                      TransferBuf[6]=((unsigned char*)(&channels[channel].channel_data_calibrate))[1];
 750   7                                                                              TransferBuf[7]=((unsigned char*)(&channels[channel].channel_data_calibrate))[2];
 751   7                                                                      }
 752   6                                                                      else
 753   6                                                                      {
 754   7                                                                                      TransferBuf[6]=((unsigned char*)(&channels[channel].channel_data))[1];
 755   7                                                                              TransferBuf[7]=((unsigned char*)(&channels[channel].channel_data))[2];  
 756   7                                                                      }                                       
 757   6                                                        }
 758   5                                                        break; 
 759   5      
 760   5                                                        case CHNL_ADC_FIX_24:
 761   5                                                        {
 762   6                                                              if(channels[channel].calibrate.cal.calibrate==1)//калиброванный
 763   6                                                                      {                                                                                                 
 764   7                                                                                      TransferBuf[channel]=((unsigned char*)(&channels[channel].channel_data_calibrate))[1];
 765   7                                                                              TransferBuf[channel]=((unsigned char*)(&channels[channel].channel_data_calibrate))[2];
 766   7                                                                      }
 767   6                                                                      else
 768   6                                                                      {                                                                        
 769   7                                                                                      TransferBuf[6]=((unsigned char*)(&channels[channel].channel_data))[1];
 770   7                                                                              TransferBuf[7]=((unsigned char*)(&channels[channel].channel_data))[2];  
 771   7                                                                      }
 772   6      
 773   6                                                        }
 774   5                                                        break;
 775   5                                                }
 776   4                                                
 777   4                                                switch(channels[channel].settings.set.state_byte_1&0x7)
 778   4                                                {
 779   5                                                              case PROTO_ADC_AMP_1:
 780   5                                                              {
 781   6                                                                      TransferBuf[8]=(0x00|(OLD_PROTO_ADC_AMP_1<<1))&0xFE;     // первый байт состояния канала
C51 COMPILER V9.00   PROTO_USO                                                             06/20/2014 09:13:36 PAGE 14  

 782   6                                                              }
 783   5                                                              break;
 784   5      
 785   5                                                              case PROTO_ADC_AMP_2:
 786   5                                                              {
 787   6                                                                      TransferBuf[8]=(0x00|(OLD_PROTO_ADC_AMP_2<<1))&0xFE;     // первый байт состояния канала        
 788   6                                                              }
 789   5                                                              break;
 790   5      
 791   5                                                              case PROTO_ADC_AMP_32:
 792   5                                                              {
 793   6                                                                      TransferBuf[8]=(0x00|(OLD_PROTO_ADC_AMP_32<<1))&0xFE;    // первый байт состояния канала        
 794   6                                                              }
 795   5                                                              break;
 796   5      
 797   5                                                              case PROTO_ADC_AMP_128:
 798   5                                                              {
 799   6                                                                      TransferBuf[8]=(0x00|(OLD_PROTO_ADC_AMP_128<<1))&0xFE;   // первый байт состояния канала
 800   6                                                              }
 801   5                                                              break;
 802   5      
 803   5                                                              default :
 804   5                                                              {
 805   6                                                                      TransferBuf[8]=(0x00|(OLD_PROTO_ADC_AMP_1<<1))&0xFE;     // первый байт состояния канала
 806   6                                                              }
 807   5                                                              break;
 808   5                                                }
 809   4                                                
 810   4                                                TransferBuf[9]=0x0A;   // второй байт состояния канала
 811   4      
 812   4                                        }
 813   3                                        break;
 814   3      
 815   3                                case CHNL_DOL:         //ДОЛ
 816   3                                {
 817   4                                        switch(channels[channel].settings.set.modific)
 818   4                                    {   
 819   5                                                        case CHNL_DOL_ENC:
 820   5                                                        {
 821   6                                                                      TransferBuf[6]=((unsigned char*)(&channels[channel].channel_data))[2];
 822   6                                                                      TransferBuf[7]=((unsigned char*)(&channels[channel].channel_data))[3];
 823   6      //                                                                      TransferBuf[channel]=((unsigned char*)(&channels[channel].channel_data))[0];
 824   6      //                                                                              TransferBuf[channel]=((unsigned char*)(&channels[channel].channel_data))[1];
 825   6      
 826   6                                                                      
 827   6      
 828   6                                                                      switch(channels[channel].settings.set.state_byte_1&0x7)
 829   6                                                                      {
 830   7                                                                                      case PROTO_ADC_AMP_1:
 831   7                                                                                      {
 832   8                                                                                              TransferBuf[8]=(0x40|(OLD_PROTO_ADC_AMP_1<<1))&0xFE;     // первый байт состояния канала
 833   8                                                                                      }
 834   7                                                                                      break;
 835   7                              
 836   7                                                                                      case PROTO_ADC_AMP_2:
 837   7                                                                                      {
 838   8                                                                                              TransferBuf[8]=(0x40|(OLD_PROTO_ADC_AMP_2<<1))&0xFE;     // первый байт состояния канала        
 839   8                                                                                      }
 840   7                                                                                      break;
 841   7                              
 842   7                                                                                      case PROTO_ADC_AMP_32:
 843   7                                                                                      {
C51 COMPILER V9.00   PROTO_USO                                                             06/20/2014 09:13:36 PAGE 15  

 844   8                                                                                              TransferBuf[8]=(0x40|(OLD_PROTO_ADC_AMP_32<<1))&0xFE;    // первый байт состояния канала        
 845   8                                                                                      }
 846   7                                                                                      break;
 847   7                              
 848   7                                                                                      case PROTO_ADC_AMP_128:
 849   7                                                                                      {
 850   8                                                                                              TransferBuf[8]=(0x40|(OLD_PROTO_ADC_AMP_128<<1))&0xFE;   // первый байт состояния канала
 851   8                                                                                      }
 852   7                                                                                      break;
 853   7                              
 854   7                                                                                      default :
 855   7                                                                                      {
 856   8                                                                                              TransferBuf[8]=(0x40|(OLD_PROTO_ADC_AMP_1<<1))&0xFE;
 857   8                                                                                      }
 858   7                                                                                      break;                  
 859   7                                                                      }
 860   6                                                                      TransferBuf[9]=0x00;     // второй байт состояния канала
 861   6                                                        }
 862   5                                                        break; 
 863   5                                                 }
 864   4                                      }
 865   3                                      break;
 866   3      
 867   3                                       case CHNL_FREQ: //частотный
 868   3                                       { 
 869   4                                                switch(channels[channel].settings.set.modific)
 870   4                                            {   
 871   5                                                                
 872   5                                                                case CHNL_FREQ_COUNT_T:
 873   5                                                                {
 874   6                                                                                      TransferBuf[6]=((unsigned char*)(&channels[channel].channel_data))[2];
 875   6                                                                                      TransferBuf[7]=((unsigned char*)(&channels[channel].channel_data))[3];
 876   6      
 877   6                                                                }
 878   5                                                                break;
 879   5      
 880   5                                                                case CHNL_FREQ_256:
 881   5                                                                {
 882   6                                                                                      TransferBuf[6]=((unsigned char*)(&channels[channel].channel_data))[2];
 883   6                                                                                      TransferBuf[7]=((unsigned char*)(&channels[channel].channel_data))[3];
 884   6                                                                }
 885   5                                                                break; 
 886   5                                                 }
 887   4                                                 
 888   4                                              TransferBuf[8]=0x40;     // первый байт состояния канала
 889   4                                      TransferBuf[9]=0x00;     // второй байт состояния канала
 890   4                                        }
 891   3                                        break;                 
 892   3                        }
 893   2      
 894   2                 TransferBuf[10]=0xFF;
 895   2      
 896   2                 len=Old_Proto_Paste_Null(TransferBuf,11);
 897   2      
 898   2                 TransferBuf[len]=Old_CRC_Check(TransferBuf,len);
 899   2                 return len+1;
 900   2         }
 901   1         return 0;
 902   1      
 903   1      }
 904          //-----------------------------------------------------------------------------
 905          unsigned char Old_Channel_Get_State(void)
C51 COMPILER V9.00   PROTO_USO                                                             06/20/2014 09:13:36 PAGE 16  

 906          {
 907   1        unsigned char channel=0;
 908   1        unsigned char len=0;
 909   1        channel=((RecieveBuf[4]>>3)&0x1F);
 910   1        if(channel<CHANNEL_NUMBER)
 911   1        {
 912   2        
 913   2                 TransferBuf[0]=0x00;TransferBuf[1]=0xD7;TransferBuf[2]=0x28;
 914   2                 TransferBuf[3]=0x0;  // 
 915   2                 TransferBuf[4]=RecieveBuf[4];
 916   2                 TransferBuf[5]=((OLD_CHANNEL_GET_STATE<<5)&0x1F)|0x3;//0x43;// код операции  
 917   2      
 918   2                              switch(channels[channel].settings.set.type)
 919   2                          {
 920   3                                       case CHNL_ADC:  //аналоговый канал
 921   3                                       {                
 922   4                                                switch(channels[channel].settings.set.state_byte_1&0x7)
 923   4                                                {
 924   5                                                              case PROTO_ADC_AMP_1:
 925   5                                                              {
 926   6                                                                      TransferBuf[6]=0x00|(OLD_PROTO_ADC_AMP_1<<1);    // первый байт состояния канала
 927   6                                                              }
 928   5                                                              break;
 929   5      
 930   5                                                              case PROTO_ADC_AMP_2:
 931   5                                                              {
 932   6                                                                      TransferBuf[6]=0x00|(OLD_PROTO_ADC_AMP_2<<1);    // первый байт состояния канала        
 933   6                                                              }
 934   5                                                              break;
 935   5      
 936   5                                                              case PROTO_ADC_AMP_32:
 937   5                                                              {
 938   6                                                                      TransferBuf[6]=0x00|(OLD_PROTO_ADC_AMP_32<<1);   // первый байт состояния канала        
 939   6                                                              }
 940   5                                                              break;
 941   5      
 942   5                                                              case PROTO_ADC_AMP_128:
 943   5                                                              {
 944   6                                                                      TransferBuf[6]=0x00|(OLD_PROTO_ADC_AMP_128<<1);  // первый байт состояния канала
 945   6                                                              }
 946   5                                                              break;
 947   5      
 948   5                                                              default :
 949   5                                                              {
 950   6                                                                      TransferBuf[6]=0x00|(OLD_PROTO_ADC_AMP_1<<1);    // первый байт состояния канала
 951   6                                                              }
 952   5                                                              break;
 953   5                                                }
 954   4                                                
 955   4                                                TransferBuf[7]=0x0A;   // второй байт состояния канала
 956   4                                        }
 957   3                                        break;
 958   3      
 959   3                                      case CHNL_DOL:   //ДОЛ
 960   3                                      {
 961   4      
 962   4                                                      switch(channels[channel].settings.set.state_byte_1&0x7)
 963   4                                                      {
 964   5                                                                      case PROTO_ADC_AMP_1:
 965   5                                                                      {
 966   6                                                                              TransferBuf[6]=0x40|(OLD_PROTO_ADC_AMP_1<<1);    // первый байт состояния канала
 967   6                                                                      }
C51 COMPILER V9.00   PROTO_USO                                                             06/20/2014 09:13:36 PAGE 17  

 968   5                                                                      break;
 969   5              
 970   5                                                                      case PROTO_ADC_AMP_2:
 971   5                                                                      {
 972   6                                                                              TransferBuf[6]=0x40|(OLD_PROTO_ADC_AMP_2<<1);    // первый байт состояния канала        
 973   6                                                                      }
 974   5                                                                      break;
 975   5              
 976   5                                                                      case PROTO_ADC_AMP_32:
 977   5                                                                      {
 978   6                                                                              TransferBuf[6]=0x40|(OLD_PROTO_ADC_AMP_32<<1);   // первый байт состояния канала        
 979   6                                                                      }
 980   5                                                                      break;
 981   5              
 982   5                                                                      case PROTO_ADC_AMP_128:
 983   5                                                                      {
 984   6                                                                              TransferBuf[6]=0x40|(OLD_PROTO_ADC_AMP_128<<1);  // первый байт состояния канала
 985   6                                                                      }
 986   5                                                                      break;
 987   5              
 988   5                                                                      default :
 989   5                                                                      {
 990   6                                                                              TransferBuf[6]=0x40;     // первый байт состояния канала
 991   6                                                                      }
 992   5                                                                      break;
 993   5              
 994   5                                                      }
 995   4                                                      TransferBuf[7]=0x00;     // второй байт состояния канала
 996   4                                      }
 997   3                                      break;
 998   3      
 999   3                                       case CHNL_FREQ: //частотный
1000   3                                       { 
1001   4                                                 
1002   4                                              TransferBuf[6]=0x40;     // первый байт состояния канала
1003   4                                      TransferBuf[7]=0x00;     // второй байт состояния канала
1004   4                                       }
1005   3                                       break;          
1006   3                        }
1007   2                 
1008   2                 len=Old_Proto_Paste_Null(TransferBuf,8);
1009   2      
1010   2                 TransferBuf[len]=Old_CRC_Check(TransferBuf,len);
1011   2                 return len+1;
1012   2         }
1013   1         return 0;    
1014   1      }
1015          //-----------------------------------------------------------------------------
1016          unsigned char Old_Reinit_Block(void)
1017          {
1018   1              return 0;       
1019   1      }
1020          //-----------------------------------------------------------------------------
1021          unsigned char Old_Channel_Set_ADC_Range(void)
1022          {
1023   1        unsigned char channel=0;
1024   1        channel=((RecieveBuf[4]>>3)&0x1F);
1025   1        if(channel<CHANNEL_NUMBER)
1026   1        {     
1027   2              switch((RecieveBuf[6]>>1)&0x3)
1028   2              {
1029   3                              case OLD_PROTO_ADC_AMP_1:
C51 COMPILER V9.00   PROTO_USO                                                             06/20/2014 09:13:36 PAGE 18  

1030   3                              {
1031   4                                   channels[channel].settings.set.state_byte_1&=0xF0;
1032   4                                       channels[channel].settings.set.state_byte_1|=PROTO_ADC_AMP_1;
1033   4                              }
1034   3                              break;
1035   3      
1036   3                              case OLD_PROTO_ADC_AMP_2:
1037   3                              {
1038   4                                       channels[channel].settings.set.state_byte_1&=0xF0;
1039   4                                       channels[channel].settings.set.state_byte_1|=PROTO_ADC_AMP_2;
1040   4                              }
1041   3                              break;
1042   3      
1043   3                              case OLD_PROTO_ADC_AMP_32:
1044   3                              {
1045   4                                       channels[channel].settings.set.state_byte_1&=0xF0;
1046   4                                       channels[channel].settings.set.state_byte_1|=PROTO_ADC_AMP_32;
1047   4                              }
1048   3                              break;
1049   3      
1050   3                              case OLD_PROTO_ADC_AMP_128:
1051   3                              {
1052   4                                   channels[channel].settings.set.state_byte_1&=0xF0;
1053   4                                       channels[channel].settings.set.state_byte_1|=PROTO_ADC_AMP_128;
1054   4                              }
1055   3                              break;
1056   3      
1057   3                              default :
1058   3                              {
1059   4                                   channels[channel].settings.set.state_byte_1&=0xF0;
1060   4                                       channels[channel].settings.set.state_byte_1|=PROTO_ADC_AMP_1;
1061   4                              }
1062   3                              break;
1063   3              }
1064   2        }
1065   1        return 0;
1066   1      }
1067          //-----------------------------------------------------------------------------
1068          unsigned char Old_Proto_Paste_Null(unsigned char *buf,unsigned char len)//т.к. старый протокол прибавляет 
             -к длине количество 0 после D7 то обрабатываем вне прерывания
1069          {
1070   1              volatile unsigned char xdata i=0,j=0;
1071   1      
1072   1              for(i=3;i<len;i++) //пропустим заголовок 0x00 0xD7 0x28
1073   1              {
1074   2                       if(buf[i]==0xD7)
1075   2                       {
1076   3                               for(j=(len-1);j>i;j--)
1077   3                               {
1078   4                                      buf[j+1]=buf[j];//сдвигаем элементы буфера вправо на одну позицию до D7
1079   4                               }
1080   3                               buf[i+1]=0x0;//вставляем 0x00 после 0xD7
1081   3                               buf[5]++;//длина кадра увеличилась на 1
1082   3                               len++;
1083   3                               i++;//не проверяем 0 спереди
1084   3                       }
1085   2              }
1086   1              return len;
1087   1      }
1088          //-----------------------------------------------------------------------------
1089          void ProtoBufHandling(void) //using 0 //процесс обработки принятого запроса
1090          {
C51 COMPILER V9.00   PROTO_USO                                                             06/20/2014 09:13:36 PAGE 19  

1091   1              if(protocol_type==PROTO_TYPE_NEW)
1092   1              {
1093   2                        channels[11].settings.set.state_byte_1=0x40; //восстановим байты статуса дола
1094   2                        channels[11].settings.set.state_byte_2=0x0A;
1095   2                        switch(RecieveBuf[4])
1096   2                        {
1097   3                      //---------------------------------------
1098   3                              case GET_DEV_INFO_REQ:
1099   3                              {
1100   4                                      buf_len=Send_Info();    
1101   4                              }
1102   3                              break;
1103   3                      //---------------------------------------
1104   3                              case NODE_FULL_INIT_REQ:
1105   3                              {
1106   4                                      buf_len=Node_Full_Init();
1107   4                              }
1108   3                              break;
1109   3                      //---------------------------------------
1110   3                              case CHANNEL_LIST_INIT_REQ:
1111   3                              {       
1112   4                                      buf_len=Channel_List_Init();    
1113   4                              }
1114   3                              break;
1115   3                      //---------------------------------------
1116   3                              case CHANNEL_GET_DATA_REQ:
1117   3                              {
1118   4                                      buf_len=Channel_Get_Data();     
1119   4                              }
1120   3                              break;
1121   3                              //-----------------------------------
1122   3                              case CHANNEL_SET_PARAMETERS_REQ:
1123   3                              {
1124   4                                      buf_len=Channel_Set_Parameters();
1125   4                              }
1126   3                              break;
1127   3                              //-----------------------------------
1128   3                              case CHANNEL_SET_ORDER_QUERY_REQ:
1129   3                              {
1130   4                                      buf_len=Channel_Set_Order_Query();
1131   4                              }
1132   3                              break;
1133   3                      //----------------------------------------
1134   3                              case CHANNEL_GET_DATA_ORDER_REQ:
1135   3                              {
1136   4                                       buf_len=Channel_Get_Data_Order();
1137   4                              }
1138   3                              break;
1139   3                      //----------------------------------------
1140   3                              case CHANNEL_SET_STATE_REQ:
1141   3                              {
1142   4                                       buf_len=Channel_Set_State();
1143   4                              }
1144   3                              break;
1145   3                      //----------------------------------------
1146   3                              case CHANNEL_GET_DATA_ORDER_M2_REQ:
1147   3                              {
1148   4                                       buf_len=Channel_Get_Data_Order_M2();
1149   4                              }
1150   3                              break;
1151   3                      //------------------------------------------
1152   3                              case CHANNEL_SET_RESET_STATE_FLAGS_REQ:
C51 COMPILER V9.00   PROTO_USO                                                             06/20/2014 09:13:36 PAGE 20  

1153   3                              {
1154   4                                      buf_len=Channel_Set_Reset_State_Flags();
1155   4                              }
1156   3                              break;
1157   3                      //------------------------------------------
1158   3                              case CHANNEL_ALL_GET_DATA_REQ:
1159   3                              {
1160   4                                       buf_len=Channel_All_Get_Data();
1161   4                              }
1162   3                              break;
1163   3                      //------------------------------------------
1164   3                              case CHANNEL_SET_ADDRESS_DESC:
1165   3                              {
1166   4                                       buf_len=Channel_Set_Address_Desc();
1167   4                              }
1168   3                              break;
1169   3                      //------------------------------------------
1170   3                              case CHANNEL_SET_CALIBRATE:
1171   3                              {
1172   4                                       buf_len=Channel_Set_Calibrate();
1173   4                              }
1174   3                              break;
1175   3                      //------------------------------------------
1176   3                              case CHANNEL_SET_ALL_DEFAULT:
1177   3                              {
1178   4                                       buf_len=Channel_Set_All_Default();
1179   4                              }
1180   3                              break;
1181   3                      //------------------------------------------
1182   3                              case CHANNEL_GET_CALIBRATE_REQ:
1183   3                              {
1184   4                                       buf_len=Channel_Get_Calibrate_Value();
1185   4                              }
1186   3                              break;
1187   3                      //------------------------------------------
1188   3                          default:
1189   3                              {
1190   4                                 buf_len=Request_Error(FR_COMMAND_NOT_EXIST);
1191   4                          }                                                              
1192   3                        }
1193   2              }
1194   1              else //старый протокол
1195   1              {
1196   2                        switch((RecieveBuf[5]>>5)&0x7)
1197   2                        {
1198   3                      //---------------------------------------
1199   3                              case OLD_CHANNEL_REINIT_BLOCK:
1200   3                              {
1201   4                                      buf_len=Old_Reinit_Block();     
1202   4                              }
1203   3                              break;
1204   3                      //---------------------------------------
1205   3                              case OLD_CHANNEL_SET_ADC_RANGE:
1206   3                              {
1207   4                                      buf_len=Old_Channel_Set_ADC_Range();
1208   4                              }
1209   3                              break;
1210   3                      //---------------------------------------
1211   3                              case OLD_CHANNEL_GET_STATE:
1212   3                              {       
1213   4                                      buf_len=Old_Channel_Get_State();        
1214   4                              }
C51 COMPILER V9.00   PROTO_USO                                                             06/20/2014 09:13:36 PAGE 21  

1215   3                              break;
1216   3                      //---------------------------------------
1217   3                              case OLD_CHANNEL_GET_DATA:
1218   3                              {
1219   4                                      buf_len=Old_Channel_Get_Data(); 
1220   4                              }
1221   3                              break;
1222   3                              //-----------------------------------
1223   3                              case OLD_CHANNEL_GET_DATA_STATE:
1224   3                              {
1225   4                                      buf_len=Old_Channel_Get_Data_State();
1226   4                              }
1227   3                              break;
1228   3                              //-----------------------------------
1229   3                          default:
1230   3                              {
1231   4                                 
1232   4                          }                                                              
1233   3                        }             
1234   2              }
1235   1      
1236   1        return;
1237   1      }
1238          //-----------------------------------------------------------------------------------
1239          //#pragma OT(0,Speed) 
1240          PT_THREAD(ProtoProcess(struct pt *pt))
1241           {
1242   1       static unsigned char  CRC=0x0;
1243   1        PT_BEGIN(pt);
1244   3      
1245   3        while(1) 
1246   3        {
1247   4        //----------restart------------
1248   4                      recieve_count=0x0;//??
1249   4                      REN=1;//recieve enqble
1250   4                      DE_RE=0;//линия на прием
1251   4                      ES=1;
1252   4        //-----------------------------
1253   4                // PT_WAIT_UNTIL(pt,RECIEVED); //ждем команды на старт
1254   4                 wdt_count[Proto_Proc].process_state=IDLE;
1255   4      
1256   4                 PT_YIELD_UNTIL(pt,RECIEVED); //ждем команды на старт 
1257   4                 wdt_count[Proto_Proc].count++;
1258   4                // WDT_Clear();//если посылка не приходит-сбрасываем
1259   4      
1260   4                
1261   4                  RECIEVED=0;
1262   4                      
1263   4                      if((protocol_type==PROTO_TYPE_NEW)&&(RecieveBuf[3]!=ADRESS_DEV))//если адрес совпал       
1264   4                      {
1265   5                              PT_RESTART(pt);//если адрес не сошелся-перезапустим протокол                    
1266   5                      }       
1267   4                                      
1268   4                  CRC=RecieveBuf[recieve_count-1];
1269   4                      
1270   4                      if(protocol_type==PROTO_TYPE_NEW)
1271   4                      {               
1272   5                              if(CRC_Check(&RecieveBuf,(recieve_count-CRC_LEN))!=CRC)
1273   5                              {
1274   6                                      PT_RESTART(pt);//если CRC не сошлось-перезапустим протокол       
1275   6                              }
1276   5                      }
C51 COMPILER V9.00   PROTO_USO                                                             06/20/2014 09:13:36 PAGE 22  

1277   4                      else
1278   4                      {
1279   5                              if(Old_CRC_Check(&RecieveBuf,(recieve_count-CRC_LEN))!=CRC)
1280   5                              {
1281   6                                      PT_RESTART(pt);//если CRC не сошлось-перезапустим протокол       
1282   6                              }                       
1283   5                      }
1284   4              //      PT_YIELD(pt);//дадим другим процессам время
1285   4        //-----------------------------
1286   4                      ProtoBufHandling();//процедура обработки сообщения      
1287   4                      if(buf_len==0)//если в буфере пусто
1288   4                      {
1289   5                              PT_RESTART(pt);//перезапустим протокол  
1290   5                      }
1291   4                      else
1292   4                      {
1293   5                              DE_RE=1; //переключаем RS485 в режим передачи
1294   5                                                              
1295   5                              REN=0;  //запрет приема-только передача
1296   5                              transf_count=0;
1297   5                              CUT_OUT_NULL=0;
1298   5                              SBUF=TransferBuf[transf_count];//передача байта, остальным займется автомат
1299   5                              transf_count++;//инкрементируем счетчик переданных
1300   5                              ES=1; //включим прерывание уарт 
1301   5      
1302   5                          if(protocol_type==PROTO_TYPE_NEW)
1303   5                              {
1304   6                                      PT_DELAY(pt,10);
1305   6                              }
1306   5                              else
1307   5                              {
1308   6                                      PT_DELAY(pt,3);
1309   6                              }                       
1310   5                      }               
1311   4        //-----------------------------
1312   4        }
1313   3      
1314   3       PT_END(pt);
1315   1      }
1316          //-----------------------------------------------------------------------------------------------
1317          void Store_Dev_Address_Desc(unsigned char addr,void* name,void* ver,void* desc,unsigned char desc_len)//со
             -хранить в ППЗУ новый адрес устройства, имя, версию, описание
1318          {
1319   1      //небезопасная
1320   1              
1321   1              unsigned int blocks=0;//здесь будет количество блоков, нужных дя сохранения комментария
1322   1              
1323   1              EEPROM_Write(&addr,1,DEVICE_ADDR_EEPROM);        //1 блок
1324   1              EEPROM_Write(name,DEVICE_NAME_LENGTH,DEVICE_NAME_EEPROM); //5 блоков
1325   1              memcpy(DEV_NAME,name,DEVICE_NAME_LENGTH_SYM);//копируем полученное имя в буфер
1326   1      
1327   1              EEPROM_Write(ver,DEVICE_VER_LENGTH,DEVICE_VER_EEPROM);          //2 блока
1328   1              memcpy(VERSION,ver,DEVICE_VER_LENGTH_SYM);//копируем версию в буфер
1329   1      
1330   1              blocks=desc_len>>2;//в блоке 4 байта, делим на 4
1331   1              if(desc_len&0xFC)//если есть остаток, то берем еще один блок
1332   1                      blocks++;
1333   1              
1334   1              if(blocks>DEVICE_DESC_MAX_LENGTH) //ограничение на количество блоков для комментария
1335   1                      blocks=DEVICE_DESC_MAX_LENGTH;
1336   1      
1337   1              EEPROM_Write(desc,(unsigned int)blocks,DEVICE_DESC_EEPROM);
C51 COMPILER V9.00   PROTO_USO                                                             06/20/2014 09:13:36 PAGE 23  

1338   1              dev_desc_len=desc_len;
1339   1              EEPROM_Write(&desc_len,1,DEVICE_DESC_LEN_EEPROM);//сохраним длину комментария
1340   1              
1341   1              memcpy(NOTICE,desc,desc_len);//копируем описание в буфер
1342   1              
1343   1              return;
1344   1      }
1345          //-----------------------------------------------------------------------------------------------
1346          void Restore_Dev_Address_Desc(void)//восстановить из ппзу адрес и информацию об устройстве
1347          {
1348   1              unsigned int blocks=0;//здесь будет количество блоков, нужных дя сохранения комментария
1349   1              
1350   1              EEPROM_Read(&ADRESS_DEV,1,DEVICE_ADDR_EEPROM);   //1 блок восстанавливаем адрес из ППЗУ
1351   1      
1352   1              if(ADRESS_DEV<1 || ADRESS_DEV>15)
1353   1                      ADRESS_DEV=1; 
1354   1      
1355   1              EEPROM_Read(DEV_NAME,DEVICE_NAME_LENGTH,DEVICE_NAME_EEPROM); //5 блоков
1356   1          EEPROM_Read(VERSION,DEVICE_VER_LENGTH,DEVICE_VER_EEPROM);
1357   1      
1358   1              EEPROM_Read(&dev_desc_len,1,DEVICE_DESC_LEN_EEPROM);//длина описания устройства в байтах
1359   1      
1360   1              if(dev_desc_len>DEVICE_DESC_MAX_LENGTH_SYM)
1361   1                      dev_desc_len=DEVICE_DESC_MAX_LENGTH_SYM;
1362   1      
1363   1              blocks=dev_desc_len>>2;//в блоке 4 байта, делим на 4
1364   1              if(dev_desc_len&0xFC)//если есть остаток, то берем еще один блок
1365   1                      blocks++;
1366   1      
1367   1              if(blocks>DEVICE_DESC_MAX_LENGTH) //ограничение на количество блоков для комментария     ???
1368   1                      blocks=DEVICE_DESC_MAX_LENGTH;
1369   1      
1370   1              EEPROM_Read(NOTICE,(unsigned int)blocks,DEVICE_DESC_EEPROM);
1371   1              return;
1372   1      }
1373          //-----------------------------------------------------------------------------------------------


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   7414    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    672       1
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      1       2
   IDATA SIZE       =      3    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
