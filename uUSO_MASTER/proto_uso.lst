C51 COMPILER V9.00   PROTO_USO                                                             06/26/2014 10:40:45 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE PROTO_USO
OBJECT MODULE PLACED IN proto_uso.obj
COMPILER INVOKED BY: C:\Program Files\Keil\C51\BIN\C51.EXE proto_uso\proto_uso.c LARGE OPTIMIZE(6,SPEED) BROWSE ORDER NO
                    -AREGS DEBUG OBJECTEXTEND PRINT(.\proto_uso.lst) OBJECT(proto_uso.obj)

line level    source

   1          #include "proto_uso.h"
   2          #include "calibrate\calibrate.h"
   3          #include "i2c.h"
   4          #include <intrins.h>
   5          #include "crc_table.h"
   6          #include "channels.h"
   7          #include "watchdog.h"
   8          #include "modbus\modbus_ascii.h"
   9          //-----------------------------------------------------------------------------------
  10          
  11          sbit DE_RE=P3^5;
  12          
  13          //-----------------------------------------------------------------------------------
  14          unsigned char xdata DEV_NAME[DEVICE_NAME_LENGTH_SYM] ="<<uUSO_2>>"; //имя устройства
  15          unsigned char xdata NOTICE[DEVICE_DESC_MAX_LENGTH_SYM]="<-- GEOSPHERA_2012 -->";//примечание    
  16          unsigned char xdata VERSION[DEVICE_VER_LENGTH_SYM] ="\x30\x30\x30\x30\x31";     // версия программы ПЗУ не бол
             -ьше 5 байт
  17          
  18          unsigned char xdata ADRESS_DEV=0x1;
  19          
  20          unsigned char xdata dev_desc_len=20;//длина описания устройства
  21          //--------------------------------global variable------------------------------------
  22          unsigned char xdata     RECIEVED=0;//принято
  23          unsigned int  xdata recieve_count;//счетчик приемного буфера
  24          unsigned char xdata     transf_count;//счетчик передаваемых байтов         
  25          unsigned char xdata     buf_len;//длина передаваемого буфера
  26          
  27          //------------------------флаги ошибок--------------------------------
  28          
  29          unsigned char xdata frame_len=0;//длина кадра, которую вытаскиваем из шестого байта кадра
  30          //--------------------------------------------------------------------
  31          unsigned char xdata  RecieveBuf[MAX_LENGTH_REC_BUF]={0} ; //буфер принимаемых данных
  32          //volatile unsigned char xdata                  *TransferBuf;
  33          unsigned char xdata  TransferBuf[MAX_LENGTH_TR_BUF]={0} ; //буфер передаваемых данных
  34          //--------------------------------------------------------------------
  35          volatile unsigned char xdata  STATE_BYTE=0xC0;//байт состояния устройства
  36          unsigned char xdata protocol_type=PROTO_TYPE_NEW;//тип протокола
  37          
  38          volatile struct pt pt_proto, pt_buf_handle;
  39          
  40          volatile struct RingBuf rngbuf;
  41          
  42          extern struct I2C_Channel xdata i2c_channels;
  43          //-----------------------------------------------------------------------------------
  44          union //объединение для конвертирования char->long
  45          {
  46                  float result_float;
  47                  unsigned char result_char[4];
  48          }
  49          sym_8_to_float;
  50          
  51          extern unsigned char idata i2c_buffer[6];
  52          extern unsigned char channel_number;//количество каналов
  53          
C51 COMPILER V9.00   PROTO_USO                                                             06/26/2014 10:40:45 PAGE 2   

  54          
  55          //-----------------------------------------------------------------------------------
  56          //#pragma OT(0,Speed)
  57          void UART_ISR(void) interrupt 4 //using 1
  58          {       
  59   1              EA=0;   //запрет прерывания
  60   1              
  61   1              if(RI)
  62   1              {
  63   2                      RI=0; 
  64   2                      rngbuf.buf[rngbuf.tail]=SBUF;
  65   2                      rngbuf.tail++;
  66   2                      rngbuf.count++;                                                                         
  67   2              }
  68   1      //----------------------------передача-----------------------------------------------
  69   1              if(TI)
  70   1              {
  71   2                      TI=0;
  72   2                       
  73   2                      if(transf_count<buf_len)
  74   2                      {
  75   3      
  76   3                                      SBUF=TransferBuf[transf_count];                 
  77   3                                      transf_count++;
  78   3                      }
  79   2                      else
  80   2                      {
  81   3                              transf_count=0;         //обнуляем счетчик
  82   3                              PT_RESTART_OUT(pt_proto);  //внепроцессный рестарт                      
  83   3                      }                                          
  84   2              }                       
  85   1              EA=1;
  86   1              return;
  87   1      }
  88          //------------------------------------------------------------------------------
  89          //#pragma OT(6,Speed)
  90          void Protocol_Init(void) //using 0
  91          {
  92   1              TI=0;
  93   1              RI=0;
  94   1              
  95   1      
  96   1              Restore_Dev_Address_Desc();
  97   1      
  98   1              rngbuf.tail=0;
  99   1              rngbuf.head=0;
 100   1              rngbuf.count=0;
 101   1      
 102   1              recieve_count=0x0;//счетчик буфера приема
 103   1              transf_count=0x0;//счетчик передаваемых байтов
 104   1              buf_len=0x0;//длина передаваемого буфера
 105   1              DE_RE=0;//линия на прием
 106   1              //CUT_OUT_NULL=0;
 107   1              STATE_BYTE=0xC0;
 108   1              PT_INIT(&pt_proto);
 109   1              PT_INIT(&pt_buf_handle);
 110   1              return;
 111   1      }
 112          //-----------------------------------------------------------------------------
 113          unsigned char Send_Info(void) //using 0    //посылка информации об устройстве
 114          {
 115   1                  unsigned char    i=0;
C51 COMPILER V9.00   PROTO_USO                                                             06/26/2014 10:40:45 PAGE 3   

 116   1                                                                                      
 117   1                 //заголовок кадра---
 118   1                 TransferBuf[0]=0x00;
 119   1                 TransferBuf[1]=0xD7;
 120   1                 TransferBuf[2]=0x29;
 121   1                 //------------------
 122   1                 TransferBuf[3]=ADRESS_DEV;  // адрес узла
 123   1                 TransferBuf[4]=GET_DEV_INFO_RESP;  // код операции
 124   1                 TransferBuf[6]=STATE_BYTE;
 125   1      
 126   1                 for(i=0;i<20;i++)
 127   1                 {                              // записываем наименование изделия
 128   2                                 if(i<DEVICE_NAME_LENGTH_SYM)
 129   2                                 {
 130   3                                      TransferBuf[i+7]=DEV_NAME[i];
 131   3                                 }
 132   2                                 else
 133   2                                 {
 134   3                                              TransferBuf[i+7]=0x00;
 135   3                                 }
 136   2                      }
 137   1              
 138   1                 for(i=0;i<5;i++)                   // записываем версию ПЗУ
 139   1                 {
 140   2                     if(i<DEVICE_VER_LENGTH_SYM)
 141   2                         {
 142   3                               TransferBuf[i+27]=VERSION[i];
 143   3                         }
 144   2                 }
 145   1      
 146   1                 TransferBuf[32]=channel_number;                 // количество каналов
 147   1      
 148   1                 for(i=0;i<channel_number;i++)                                   // данные по каналу
 149   1             {
 150   2                              TransferBuf[i*2+33]=((channels[i].settings.set.type)<<4)|channels[i].settings.set.modific; // байт да
             -нных
 151   2                              TransferBuf[i*2+33+1]=0x00;                                                     // резерв байт
 152   2                 }    
 153   1                 for(i=0;i<dev_desc_len;i++)                                  // записываем примечание
 154   1                 {
 155   2                               TransferBuf[i+33+channel_number*2]=NOTICE[i];
 156   2                 }
 157   1                              
 158   1                 TransferBuf[5]=28+channel_number*2+dev_desc_len;                     // подсчет длины данных 
 159   1                 TransferBuf[33+channel_number*2+dev_desc_len]=CRC_Check(&TransferBuf[1],32+channel_number*2+dev_desc_l
             -en); // подсчет контрольной суммы
 160   1      
 161   1              return (34+channel_number*2+dev_desc_len);
 162   1      }
 163          //-----------------------------------------------------------------------------
 164          unsigned char Node_Full_Init(void) //using 0 //полная инициализация узла
 165          {
 166   1              return 0;
 167   1      }
 168          //-----------------------------------------------------------------------------
 169          unsigned char Channel_List_Init(void) //using 0 //Инициализация списка каналов узла (без потери данных);
 170          {
 171   1              return 0;
 172   1      }
 173          //-----------------------------------------------------------------------------
 174          unsigned char Channel_Get_Data(void) //using 0 //Выдать данные по каналам, согласно абсолютной нумерации;
 175          {
C51 COMPILER V9.00   PROTO_USO                                                             06/26/2014 10:40:45 PAGE 4   

 176   1              return 0;
 177   1      }
 178          //-----------------------------------------------------------------------------
 179          unsigned char  Channel_Set_Parameters(void) //using 0 //Установить параметры по каналам, согласно абсолютн
             -ой нумерации;
 180          {
 181   1             unsigned char  index=0, store_data=0;//i=0;
 182   1               
 183   1                 while(index<RecieveBuf[5]-1)                            // данные по каналам
 184   1                    {
 185   2                                      if(RecieveBuf[6+index]<channel_number)
 186   2                                  {
 187   3                                              switch((RecieveBuf[6+index+1]>>4)&0xF)
 188   3                                              {
 189   4                                                              case CHNL_ADC://АЦП
 190   4                                                              {
 191   5                                                                      if((channels[RecieveBuf[6+index]].settings.set.modific!=RecieveBuf[6+index+1])||(channels[RecieveB
             -uf[6+index]].settings.set.state_byte_1!=RecieveBuf[6+index+2]) || (channels[RecieveBuf[6+index]].settings.set.state_byte
             -_2!=RecieveBuf[6+index+3]))
 192   5                                                                      {  
 193   6                                                                              channels[RecieveBuf[6+index]].settings.set.state_byte_1=RecieveBuf[6+index+2];
 194   6                                                                              channels[RecieveBuf[6+index]].settings.set.state_byte_2=RecieveBuf[6+index+3];
 195   6                                                                              channels[RecieveBuf[6+index]].settings.set.modific         =RecieveBuf[6+index+1]&0xF;
 196   6                                                                              store_data=1;
 197   6                                                                              
 198   6                                                                      }
 199   5                                                                      index++;
 200   5                                                              }
 201   4                                                              break;
 202   4      
 203   4      
 204   4                                                              default :
 205   4                                                              {
 206   5                                                                      _nop_();
 207   5                                                              }                       
 208   4                                              }
 209   3                                              index=index+3;
 210   3                                      }
 211   2                                      else
 212   2                                      {
 213   3                                              return Request_Error(FR_UNATTENDED_CHANNEL);
 214   3                                      }
 215   2                        }
 216   1                 if(store_data)
 217   1                 {
 218   2                              Store_Channels_Data();  //сохраним настройки каналов в ППЗУ
 219   2                 }
 220   1      
 221   1                 return Request_Error(FR_SUCCESFUL);
 222   1      }
 223          //-----------------------------------------------------------------------------
 224          unsigned char Channel_Set_Order_Query(void) //using 0 //Задать последовательность опроса;
 225          {
 226   1              return 0;
 227   1      }
 228          //-----------------------------------------------------------------------------
 229          unsigned char Channel_Get_Data_Order(void) //using 0 //Выдать данные по каналам, согласно последовательнос
             -ти опроса;
 230          {
 231   1              return 0;
 232   1      }
 233          //-----------------------------------------------------------------------------
C51 COMPILER V9.00   PROTO_USO                                                             06/26/2014 10:40:45 PAGE 5   

 234          unsigned char Channel_Set_State(void) //using 0 //Установить состояния по каналам, согласно абсолютной нум
             -ерации;
 235          {
 236   1              return 0;
 237   1      }
 238          //-----------------------------------------------------------------------------
 239          unsigned char  Channel_Get_Data_Order_M2(void) //using 0 //Выдать данные по каналам, согласно последовател
             -ьности опроса;
 240          {
 241   1              return 0;
 242   1      }
 243          //-----------------------------------------------------------------------------
 244          unsigned char Channel_Set_Reset_State_Flags(void) //using 0 //  Установка/Сброс флагов состояния 
 245          {
 246   1              STATE_BYTE=0x40;
 247   1              i2c_buffer[0]=SLAVE_STATE_BYTE_RESET;//сбросим флаг инициализации ведомого
 248   1              ChannelsInit();
 249   1              return  Request_Error(FR_SUCCESFUL);//ошибки нет, подтверждение
 250   1      }
 251          //-----------------------------------------------------------------------------
 252          #pragma OT(9,Speed)
 253          unsigned char Channel_All_Get_Data(void) //using 0 //Выдать информацию по всем каналам узла (расширенный р
             -ежим);
 254          {
 255   1         unsigned char data index=0,i=0;
 256   1      
 257   1      
 258   1         TransferBuf[0]=0x00;TransferBuf[1]=0xD7;TransferBuf[2]=0x29;
 259   1         TransferBuf[3]=ADRESS_DEV;  // адрес узла
 260   1         TransferBuf[4]=CHANNEL_ALL_GET_DATA_RESP;  // код операции
 261   1         TransferBuf[6]=STATE_BYTE;
 262   1      
 263   1         index=7;//длина заголовка
 264   1       
 265   1          for(i=0;i<channel_number;i++)                                  // данные по каналам
 266   1          {
 267   2                        TransferBuf[index++]=i;
 268   2                        TransferBuf[index++]=((channels[i].settings.set.type)<<4)|channels[i].settings.set.modific; // тип и м
             -одификация канала
 269   2                        switch(channels[i].settings.set.type)
 270   2                          {
 271   3                                       case CHNL_ADC:  //аналоговый канал
 272   3                                       {
 273   4                                               switch(channels[i].settings.set.modific)
 274   4                               {
 275   5                                                        case CHNL_ADC_FIX_16:
 276   5                                                        {
 277   6                                                                      if(channels[i].calibrate.cal.calibrate==1)//калиброванный
 278   6                                                                      {                                                
 279   7                                                                                      TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data_calibrate))[2];
 280   7                                                                              TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data_calibrate))[1];
 281   7                                                                      }
 282   6                                                                      else
 283   6                                                                      {
 284   7                                                                                      TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data))[2];
 285   7                                                                              TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data))[1];  
 286   7                                                                      } 
 287   6      
 288   6                                                                        
 289   6                                                                       TransferBuf[index++]=channels[i].settings.set.state_byte_1;     // первый байт состояния канала
 290   6                                               TransferBuf[index++]=channels[i].settings.set.state_byte_2;     // второй байт сос
             -тояния канала
C51 COMPILER V9.00   PROTO_USO                                                             06/26/2014 10:40:45 PAGE 6   

 291   6                                                        }
 292   5                                                        break; 
 293   5      
 294   5                                                        case CHNL_ADC_FIX_24:
 295   5                                                        {
 296   6                                                              if(channels[i].calibrate.cal.calibrate==1)//калиброванный
 297   6                                                                      {                                                                                                 
 298   7                                                                                      TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data_calibrate))[3];
 299   7                                                                                      TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data_calibrate))[2];
 300   7                                                                              TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data_calibrate))[1];
 301   7                                                                      }
 302   6                                                                      else
 303   6                                                                      {                                                                        
 304   7                                                                                      TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data))[3];
 305   7                                                                                      TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data))[2];
 306   7                                                                              TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data))[1];  
 307   7                                                                      } 
 308   6                        
 309   6                                                                        TransferBuf[index++]=channels[i].settings.set.state_byte_1;    // первый байт состояния канала
 310   6                                                TransferBuf[index++]=channels[i].settings.set.state_byte_2;    // второй байт со
             -стояния канала
 311   6                                                        }
 312   5                                                        break;
 313   5                                                }
 314   4                                        }
 315   3                                        break;
 316   3      
 317   3                                      case CHNL_DOL:   //ДОЛ
 318   3                                      {
 319   4                                                switch(channels[i].settings.set.modific)
 320   4                                            {   
 321   5                                                                case CHNL_DOL_ENC:
 322   5                                                                {
 323   6                                                                                      TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data))[3];
 324   6                                                                                      TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data))[2];
 325   6                                                                              TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data))[1];
 326   6                                                                                      TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data))[0];
 327   6                                                                                  TransferBuf[index++]=channels[i].settings.set.state_byte_1;  // первый байт состояния канала
 328   6                                                                }
 329   5                                                                break; 
 330   5                                                 }
 331   4                                      }
 332   3                                      break;
 333   3      
 334   3                                       case CHNL_FREQ: //частотный
 335   3                                       { 
 336   4                                                switch(channels[i].settings.set.modific)
 337   4                                            {   
 338   5                                                                
 339   5                                                                case CHNL_FREQ_COUNT_T:
 340   5                                                                {
 341   6                                                                                      TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data))[3];
 342   6                                                                                      TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data))[2];
 343   6                                                                                TransferBuf[index++]=channels[i].settings.set.state_byte_1;    // первый байт состояния канала
 344   6                                                                }
 345   5                                                                break;
 346   5      
 347   5                                                                case CHNL_FREQ_256:
 348   5                                                                {
 349   6                                                                                      TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data))[3];
 350   6                                                                                      TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data))[2];
 351   6                                                                                  TransferBuf[index++]=channels[i].settings.set.state_byte_1;  // первый байт состояния канала
C51 COMPILER V9.00   PROTO_USO                                                             06/26/2014 10:40:45 PAGE 7   

 352   6                                                                }
 353   5                                                                break; 
 354   5                                                 }
 355   4                                        }
 356   3                                        break;                 
 357   3                        }
 358   2                 }
 359   1      
 360   1                TransferBuf[5]=index+2-7;                                              // подсчет длины данных двойка это 1(байт статуса)+1(контрольная сумма
             -)
 361   1                TransferBuf[index]=CRC_Check(&TransferBuf[1],(unsigned int)(index)-1); // подсчет кс
 362   1                return (unsigned char)(index+1);
 363   1      }
 364          //-----------------------------------------------------------------------------
 365          #pragma OT(0,Speed)
 366          unsigned char Channel_Set_Calibrate(void)//установить верхнюю или нижнюю точку калибровки
 367          {
 368   1      
 369   1              float K,C;      
 370   1      
 371   1              sym_8_to_float.result_char[0]=RecieveBuf[11];
 372   1              sym_8_to_float.result_char[1]=RecieveBuf[10];
 373   1              sym_8_to_float.result_char[2]=RecieveBuf[9];
 374   1              sym_8_to_float.result_char[3]=RecieveBuf[8];
 375   1      
 376   1              K=sym_8_to_float.result_float;
 377   1      
 378   1              sym_8_to_float.result_char[0]=RecieveBuf[15];
 379   1              sym_8_to_float.result_char[1]=RecieveBuf[14];
 380   1              sym_8_to_float.result_char[2]=RecieveBuf[13];
 381   1              sym_8_to_float.result_char[3]=RecieveBuf[12];
 382   1      
 383   1              C=sym_8_to_float.result_float;
 384   1      
 385   1              switch(RecieveBuf[7])
 386   1              {
 387   2                      case 0:
 388   2                      {
 389   3                              Calibrate(RecieveBuf[6],K,C);   
 390   3                      }
 391   2                      break;
 392   2      
 393   2                      case 1:
 394   2                      {
 395   3                              Calibrate_Set_Flag(RecieveBuf[6],RESET);
 396   3                      }
 397   2                      break;
 398   2      
 399   2                      case 2:
 400   2                      {
 401   3                              Calibrate_Set_Flag(RecieveBuf[6],SET);  
 402   3                      }
 403   2                      break;
 404   2      
 405   2                      default :
 406   2                      {
 407   3                              _nop_();
 408   3                      }
 409   2                      break;
 410   2              }
 411   1      
 412   1      
C51 COMPILER V9.00   PROTO_USO                                                             06/26/2014 10:40:45 PAGE 8   

 413   1              return  Request_Error(FR_SUCCESFUL);//ошибки нет, подтверждение 
 414   1      }
 415          //------------------------------------------------------------------------------
 416          unsigned char Channel_Get_Calibrate_Value(void)//получить коэфициенты калибровки заданного канала
 417          {
 418   1         unsigned char data channel=0;
 419   1      
 420   1      
 421   1         TransferBuf[0]=0x00;TransferBuf[1]=0xD7;TransferBuf[2]=0x29;
 422   1         TransferBuf[3]=ADRESS_DEV;  // адрес узла
 423   1         TransferBuf[4]=CHANNEL_GET_CALIBRATE_RESP;  // код операции
 424   1         TransferBuf[5]=0xB;//длина оставшейся части кадра
 425   1      
 426   1      
 427   1         channel=RecieveBuf[6];
 428   1      
 429   1         if(channel>=channel_number)
 430   1         {
 431   2                      return Request_Error(FR_COMMAND_STRUCT_ERROR);//непрвильный номер канала        
 432   2         }
 433   1      
 434   1         TransferBuf[6]=channel;
 435   1      
 436   1         TransferBuf[7]=channels[channel].calibrate.cal.calibrate;
 437   1      
 438   1         sym_8_to_float.result_float=channels[channel].calibrate.cal.K;
 439   1      
 440   1              TransferBuf[11]=sym_8_to_float.result_char[0];
 441   1              TransferBuf[10]=sym_8_to_float.result_char[1];
 442   1              TransferBuf[9]=sym_8_to_float.result_char[2];
 443   1              TransferBuf[8]=sym_8_to_float.result_char[3];
 444   1      
 445   1         sym_8_to_float.result_float=channels[channel].calibrate.cal.C;
 446   1      
 447   1              TransferBuf[15]=sym_8_to_float.result_char[0];
 448   1              TransferBuf[14]=sym_8_to_float.result_char[1];
 449   1              TransferBuf[13]=sym_8_to_float.result_char[2];
 450   1              TransferBuf[12]=sym_8_to_float.result_char[3];
 451   1      
 452   1              TransferBuf[16]=CRC_Check(&TransferBuf[1],15); // подсчет кс
 453   1              return 0x11;//17        
 454   1      }
 455          //------------------------------------------------------------------------------
 456          unsigned char Channel_Set_Address_Desc(void)//установить новый адрес устройства, имя, описание, версию про
             -шивки и комментарий
 457          {
 458   1              unsigned char  desc_len=0;
 459   1              desc_len=RecieveBuf[5]-27;
 460   1      
 461   1              if(desc_len)
 462   1              {       
 463   2                      Store_Dev_Address_Desc(RecieveBuf[6],&RecieveBuf[7],&RecieveBuf[27],&RecieveBuf[32],desc_len);
 464   2                      return    Request_Error(FR_SUCCESFUL);//ошибки нет, подтверждение
 465   2              }
 466   1              else
 467   1              {
 468   2                      return Request_Error(FR_COMMAND_STRUCT_ERROR);
 469   2              }
 470   1              return 0;
 471   1      }
 472          //-----------------------------------------------------------------------------
 473          unsigned char Channel_Set_All_Default(void)//установить настройки и калибровки каналов по умолчанию
C51 COMPILER V9.00   PROTO_USO                                                             06/26/2014 10:40:45 PAGE 9   

 474          {
 475   1              Channels_Set_Default();
 476   1              Calibrate_Set_Default();
 477   1              return  Request_Error(FR_SUCCESFUL);//ошибки нет, подтверждение         
 478   1      }
 479          //-----------------------------------------------------------------------------
 480          unsigned char Request_Error(unsigned char error_code) //using 0 //      Ошибочный запрос/ответ;
 481          {
 482   1              TransferBuf[0]=0x00;TransferBuf[1]=0xD7;TransferBuf[2]=0x29;
 483   1          TransferBuf[3]=ADRESS_DEV;  // адрес узла
 484   1          TransferBuf[7]=RecieveBuf[4]; // код сбойной команды
 485   1          TransferBuf[4]=0xFF;  // код операции
 486   1      
 487   1              TransferBuf[6]=STATE_BYTE; // байт статуса узла
 488   1          TransferBuf[8]=error_code;   
 489   1          TransferBuf[5]=0x04;          // длина данных
 490   1          TransferBuf[9]=CRC_Check(TransferBuf,9);
 491   1              return 10;
 492   1      }
 493          
 494          //-----------------------------------------------------------------------------
 495          unsigned char Old_CRC_Check(unsigned char xdata *Spool_pr,unsigned char Count_pr)
 496          {
 497   1           unsigned char crc = 0x0;
 498   1               unsigned char i=0;
 499   1      
 500   1               for(i=0;i<Count_pr;i++)
 501   1               {
 502   2                      CY=0;
 503   2                      crc+=Spool_pr[i];
 504   2                      if(CY)
 505   2                      {
 506   3                              crc++;
 507   3                      }
 508   2               }
 509   1               crc=0xFF-crc;
 510   1      
 511   1           return crc;        
 512   1      }
 513          //-----------------------------------------------------------------------------
 514          unsigned char Old_Channel_Get_Data(void)
 515          {
 516   1        unsigned char channel=0;
 517   1        unsigned char len=0;
 518   1        channel=((RecieveBuf[4]>>3)&0x1F);
 519   1        if(channel<CHANNEL_NUMBER)
 520   1        {  
 521   2                 TransferBuf[0]=0x00;TransferBuf[1]=0xD7;TransferBuf[2]=0x28;
 522   2                 TransferBuf[3]=0x0;  // 
 523   2                 TransferBuf[4]=RecieveBuf[4];
 524   2                 TransferBuf[5]=((OLD_CHANNEL_GET_DATA<<5)&0x1F)|0x3;//0x63;// код операции   
 525   2      
 526   2                              switch(channels[channel].settings.set.type)
 527   2                          {
 528   3                                       case CHNL_ADC:  //аналоговый канал
 529   3                                       {
 530   4                                               switch(channels[channel].settings.set.modific)
 531   4                               {
 532   5                                                        case CHNL_ADC_FIX_16:
 533   5                                                        {
 534   6                                                                      if(channels[channel].calibrate.cal.calibrate==1)//калиброванный
 535   6                                                                      {                                                
C51 COMPILER V9.00   PROTO_USO                                                             06/26/2014 10:40:45 PAGE 10  

 536   7                                                                                      TransferBuf[6]=((unsigned char*)(&channels[channel].channel_data_calibrate))[1];
 537   7                                                                              TransferBuf[7]=((unsigned char*)(&channels[channel].channel_data_calibrate))[2];
 538   7                                                                      }
 539   6                                                                      else
 540   6                                                                      {
 541   7                                                                                      TransferBuf[6]=((unsigned char*)(&channels[channel].channel_data))[1];
 542   7                                                                              TransferBuf[7]=((unsigned char*)(&channels[channel].channel_data))[2];  
 543   7                                                                      }                                       
 544   6                                                        }
 545   5                                                        break; 
 546   5      
 547   5                                                        case CHNL_ADC_FIX_24:
 548   5                                                        {
 549   6                                                              if(channels[channel].calibrate.cal.calibrate==1)//калиброванный
 550   6                                                                      {                                                                                                 
 551   7                                                                                      TransferBuf[channel]=((unsigned char*)(&channels[channel].channel_data_calibrate))[1];
 552   7                                                                              TransferBuf[channel]=((unsigned char*)(&channels[channel].channel_data_calibrate))[2];
 553   7                                                                      }
 554   6                                                                      else
 555   6                                                                      {                                                                        
 556   7                                                                                      TransferBuf[6]=((unsigned char*)(&channels[channel].channel_data))[1];
 557   7                                                                              TransferBuf[7]=((unsigned char*)(&channels[channel].channel_data))[2];  
 558   7                                                                      }
 559   6      
 560   6                                                        }
 561   5                                                        break;
 562   5                                                }                                       
 563   4                                        }
 564   3                                        break;
 565   3      
 566   3                                      case CHNL_DOL:   //ДОЛ
 567   3                                      {
 568   4                                                switch(channels[channel].settings.set.modific)
 569   4                                            {   
 570   5                                                                case CHNL_DOL_ENC:
 571   5                                                                {
 572   6                                                                                      TransferBuf[6]=((unsigned char*)(&channels[channel].channel_data))[2];
 573   6                                                                                      TransferBuf[7]=((unsigned char*)(&channels[channel].channel_data))[3];
 574   6      //                                                                      TransferBuf[channel]=((unsigned char*)(&channels[channel].channel_data))[0];
 575   6      //                                                                              TransferBuf[channel]=((unsigned char*)(&channels[channel].channel_data))[1];
 576   6                                                                }
 577   5                                                                break; 
 578   5                                                 }
 579   4                                      }
 580   3                                      break;
 581   3      
 582   3                                       case CHNL_FREQ: //частотный
 583   3                                       { 
 584   4                                                switch(channels[channel].settings.set.modific)
 585   4                                            {   
 586   5                                                                
 587   5                                                                case CHNL_FREQ_COUNT_T:
 588   5                                                                {
 589   6                                                                                      TransferBuf[6]=((unsigned char*)(&channels[channel].channel_data))[2];
 590   6                                                                                      TransferBuf[7]=((unsigned char*)(&channels[channel].channel_data))[3];
 591   6      
 592   6                                                                }
 593   5                                                                break;
 594   5      
 595   5                                                                case CHNL_FREQ_256:
 596   5                                                                {
 597   6                                                                                      TransferBuf[6]=((unsigned char*)(&channels[channel].channel_data))[2];
C51 COMPILER V9.00   PROTO_USO                                                             06/26/2014 10:40:45 PAGE 11  

 598   6                                                                                      TransferBuf[7]=((unsigned char*)(&channels[channel].channel_data))[3];
 599   6                                                                }
 600   5                                                                break; 
 601   5                                                 }                                       
 602   4                                        }
 603   3                                        break;                 
 604   3                        }
 605   2                 
 606   2                 len=Proto_Paste_Null(TransferBuf,8);
 607   2      
 608   2                 TransferBuf[len]=Old_CRC_Check(TransferBuf,len);
 609   2                 return len+1;
 610   2         }
 611   1         return 0;    
 612   1      }
 613          //-----------------------------------------------------------------------------
 614          unsigned char Old_Channel_Get_Data_State(void)
 615          {
 616   1        unsigned char channel=0;
 617   1        unsigned char len=0;
 618   1        channel=((RecieveBuf[4]>>3)&0x1F);
 619   1        if(channel<CHANNEL_NUMBER)
 620   1        {
 621   2                 TransferBuf[0]=0x00;TransferBuf[1]=0xD7;TransferBuf[2]=0x28;
 622   2                 TransferBuf[3]=0x0;  // 
 623   2                 TransferBuf[4]=RecieveBuf[4];
 624   2                 TransferBuf[5]=((OLD_CHANNEL_GET_DATA_STATE<<5)&0x1F)|0x6;//0x66;// код операции     
 625   2      
 626   2                              switch(channels[channel].settings.set.type)
 627   2                          {
 628   3                                       case CHNL_ADC:  //аналоговый канал
 629   3                                       {
 630   4                                               switch(channels[channel].settings.set.modific)
 631   4                               {
 632   5                                                        case CHNL_ADC_FIX_16:
 633   5                                                        {
 634   6                                                                      if(channels[channel].calibrate.cal.calibrate==1)//калиброванный
 635   6                                                                      {                                                
 636   7                                                                                      TransferBuf[6]=((unsigned char*)(&channels[channel].channel_data_calibrate))[1];
 637   7                                                                              TransferBuf[7]=((unsigned char*)(&channels[channel].channel_data_calibrate))[2];
 638   7                                                                      }
 639   6                                                                      else
 640   6                                                                      {
 641   7                                                                                      TransferBuf[6]=((unsigned char*)(&channels[channel].channel_data))[1];
 642   7                                                                              TransferBuf[7]=((unsigned char*)(&channels[channel].channel_data))[2];  
 643   7                                                                      }                                       
 644   6                                                        }
 645   5                                                        break; 
 646   5      
 647   5                                                        case CHNL_ADC_FIX_24:
 648   5                                                        {
 649   6                                                              if(channels[channel].calibrate.cal.calibrate==1)//калиброванный
 650   6                                                                      {                                                                                                 
 651   7                                                                                      TransferBuf[channel]=((unsigned char*)(&channels[channel].channel_data_calibrate))[1];
 652   7                                                                              TransferBuf[channel]=((unsigned char*)(&channels[channel].channel_data_calibrate))[2];
 653   7                                                                      }
 654   6                                                                      else
 655   6                                                                      {                                                                        
 656   7                                                                                      TransferBuf[6]=((unsigned char*)(&channels[channel].channel_data))[1];
 657   7                                                                              TransferBuf[7]=((unsigned char*)(&channels[channel].channel_data))[2];  
 658   7                                                                      }
 659   6      
C51 COMPILER V9.00   PROTO_USO                                                             06/26/2014 10:40:45 PAGE 12  

 660   6                                                        }
 661   5                                                        break;
 662   5                                                }
 663   4                                                
 664   4                                                switch(channels[channel].settings.set.state_byte_1&0x7)
 665   4                                                {
 666   5                                                              case PROTO_ADC_AMP_1:
 667   5                                                              {
 668   6                                                                      TransferBuf[8]=(0x00|(OLD_PROTO_ADC_AMP_1<<1))&0xFE;     // первый байт состояния канала
 669   6                                                              }
 670   5                                                              break;
 671   5      
 672   5                                                              case PROTO_ADC_AMP_2:
 673   5                                                              {
 674   6                                                                      TransferBuf[8]=(0x00|(OLD_PROTO_ADC_AMP_2<<1))&0xFE;     // первый байт состояния канала        
 675   6                                                              }
 676   5                                                              break;
 677   5      
 678   5                                                              case PROTO_ADC_AMP_32:
 679   5                                                              {
 680   6                                                                      TransferBuf[8]=(0x00|(OLD_PROTO_ADC_AMP_32<<1))&0xFE;    // первый байт состояния канала        
 681   6                                                              }
 682   5                                                              break;
 683   5      
 684   5                                                              case PROTO_ADC_AMP_128:
 685   5                                                              {
 686   6                                                                      TransferBuf[8]=(0x00|(OLD_PROTO_ADC_AMP_128<<1))&0xFE;   // первый байт состояния канала
 687   6                                                              }
 688   5                                                              break;
 689   5      
 690   5                                                              default :
 691   5                                                              {
 692   6                                                                      TransferBuf[8]=(0x00|(OLD_PROTO_ADC_AMP_1<<1))&0xFE;     // первый байт состояния канала
 693   6                                                              }
 694   5                                                              break;
 695   5                                                }
 696   4                                                
 697   4                                                TransferBuf[9]=0x0A;   // второй байт состояния канала
 698   4      
 699   4                                        }
 700   3                                        break;
 701   3      
 702   3                                case CHNL_DOL:         //ДОЛ
 703   3                                {
 704   4                                        switch(channels[channel].settings.set.modific)
 705   4                                    {   
 706   5                                                        case CHNL_DOL_ENC:
 707   5                                                        {
 708   6                                                                      TransferBuf[6]=((unsigned char*)(&channels[channel].channel_data))[2];
 709   6                                                                      TransferBuf[7]=((unsigned char*)(&channels[channel].channel_data))[3];
 710   6      //                                                                      TransferBuf[channel]=((unsigned char*)(&channels[channel].channel_data))[0];
 711   6      //                                                                              TransferBuf[channel]=((unsigned char*)(&channels[channel].channel_data))[1];
 712   6      
 713   6                                                                      
 714   6      
 715   6                                                                      switch(channels[channel].settings.set.state_byte_1&0x7)
 716   6                                                                      {
 717   7                                                                                      case PROTO_ADC_AMP_1:
 718   7                                                                                      {
 719   8                                                                                              TransferBuf[8]=(0x40|(OLD_PROTO_ADC_AMP_1<<1))&0xFE;     // первый байт состояния канала
 720   8                                                                                      }
 721   7                                                                                      break;
C51 COMPILER V9.00   PROTO_USO                                                             06/26/2014 10:40:45 PAGE 13  

 722   7                              
 723   7                                                                                      case PROTO_ADC_AMP_2:
 724   7                                                                                      {
 725   8                                                                                              TransferBuf[8]=(0x40|(OLD_PROTO_ADC_AMP_2<<1))&0xFE;     // первый байт состояния канала        
 726   8                                                                                      }
 727   7                                                                                      break;
 728   7                              
 729   7                                                                                      case PROTO_ADC_AMP_32:
 730   7                                                                                      {
 731   8                                                                                              TransferBuf[8]=(0x40|(OLD_PROTO_ADC_AMP_32<<1))&0xFE;    // первый байт состояния канала        
 732   8                                                                                      }
 733   7                                                                                      break;
 734   7                              
 735   7                                                                                      case PROTO_ADC_AMP_128:
 736   7                                                                                      {
 737   8                                                                                              TransferBuf[8]=(0x40|(OLD_PROTO_ADC_AMP_128<<1))&0xFE;   // первый байт состояния канала
 738   8                                                                                      }
 739   7                                                                                      break;
 740   7                              
 741   7                                                                                      default :
 742   7                                                                                      {
 743   8                                                                                              TransferBuf[8]=(0x40|(OLD_PROTO_ADC_AMP_1<<1))&0xFE;
 744   8                                                                                      }
 745   7                                                                                      break;                  
 746   7                                                                      }
 747   6                                                                      TransferBuf[9]=0x00;     // второй байт состояния канала
 748   6                                                        }
 749   5                                                        break; 
 750   5                                                 }
 751   4                                      }
 752   3                                      break;
 753   3      
 754   3                                       case CHNL_FREQ: //частотный
 755   3                                       { 
 756   4                                                switch(channels[channel].settings.set.modific)
 757   4                                            {   
 758   5                                                                
 759   5                                                                case CHNL_FREQ_COUNT_T:
 760   5                                                                {
 761   6                                                                                      TransferBuf[6]=((unsigned char*)(&channels[channel].channel_data))[2];
 762   6                                                                                      TransferBuf[7]=((unsigned char*)(&channels[channel].channel_data))[3];
 763   6      
 764   6                                                                }
 765   5                                                                break;
 766   5      
 767   5                                                                case CHNL_FREQ_256:
 768   5                                                                {
 769   6                                                                                      TransferBuf[6]=((unsigned char*)(&channels[channel].channel_data))[2];
 770   6                                                                                      TransferBuf[7]=((unsigned char*)(&channels[channel].channel_data))[3];
 771   6                                                                }
 772   5                                                                break; 
 773   5                                                 }
 774   4                                                 
 775   4                                              TransferBuf[8]=0x40;     // первый байт состояния канала
 776   4                                      TransferBuf[9]=0x00;     // второй байт состояния канала
 777   4                                        }
 778   3                                        break;                 
 779   3                        }
 780   2      
 781   2                 TransferBuf[10]=0xFF;
 782   2      
 783   2                 len=Proto_Paste_Null(TransferBuf,11);
C51 COMPILER V9.00   PROTO_USO                                                             06/26/2014 10:40:45 PAGE 14  

 784   2      
 785   2                 TransferBuf[len]=Old_CRC_Check(TransferBuf,len);
 786   2                 return len+1;
 787   2         }
 788   1         return 0;
 789   1      
 790   1      }
 791          //-----------------------------------------------------------------------------
 792          unsigned char Old_Channel_Get_State(void)
 793          {
 794   1        unsigned char channel=0;
 795   1        unsigned char len=0;
 796   1        channel=((RecieveBuf[4]>>3)&0x1F);
 797   1        if(channel<CHANNEL_NUMBER)
 798   1        {
 799   2        
 800   2                 TransferBuf[0]=0x00;TransferBuf[1]=0xD7;TransferBuf[2]=0x28;
 801   2                 TransferBuf[3]=0x0;  // 
 802   2                 TransferBuf[4]=RecieveBuf[4];
 803   2                 TransferBuf[5]=((OLD_CHANNEL_GET_STATE<<5)&0x1F)|0x3;//0x43;// код операции  
 804   2      
 805   2                              switch(channels[channel].settings.set.type)
 806   2                          {
 807   3                                       case CHNL_ADC:  //аналоговый канал
 808   3                                       {                
 809   4                                                switch(channels[channel].settings.set.state_byte_1&0x7)
 810   4                                                {
 811   5                                                              case PROTO_ADC_AMP_1:
 812   5                                                              {
 813   6                                                                      TransferBuf[6]=0x00|(OLD_PROTO_ADC_AMP_1<<1);    // первый байт состояния канала
 814   6                                                              }
 815   5                                                              break;
 816   5      
 817   5                                                              case PROTO_ADC_AMP_2:
 818   5                                                              {
 819   6                                                                      TransferBuf[6]=0x00|(OLD_PROTO_ADC_AMP_2<<1);    // первый байт состояния канала        
 820   6                                                              }
 821   5                                                              break;
 822   5      
 823   5                                                              case PROTO_ADC_AMP_32:
 824   5                                                              {
 825   6                                                                      TransferBuf[6]=0x00|(OLD_PROTO_ADC_AMP_32<<1);   // первый байт состояния канала        
 826   6                                                              }
 827   5                                                              break;
 828   5      
 829   5                                                              case PROTO_ADC_AMP_128:
 830   5                                                              {
 831   6                                                                      TransferBuf[6]=0x00|(OLD_PROTO_ADC_AMP_128<<1);  // первый байт состояния канала
 832   6                                                              }
 833   5                                                              break;
 834   5      
 835   5                                                              default :
 836   5                                                              {
 837   6                                                                      TransferBuf[6]=0x00|(OLD_PROTO_ADC_AMP_1<<1);    // первый байт состояния канала
 838   6                                                              }
 839   5                                                              break;
 840   5                                                }
 841   4                                                
 842   4                                                TransferBuf[7]=0x0A;   // второй байт состояния канала
 843   4                                        }
 844   3                                        break;
 845   3      
C51 COMPILER V9.00   PROTO_USO                                                             06/26/2014 10:40:45 PAGE 15  

 846   3                                      case CHNL_DOL:   //ДОЛ
 847   3                                      {
 848   4      
 849   4                                                      switch(channels[channel].settings.set.state_byte_1&0x7)
 850   4                                                      {
 851   5                                                                      case PROTO_ADC_AMP_1:
 852   5                                                                      {
 853   6                                                                              TransferBuf[6]=0x40|(OLD_PROTO_ADC_AMP_1<<1);    // первый байт состояния канала
 854   6                                                                      }
 855   5                                                                      break;
 856   5              
 857   5                                                                      case PROTO_ADC_AMP_2:
 858   5                                                                      {
 859   6                                                                              TransferBuf[6]=0x40|(OLD_PROTO_ADC_AMP_2<<1);    // первый байт состояния канала        
 860   6                                                                      }
 861   5                                                                      break;
 862   5              
 863   5                                                                      case PROTO_ADC_AMP_32:
 864   5                                                                      {
 865   6                                                                              TransferBuf[6]=0x40|(OLD_PROTO_ADC_AMP_32<<1);   // первый байт состояния канала        
 866   6                                                                      }
 867   5                                                                      break;
 868   5              
 869   5                                                                      case PROTO_ADC_AMP_128:
 870   5                                                                      {
 871   6                                                                              TransferBuf[6]=0x40|(OLD_PROTO_ADC_AMP_128<<1);  // первый байт состояния канала
 872   6                                                                      }
 873   5                                                                      break;
 874   5              
 875   5                                                                      default :
 876   5                                                                      {
 877   6                                                                              TransferBuf[6]=0x40;     // первый байт состояния канала
 878   6                                                                      }
 879   5                                                                      break;
 880   5              
 881   5                                                      }
 882   4                                                      TransferBuf[7]=0x00;     // второй байт состояния канала
 883   4                                      }
 884   3                                      break;
 885   3      
 886   3                                       case CHNL_FREQ: //частотный
 887   3                                       { 
 888   4                                                 
 889   4                                              TransferBuf[6]=0x40;     // первый байт состояния канала
 890   4                                      TransferBuf[7]=0x00;     // второй байт состояния канала
 891   4                                       }
 892   3                                       break;          
 893   3                        }
 894   2                 
 895   2                 len=Proto_Paste_Null(TransferBuf,8);
 896   2      
 897   2                 TransferBuf[len]=Old_CRC_Check(TransferBuf,len);
 898   2                 return len+1;
 899   2         }
 900   1         return 0;    
 901   1      }
 902          //-----------------------------------------------------------------------------
 903          unsigned char Old_Reinit_Block(void)
 904          {
 905   1              return 0;       
 906   1      }
 907          //-----------------------------------------------------------------------------
C51 COMPILER V9.00   PROTO_USO                                                             06/26/2014 10:40:45 PAGE 16  

 908          unsigned char Old_Channel_Set_ADC_Range(void)
 909          {
 910   1        unsigned char channel=0;
 911   1        channel=((RecieveBuf[4]>>3)&0x1F);
 912   1        if(channel<CHANNEL_NUMBER)
 913   1        {     
 914   2              switch((RecieveBuf[6]>>1)&0x3)
 915   2              {
 916   3                              case OLD_PROTO_ADC_AMP_1:
 917   3                              {
 918   4                                   channels[channel].settings.set.state_byte_1&=0xF0;
 919   4                                       channels[channel].settings.set.state_byte_1|=PROTO_ADC_AMP_1;
 920   4                              }
 921   3                              break;
 922   3      
 923   3                              case OLD_PROTO_ADC_AMP_2:
 924   3                              {
 925   4                                       channels[channel].settings.set.state_byte_1&=0xF0;
 926   4                                       channels[channel].settings.set.state_byte_1|=PROTO_ADC_AMP_2;
 927   4                              }
 928   3                              break;
 929   3      
 930   3                              case OLD_PROTO_ADC_AMP_32:
 931   3                              {
 932   4                                       channels[channel].settings.set.state_byte_1&=0xF0;
 933   4                                       channels[channel].settings.set.state_byte_1|=PROTO_ADC_AMP_32;
 934   4                              }
 935   3                              break;
 936   3      
 937   3                              case OLD_PROTO_ADC_AMP_128:
 938   3                              {
 939   4                                   channels[channel].settings.set.state_byte_1&=0xF0;
 940   4                                       channels[channel].settings.set.state_byte_1|=PROTO_ADC_AMP_128;
 941   4                              }
 942   3                              break;
 943   3      
 944   3                              default :
 945   3                              {
 946   4                                   channels[channel].settings.set.state_byte_1&=0xF0;
 947   4                                       channels[channel].settings.set.state_byte_1|=PROTO_ADC_AMP_1;
 948   4                              }
 949   3                              break;
 950   3              }
 951   2        }
 952   1        return 0;
 953   1      }
 954          //-----------------------------------------------------------------------------
 955          unsigned char Proto_Paste_Null(unsigned char *buf,unsigned char len)//т.к. старый протокол прибавляет к дл
             -ине количество 0 после D7 то обрабатываем вне прерывания
 956          {
 957   1              volatile unsigned char xdata i=0,j=0;
 958   1      
 959   1              for(i=3;i<len;i++) //пропустим заголовок 0x00 0xD7 0x28
 960   1              {
 961   2                       if(buf[i]==0xD7)
 962   2                       {
 963   3                               for(j=(len-1);j>i;j--)
 964   3                               {
 965   4                                      buf[j+1]=buf[j];//сдвигаем элементы буфера вправо на одну позицию до D7
 966   4                               }
 967   3                               buf[i+1]=0x0;//вставляем 0x00 после 0xD7
 968   3      
C51 COMPILER V9.00   PROTO_USO                                                             06/26/2014 10:40:45 PAGE 17  

 969   3                               if(protocol_type==PROTO_TYPE_OLD)
 970   3                               {
 971   4                                      buf[5]++;//длина кадра увеличилась на 1
 972   4                               }
 973   3      
 974   3                               len++;
 975   3                               i++;//не проверяем 0 спереди
 976   3                       }
 977   2              }
 978   1              return len;
 979   1      }
 980          //-----------------------------------------------------------------------------
 981          void ProtoBufHandling(void) //using 0 //процесс обработки принятого запроса
 982          {
 983   1              switch(protocol_type)
 984   1              {
 985   2                      case PROTO_TYPE_NEW:
 986   2                      {
 987   3                                channels[11].settings.set.state_byte_1=0x40; //восстановим байты статуса дола
 988   3                                channels[11].settings.set.state_byte_2=0x0A;
 989   3                                switch(RecieveBuf[4])
 990   3                                {
 991   4                              //---------------------------------------
 992   4                                      case GET_DEV_INFO_REQ:
 993   4                                      {
 994   5                                              buf_len=Send_Info();    
 995   5                                      }
 996   4                                      break;
 997   4                              //---------------------------------------
 998   4                                      case NODE_FULL_INIT_REQ:
 999   4                                      {
1000   5                                              buf_len=Node_Full_Init();
1001   5                                      }
1002   4                                      break;
1003   4                              //---------------------------------------
1004   4                                      case CHANNEL_LIST_INIT_REQ:
1005   4                                      {       
1006   5                                              buf_len=Channel_List_Init();    
1007   5                                      }
1008   4                                      break;
1009   4                              //---------------------------------------
1010   4                                      case CHANNEL_GET_DATA_REQ:
1011   4                                      {
1012   5                                              buf_len=Channel_Get_Data();     
1013   5                                      }
1014   4                                      break;
1015   4                                      //-----------------------------------
1016   4                                      case CHANNEL_SET_PARAMETERS_REQ:
1017   4                                      {
1018   5                                              buf_len=Channel_Set_Parameters();
1019   5                                      }
1020   4                                      break;
1021   4                                      //-----------------------------------
1022   4                                      case CHANNEL_SET_ORDER_QUERY_REQ:
1023   4                                      {
1024   5                                              buf_len=Channel_Set_Order_Query();
1025   5                                      }
1026   4                                      break;
1027   4                              //----------------------------------------
1028   4                                      case CHANNEL_GET_DATA_ORDER_REQ:
1029   4                                      {
1030   5                                               buf_len=Channel_Get_Data_Order();
C51 COMPILER V9.00   PROTO_USO                                                             06/26/2014 10:40:45 PAGE 18  

1031   5                                      }
1032   4                                      break;
1033   4                              //----------------------------------------
1034   4                                      case CHANNEL_SET_STATE_REQ:
1035   4                                      {
1036   5                                               buf_len=Channel_Set_State();
1037   5                                      }
1038   4                                      break;
1039   4                              //----------------------------------------
1040   4                                      case CHANNEL_GET_DATA_ORDER_M2_REQ:
1041   4                                      {
1042   5                                               buf_len=Channel_Get_Data_Order_M2();
1043   5                                      }
1044   4                                      break;
1045   4                              //------------------------------------------
1046   4                                      case CHANNEL_SET_RESET_STATE_FLAGS_REQ:
1047   4                                      {
1048   5                                              buf_len=Channel_Set_Reset_State_Flags();
1049   5                                      }
1050   4                                      break;
1051   4                              //------------------------------------------
1052   4                                      case CHANNEL_ALL_GET_DATA_REQ:
1053   4                                      {
1054   5                                               buf_len=Channel_All_Get_Data();
1055   5                                      }
1056   4                                      break;
1057   4                              //------------------------------------------
1058   4                                      case CHANNEL_SET_ADDRESS_DESC:
1059   4                                      {
1060   5                                               buf_len=Channel_Set_Address_Desc();
1061   5                                      }
1062   4                                      break;
1063   4                              //------------------------------------------
1064   4                                      case CHANNEL_SET_CALIBRATE:
1065   4                                      {
1066   5                                               buf_len=Channel_Set_Calibrate();
1067   5                                      }
1068   4                                      break;
1069   4                              //------------------------------------------
1070   4                                      case CHANNEL_SET_ALL_DEFAULT:
1071   4                                      {
1072   5                                               buf_len=Channel_Set_All_Default();
1073   5                                      }
1074   4                                      break;
1075   4                              //------------------------------------------
1076   4                                      case CHANNEL_GET_CALIBRATE_REQ:
1077   4                                      {
1078   5                                               buf_len=Channel_Get_Calibrate_Value();
1079   5                                      }
1080   4                                      break;
1081   4                              //------------------------------------------
1082   4                                  default:
1083   4                                      {
1084   5                                         buf_len=Request_Error(FR_COMMAND_NOT_EXIST);
1085   5                                  }                                                              
1086   4                                }
1087   3                      }
1088   2                      break;
1089   2      
1090   2                      case PROTO_TYPE_OLD: //старый протокол
1091   2                      {
1092   3                                switch((RecieveBuf[5]>>5)&0x7)
C51 COMPILER V9.00   PROTO_USO                                                             06/26/2014 10:40:45 PAGE 19  

1093   3                                {
1094   4                              //---------------------------------------
1095   4                                      case OLD_CHANNEL_REINIT_BLOCK:
1096   4                                      {
1097   5                                              buf_len=Old_Reinit_Block();     
1098   5                                      }
1099   4                                      break;
1100   4                              //---------------------------------------
1101   4                                      case OLD_CHANNEL_SET_ADC_RANGE:
1102   4                                      {
1103   5                                              buf_len=Old_Channel_Set_ADC_Range();
1104   5                                      }
1105   4                                      break;
1106   4                              //---------------------------------------
1107   4                                      case OLD_CHANNEL_GET_STATE:
1108   4                                      {       
1109   5                                              buf_len=Old_Channel_Get_State();        
1110   5                                      }
1111   4                                      break;
1112   4                              //---------------------------------------
1113   4                                      case OLD_CHANNEL_GET_DATA:
1114   4                                      {
1115   5                                              buf_len=Old_Channel_Get_Data(); 
1116   5                                      }
1117   4                                      break;
1118   4                                      //-----------------------------------
1119   4                                      case OLD_CHANNEL_GET_DATA_STATE:
1120   4                                      {
1121   5                                              buf_len=Old_Channel_Get_Data_State();
1122   5                                      }
1123   4                                      break;
1124   4                                      //-----------------------------------
1125   4                                  default:
1126   4                                      {
1127   5                                         
1128   5                                  }                                                              
1129   4                                }     
1130   3                       }
1131   2                       break;
1132   2                       
1133   2                       case PROTO_TYPE_MODBUS_ASCII:
1134   2                       {
1135   3                                switch(Sym_2_To_Char(&RecieveBuf[3]))//(MBCHAR2BIN(RecieveBuf[3])<<4| MBCHAR2BIN(RecieveBuf[4]))
1136   3                                {
1137   4                                      //---------------------------------------
1138   4                                              case MB_FUNC_READ_HOLDING_REGISTER:
1139   4                                              {
1140   5                                                      buf_len=ReadHoldingReg();       
1141   5                                              }
1142   4                                              break;
1143   4                                      //------------------------------------------
1144   4                                          default:
1145   4                                              {
1146   5                                                 buf_len=0x0;
1147   5                                          }                                                              
1148   4                                }
1149   3                       }
1150   2                       break; 
1151   2              }
1152   1      
1153   1        return;
1154   1      }
C51 COMPILER V9.00   PROTO_USO                                                             06/26/2014 10:40:45 PAGE 20  

1155          //-----------------------------------------------------------------------------------
1156          PT_THREAD(ProtoProcess(struct pt *pt))
1157           {
1158   1       static unsigned char  CRC=0x0, LRC=0x0;
1159   1        PT_BEGIN(pt);
1160   3      
1161   3        while(1) 
1162   3        {
1163   4        //----------restart------------
1164   4                      recieve_count=0x0;//??
1165   4                      REN=1;//recieve enqble
1166   4                      DE_RE=0;//линия на прием
1167   4                      ES=1;
1168   4        //-----------------------------
1169   4                // PT_WAIT_UNTIL(pt,RECIEVED); //ждем команды на старт
1170   4                 wdt_count[Proto_Proc].process_state=IDLE;
1171   4      
1172   4                 PT_YIELD_UNTIL(pt,RECIEVED); //ждем команды на старт 
1173   4                 wdt_count[Proto_Proc].process_state=RUN;
1174   4                 
1175   4      
1176   4                  RECIEVED=0;
1177   4                      
1178   4      
1179   4                      switch(protocol_type)
1180   4                      {
1181   5                              case PROTO_TYPE_NEW:
1182   5                              {
1183   6                                      if(RecieveBuf[3]!=ADRESS_DEV)//если адрес совпал          
1184   6                                      {
1185   7                                              PT_RESTART(pt);//если адрес не сошелся-перезапустим протокол                    
1186   7                                      }
1187   6      
1188   6                                      CRC=RecieveBuf[recieve_count-1];
1189   6      
1190   6                                  if(CRC_Check(&RecieveBuf,(recieve_count-CRC_LEN))!=CRC)
1191   6                                      {
1192   7                                              PT_RESTART(pt);//если CRC не сошлось-перезапустим протокол       
1193   7                                      }
1194   6                              }
1195   5                              break;
1196   5              
1197   5                              case PROTO_TYPE_OLD:
1198   5                              {
1199   6                                      CRC=RecieveBuf[recieve_count-1];
1200   6      
1201   6                                      if(Old_CRC_Check(&RecieveBuf,(recieve_count-CRC_LEN))!=CRC)
1202   6                                      {
1203   7                                              PT_RESTART(pt);//если CRC не сошлось-перезапустим протокол       
1204   7                                      }
1205   6                              }
1206   5                              break;
1207   5              
1208   5                              case PROTO_TYPE_MODBUS_ASCII:
1209   5                              {
1210   6                                      if(Sym_2_To_Char(&RecieveBuf[1])!=ADRESS_DEV)//((unsigned char)(MBCHAR2BIN(RecieveBuf[1])<<4| MBCHAR2B
             -IN(RecieveBuf[2]))!=ADRESS_DEV)
1211   6                                      {
1212   7                                              PT_RESTART(pt); 
1213   7                                      }       
1214   6                                      
1215   6                      
C51 COMPILER V9.00   PROTO_USO                                                             06/26/2014 10:40:45 PAGE 21  

1216   6                                      LRC=Sym_2_To_Char(&RecieveBuf[recieve_count-LRC_LEN]);//((MBCHAR2BIN(RecieveBuf[recieve_count-LRC_LEN]
             -)<<4)|(MBCHAR2BIN(RecieveBuf[recieve_count-LRC_LEN+1])));
1217   6                                              
1218   6                                      if(LRC_Check(&RecieveBuf[1],(recieve_count-LRC_LEN-1))!=LRC)
1219   6                                      {
1220   7                                              PT_RESTART(pt);//если LRC не сошлось-перезапустим протокол                       
1221   7                                      }
1222   6                              }
1223   5                              break;
1224   5                      }
1225   4      
1226   4              //      PT_YIELD(pt);//дадим другим процессам время
1227   4        //-----------------------------
1228   4                      ProtoBufHandling();//процедура обработки сообщения      
1229   4                      if(buf_len==0)//если в буфере пусто
1230   4                      {
1231   5                              PT_RESTART(pt);//перезапустим протокол  
1232   5                      }
1233   4                      else
1234   4                      {
1235   5                              if(protocol_type==PROTO_TYPE_NEW)
1236   5                              {
1237   6                                      buf_len=Proto_Paste_Null(TransferBuf,buf_len);
1238   6                              }
1239   5      
1240   5                              DE_RE=1; //переключаем RS485 в режим передачи
1241   5                                                              
1242   5                              REN=0;  //запрет приема-только передача
1243   5                              transf_count=0;
1244   5                              SBUF=TransferBuf[transf_count];//передача байта, остальным займется автомат
1245   5                              transf_count++;//инкрементируем счетчик переданных
1246   5                              ES=1; //включим прерывание уарт 
1247   5      
1248   5                              wdt_count[Proto_Proc].count++;
1249   5      
1250   5                          if(protocol_type==PROTO_TYPE_NEW)
1251   5                              {
1252   6                                      PT_DELAY(pt,10);
1253   6                              }
1254   5                              else
1255   5                              {
1256   6                                      PT_DELAY(pt,3);
1257   6                              }                       
1258   5                      }               
1259   4        //-----------------------------
1260   4        
1261   4        }
1262   3      
1263   3       PT_END(pt);
1264   1      }
1265          //-----------------------------------------------------------------------------------------------
1266          void Store_Dev_Address_Desc(unsigned char addr,void* name,void* ver,void* desc,unsigned char desc_len)//со
             -хранить в ППЗУ новый адрес устройства, имя, версию, описание
1267          {
1268   1      //небезопасная
1269   1              
1270   1              unsigned int blocks=0;//здесь будет количество блоков, нужных дя сохранения комментария
1271   1              
1272   1              EEPROM_Write(&addr,1,DEVICE_ADDR_EEPROM);        //1 блок
1273   1              EEPROM_Write(name,DEVICE_NAME_LENGTH,DEVICE_NAME_EEPROM); //5 блоков
1274   1              memcpy(DEV_NAME,name,DEVICE_NAME_LENGTH_SYM);//копируем полученное имя в буфер
1275   1      
C51 COMPILER V9.00   PROTO_USO                                                             06/26/2014 10:40:45 PAGE 22  

1276   1              EEPROM_Write(ver,DEVICE_VER_LENGTH,DEVICE_VER_EEPROM);          //2 блока
1277   1              memcpy(VERSION,ver,DEVICE_VER_LENGTH_SYM);//копируем версию в буфер
1278   1      
1279   1              blocks=desc_len>>2;//в блоке 4 байта, делим на 4
1280   1              if(desc_len&0xFC)//если есть остаток, то берем еще один блок
1281   1                      blocks++;
1282   1              
1283   1              if(blocks>DEVICE_DESC_MAX_LENGTH) //ограничение на количество блоков для комментария
1284   1                      blocks=DEVICE_DESC_MAX_LENGTH;
1285   1      
1286   1              EEPROM_Write(desc,(unsigned int)blocks,DEVICE_DESC_EEPROM);
1287   1              dev_desc_len=desc_len;
1288   1              EEPROM_Write(&desc_len,1,DEVICE_DESC_LEN_EEPROM);//сохраним длину комментария
1289   1              
1290   1              memcpy(NOTICE,desc,desc_len);//копируем описание в буфер
1291   1              
1292   1              return;
1293   1      }
1294          //-----------------------------------------------------------------------------------------------
1295          void Restore_Dev_Address_Desc(void)//восстановить из ппзу адрес и информацию об устройстве
1296          {
1297   1              unsigned int blocks=0;//здесь будет количество блоков, нужных дя сохранения комментария
1298   1              
1299   1              EEPROM_Read(&ADRESS_DEV,1,DEVICE_ADDR_EEPROM);   //1 блок восстанавливаем адрес из ППЗУ
1300   1      
1301   1              if(ADRESS_DEV<1 || ADRESS_DEV>15)
1302   1                      ADRESS_DEV=1; 
1303   1      
1304   1              EEPROM_Read(DEV_NAME,DEVICE_NAME_LENGTH,DEVICE_NAME_EEPROM); //5 блоков
1305   1          EEPROM_Read(VERSION,DEVICE_VER_LENGTH,DEVICE_VER_EEPROM);
1306   1      
1307   1              EEPROM_Read(&dev_desc_len,1,DEVICE_DESC_LEN_EEPROM);//длина описания устройства в байтах
1308   1      
1309   1              if(dev_desc_len>DEVICE_DESC_MAX_LENGTH_SYM)
1310   1                      dev_desc_len=DEVICE_DESC_MAX_LENGTH_SYM;
1311   1      
1312   1              blocks=dev_desc_len>>2;//в блоке 4 байта, делим на 4
1313   1              if(dev_desc_len&0xFC)//если есть остаток, то берем еще один блок
1314   1                      blocks++;
1315   1      
1316   1              if(blocks>DEVICE_DESC_MAX_LENGTH) //ограничение на количество блоков для комментария     ???
1317   1                      blocks=DEVICE_DESC_MAX_LENGTH;
1318   1      
1319   1              EEPROM_Read(NOTICE,(unsigned int)blocks,DEVICE_DESC_EEPROM);
1320   1              return;
1321   1      }
1322          //-----------------------------------------------------------------------------------------------
1323           PT_THREAD(RingBufHandling(struct pt *pt))//обработка кольцевого буфера
1324           {
1325   1              static unsigned char temp_count=0;//временные копии конца  и счетчика буфера
1326   1              static unsigned char temp_tail=0;
1327   1      
1328   1              static unsigned char i=0;
1329   1              static unsigned char CUT_OUT_NULL=0;//флаг-вырезаем 0 после 0xD7
1330   1      
1331   1        PT_BEGIN(pt);
1332   3      
1333   3        CUT_OUT_NULL=0;
1334   3      
1335   3        while(1) 
1336   3        {
1337   4                      wdt_count[RingBufHandling_Proc].process_state=IDLE;
C51 COMPILER V9.00   PROTO_USO                                                             06/26/2014 10:40:45 PAGE 23  

1338   4                      PT_YIELD_UNTIL(pt,(rngbuf.count>0x0));//в буфере есть данные
1339   4                      wdt_count[RingBufHandling_Proc].process_state=RUN;
1340   4              
1341   4      
1342   4                      ES=0;
1343   4                      temp_count=rngbuf.count;
1344   4                      rngbuf.count=0x0;
1345   4                      temp_tail =rngbuf.tail;
1346   4                      ES=1;
1347   4      
1348   4                      for(i=(temp_tail-temp_count);i!=temp_tail;i++)//поиск стартовой последовательности
1349   4                      {
1350   5                              if(i2c_channels.I2C_CHNL.channels.protocol_type==PROTO_MB_ASCII)
1351   5                              {
1352   6                                      switch(rngbuf.buf[i])
1353   6                                      {
1354   7                                              //---------MB ASCII------
1355   7                                              case  0x3A:      //":"
1356   7                                              {               
1357   8                                                      recieve_count=0x0;
1358   8                                                      RecieveBuf[recieve_count]=rngbuf.buf[i];
1359   8                                                      protocol_type=PROTO_TYPE_MODBUS_ASCII;
1360   8                                                      recieve_count++;                                                                 
1361   8                                              }
1362   7                                              break;
1363   7                      
1364   7                                              case 0xA:        //"LF"
1365   7                                              {
1366   8                                                      RECIEVED=1;//буфер принят
1367   8                                                      ES=0;
1368   8                                                      REN=0;  //recieve disable 
1369   8                                              }
1370   7                                              break;
1371   7                      
1372   7                                              case 0xD:        //"CR"
1373   7                                              {
1374   8                                                      //
1375   8                                              }
1376   7                                              break;  
1377   7                                              
1378   7                                              default:
1379   7                                              {
1380   8                                                      if(((rngbuf.buf[i]>='0' && rngbuf.buf[i]<='9') || (rngbuf.buf[i]>='A' && rngbuf.buf[i]<='F')))
1381   8                                                      {
1382   9                                                              RecieveBuf[recieve_count]=rngbuf.buf[i];
1383   9                                                              recieve_count++;        
1384   9                                                      }
1385   8                                              }
1386   7                                              break;                          
1387   7                                      }                               
1388   6                              }
1389   5                              else
1390   5                              {
1391   6                                      switch(rngbuf.buf[i])
1392   6                                      {
1393   7                                                      case (char)(0xD7):
1394   7                                                      {
1395   8                                                              RecieveBuf[recieve_count]=rngbuf.buf[i];
1396   8                                                              recieve_count++;
1397   8                                                              CUT_OUT_NULL=1;          
1398   8                                                      }
1399   7                                                      break;
C51 COMPILER V9.00   PROTO_USO                                                             06/26/2014 10:40:45 PAGE 24  

1400   7                              
1401   7                                                      case (char)(0x29):
1402   7                                                      {
1403   8                                                              if(CUT_OUT_NULL==1)
1404   8                                                              {
1405   9                                                                      RecieveBuf[0]=0x0;
1406   9                                                                      RecieveBuf[1]=0xD7;
1407   9                                                                      RecieveBuf[2]=0x29;
1408   9                                                                      recieve_count=0x3;
1409   9                                                                      protocol_type=PROTO_TYPE_NEW;                   
1410   9                                                              }
1411   8                                                              else
1412   8                                                              {
1413   9                                                                      RecieveBuf[recieve_count]=rngbuf.buf[i];
1414   9                                                                      recieve_count++;        
1415   9                                                              }
1416   8                                                              CUT_OUT_NULL=0;
1417   8                                                      }
1418   7                                                      break;
1419   7                              
1420   7                                                      case (char)(0x28):
1421   7                                                      {
1422   8                                                              if(CUT_OUT_NULL==1)
1423   8                                                              {
1424   9                                                                      RecieveBuf[0]=0x0;
1425   9                                                                      RecieveBuf[1]=0xD7;
1426   9                                                                      RecieveBuf[2]=0x28;
1427   9                                                                      recieve_count=0x3;
1428   9                                                                      protocol_type=PROTO_TYPE_OLD;                   
1429   9                                                              }
1430   8                                                              else
1431   8                                                              {
1432   9                                                                      RecieveBuf[recieve_count]=rngbuf.buf[i];
1433   9                                                                      recieve_count++;        
1434   9                                                              }
1435   8                                                              CUT_OUT_NULL=0;
1436   8                                                      }
1437   7                                                      break;
1438   7                              
1439   7                                                      case (char)(0x0):
1440   7                                                      {
1441   8                                                              if(CUT_OUT_NULL==1)       //если после 0xD7-пропускаем
1442   8                                                              {
1443   9                                                                      CUT_OUT_NULL=0;         
1444   9                                                              }
1445   8                                                              else
1446   8                                                              {
1447   9                                                                      RecieveBuf[recieve_count]=rngbuf.buf[i];
1448   9                                                                      recieve_count++;        
1449   9                                                              }
1450   8                                                      }
1451   7                                                      break;          
1452   7                                                      //-----------------------
1453   7                              
1454   7                                                      default :
1455   7                                                      {
1456   8                                                              RecieveBuf[recieve_count]=rngbuf.buf[i];
1457   8                                                              recieve_count++;
1458   8                                                              CUT_OUT_NULL=0;         
1459   8                                                      }
1460   7                                              }
1461   6                              
C51 COMPILER V9.00   PROTO_USO                                                             06/26/2014 10:40:45 PAGE 25  

1462   6                                         if(recieve_count>6)
1463   6                                         {
1464   7                                                        if(recieve_count==6+frame_len)          // принимаем указанное в frame_len число байт данные, 6 значит
             - что обмен идет с компом, надо ставаить 5 чтобы обмениваться с устройствами
1465   7                                                        {
1466   8                                                                      RECIEVED=1;//буфер принят
1467   8                                                                      ES=0;
1468   8                                                                      REN=0;  //recieve disable -запрещаем принимать в буфер  
1469   8                                                                      CUT_OUT_NULL=0;                                                 
1470   8                                                        }      
1471   7                                                        
1472   7                                                        //----------------------обрабатываем возможные ошибки длины кадра-------------
1473   7                                                    if(recieve_count>MAX_LENGTH_REC_BUF)      //если посылка слишком длинная
1474   7                                                        {
1475   8                                                                      PT_RESTART(&pt_proto);  //внепроцессный рестарт
1476   8                                                        }  
1477   7                                         }
1478   6                                         else
1479   6                                         {
1480   7                                                         if(recieve_count==6)
1481   7                                                         {     
1482   8                                                              
1483   8                                                                      frame_len=RecieveBuf[recieve_count-1];  // получаем длину данных после заголовка
1484   8                                                                      if(protocol_type==PROTO_TYPE_OLD)
1485   8                                                                      {
1486   9                                                                              frame_len&=0x1F;//в старом протоколе только 5 младших бит -длина оставшейся части       
1487   9                                                                      }                                        
1488   8                                                         }                    
1489   7                                         }
1490   6                                      }
1491   5                                                                                                                                      
1492   5                      }
1493   4                      wdt_count[RingBufHandling_Proc].count++;
1494   4                      PT_YIELD(pt);//дадим другим процессам время     
1495   4        }
1496   3      
1497   3        PT_END(pt);
1498   1       }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   8382    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    946       1
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      1       2
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
