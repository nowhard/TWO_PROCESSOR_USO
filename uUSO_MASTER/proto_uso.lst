C51 COMPILER V9.00   PROTO_USO                                                             06/23/2014 16:07:07 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE PROTO_USO
OBJECT MODULE PLACED IN proto_uso.obj
COMPILER INVOKED BY: C:\Program Files\Keil\C51\BIN\C51.EXE proto_uso\proto_uso.c LARGE OPTIMIZE(6,SPEED) BROWSE ORDER NO
                    -AREGS DEBUG OBJECTEXTEND PRINT(.\proto_uso.lst) OBJECT(proto_uso.obj)

line level    source

   1          #include "proto_uso.h"
   2          #include "calibrate\calibrate.h"
   3          #include "i2c.h"
   4          #include <intrins.h>
   5          #include "crc_table.h"
   6          #include "channels.h"
   7          #include "watchdog.h"
   8          #include "modbus\modbus_ascii.h"
   9          //-----------------------------------------------------------------------------------
  10          
  11          sbit DE_RE=P3^5;
  12          
  13          //-----------------------------------------------------------------------------------
  14          unsigned char xdata DEV_NAME[DEVICE_NAME_LENGTH_SYM] ="<<uUSO_2>>"; //имя устройства
  15          unsigned char xdata NOTICE[DEVICE_DESC_MAX_LENGTH_SYM]="<-- GEOSPHERA_2012 -->";//примечание    
  16          unsigned char xdata VERSION[DEVICE_VER_LENGTH_SYM] ="\x30\x30\x30\x30\x31";     // версия программы ПЗУ не бол
             -ьше 5 байт
  17          
  18          unsigned char xdata ADRESS_DEV=0x1;
  19          
  20          unsigned char xdata dev_desc_len=20;//длина описания устройства
  21          //--------------------------------global variable------------------------------------
  22          unsigned char xdata     RECIEVED=0;//принято
  23          unsigned int  xdata recieve_count;//счетчик приемного буфера
  24          unsigned char xdata     transf_count;//счетчик передаваемых байтов         
  25          unsigned char xdata     buf_len;//длина передаваемого буфера
  26          
  27          //------------------------флаги ошибок--------------------------------
  28          
  29          unsigned char xdata frame_len=0;//длина кадра, которую вытаскиваем из шестого байта кадра
  30          //--------------------------------------------------------------------
  31          unsigned char xdata  RecieveBuf[MAX_LENGTH_REC_BUF]={0} ; //буфер принимаемых данных
  32          //volatile unsigned char xdata                  *TransferBuf;
  33          unsigned char xdata  TransferBuf[MAX_LENGTH_TR_BUF]={0} ; //буфер передаваемых данных
  34          //--------------------------------------------------------------------
  35          volatile unsigned char xdata  STATE_BYTE=0xC0;//байт состояния устройства
  36          unsigned char xdata protocol_type=PROTO_TYPE_NEW;//тип протокола
  37          
  38          volatile struct pt pt_proto, pt_buf_handle;
  39          
  40          volatile struct RingBuf rngbuf;
  41          //-----------------------------------------------------------------------------------
  42          union //объединение для конвертирования char->long
  43          {
  44                  float result_float;
  45                  unsigned char result_char[4];
  46          }
  47          sym_8_to_float;
  48          
  49          extern unsigned char idata i2c_buffer[6];
  50          extern unsigned char channel_number;//количество каналов
  51          
  52          //-----------------------------------------------------------------------------------
  53          //#pragma OT(0,Speed)
C51 COMPILER V9.00   PROTO_USO                                                             06/23/2014 16:07:07 PAGE 2   

  54          void UART_ISR(void) interrupt 4 //using 1
  55          {       
  56   1              EA=0;   //запрет прерывания
  57   1              
  58   1              if(RI)
  59   1              {
  60   2                      RI=0; 
  61   2                      rngbuf.buf[rngbuf.tail]=SBUF;
  62   2                      rngbuf.tail++;
  63   2                      rngbuf.count++;                                                                         
  64   2              }
  65   1      //----------------------------передача-----------------------------------------------
  66   1              if(TI)
  67   1              {
  68   2                      TI=0;
  69   2                       
  70   2                      if(transf_count<buf_len)
  71   2                      {
  72   3      
  73   3                                      SBUF=TransferBuf[transf_count];                 
  74   3                                      transf_count++;
  75   3                      }
  76   2                      else
  77   2                      {
  78   3                              transf_count=0;         //обнуляем счетчик
  79   3                              PT_RESTART_OUT(pt_proto);  //внепроцессный рестарт                      
  80   3                      }                                          
  81   2              }                       
  82   1              EA=1;
  83   1              return;
  84   1      }
  85          //------------------------------------------------------------------------------
  86          //#pragma OT(6,Speed)
  87          void Protocol_Init(void) //using 0
  88          {
  89   1              TI=0;
  90   1              RI=0;
  91   1              
  92   1      
  93   1              Restore_Dev_Address_Desc();
  94   1      
  95   1              rngbuf.tail=0;
  96   1              rngbuf.head=0;
  97   1              rngbuf.count=0;
  98   1      
  99   1              recieve_count=0x0;//счетчик буфера приема
 100   1              transf_count=0x0;//счетчик передаваемых байтов
 101   1              buf_len=0x0;//длина передаваемого буфера
 102   1              DE_RE=0;//линия на прием
 103   1              //CUT_OUT_NULL=0;
 104   1              STATE_BYTE=0xC0;
 105   1              PT_INIT(&pt_proto);
 106   1              PT_INIT(&pt_buf_handle);
 107   1              return;
 108   1      }
 109          //-----------------------------------------------------------------------------
 110          unsigned char Send_Info(void) //using 0    //посылка информации об устройстве
 111          {
 112   1                  unsigned char    i=0;
 113   1                                                                                      
 114   1                 //заголовок кадра---
 115   1                 TransferBuf[0]=0x00;
C51 COMPILER V9.00   PROTO_USO                                                             06/23/2014 16:07:07 PAGE 3   

 116   1                 TransferBuf[1]=0xD7;
 117   1                 TransferBuf[2]=0x29;
 118   1                 //------------------
 119   1                 TransferBuf[3]=ADRESS_DEV;  // адрес узла
 120   1                 TransferBuf[4]=GET_DEV_INFO_RESP;  // код операции
 121   1                 TransferBuf[6]=STATE_BYTE;
 122   1      
 123   1                 for(i=0;i<20;i++)
 124   1                 {                              // записываем наименование изделия
 125   2                                 if(i<DEVICE_NAME_LENGTH_SYM)
 126   2                                 {
 127   3                                      TransferBuf[i+7]=DEV_NAME[i];
 128   3                                 }
 129   2                                 else
 130   2                                 {
 131   3                                              TransferBuf[i+7]=0x00;
 132   3                                 }
 133   2                      }
 134   1              
 135   1                 for(i=0;i<5;i++)                   // записываем версию ПЗУ
 136   1                 {
 137   2                     if(i<DEVICE_VER_LENGTH_SYM)
 138   2                         {
 139   3                               TransferBuf[i+27]=VERSION[i];
 140   3                         }
 141   2                 }
 142   1      
 143   1                 TransferBuf[32]=channel_number;                 // количество каналов
 144   1      
 145   1                 for(i=0;i<channel_number;i++)                                   // данные по каналу
 146   1             {
 147   2                              TransferBuf[i*2+33]=((channels[i].settings.set.type)<<4)|channels[i].settings.set.modific; // байт да
             -нных
 148   2                              TransferBuf[i*2+33+1]=0x00;                                                     // резерв байт
 149   2                 }    
 150   1                 for(i=0;i<dev_desc_len;i++)                                  // записываем примечание
 151   1                 {
 152   2                               TransferBuf[i+33+channel_number*2]=NOTICE[i];
 153   2                 }
 154   1                              
 155   1                 TransferBuf[5]=28+channel_number*2+dev_desc_len;                     // подсчет длины данных 
 156   1                 TransferBuf[33+channel_number*2+dev_desc_len]=CRC_Check(&TransferBuf[1],32+channel_number*2+dev_desc_l
             -en); // подсчет контрольной суммы
 157   1      
 158   1              return (34+channel_number*2+dev_desc_len);
 159   1      }
 160          //-----------------------------------------------------------------------------
 161          unsigned char Node_Full_Init(void) //using 0 //полная инициализация узла
 162          {
 163   1              return 0;
 164   1      }
 165          //-----------------------------------------------------------------------------
 166          unsigned char Channel_List_Init(void) //using 0 //Инициализация списка каналов узла (без потери данных);
 167          {
 168   1              return 0;
 169   1      }
 170          //-----------------------------------------------------------------------------
 171          unsigned char Channel_Get_Data(void) //using 0 //Выдать данные по каналам, согласно абсолютной нумерации;
 172          {
 173   1              return 0;
 174   1      }
 175          //-----------------------------------------------------------------------------
C51 COMPILER V9.00   PROTO_USO                                                             06/23/2014 16:07:07 PAGE 4   

 176          unsigned char  Channel_Set_Parameters(void) //using 0 //Установить параметры по каналам, согласно абсолютн
             -ой нумерации;
 177          {
 178   1             unsigned char  index=0, store_data=0;//i=0;
 179   1               
 180   1                 while(index<RecieveBuf[5]-1)                            // данные по каналам
 181   1                    {
 182   2                                      if(RecieveBuf[6+index]<channel_number)
 183   2                                  {
 184   3                                              switch((RecieveBuf[6+index+1]>>4)&0xF)
 185   3                                              {
 186   4                                                              case CHNL_ADC://АЦП
 187   4                                                              {
 188   5                                                                      if((channels[RecieveBuf[6+index]].settings.set.modific!=RecieveBuf[6+index+1])||(channels[RecieveB
             -uf[6+index]].settings.set.state_byte_1!=RecieveBuf[6+index+2]) || (channels[RecieveBuf[6+index]].settings.set.state_byte
             -_2!=RecieveBuf[6+index+3]))
 189   5                                                                      {  
 190   6                                                                              channels[RecieveBuf[6+index]].settings.set.state_byte_1=RecieveBuf[6+index+2];
 191   6                                                                              channels[RecieveBuf[6+index]].settings.set.state_byte_2=RecieveBuf[6+index+3];
 192   6                                                                              channels[RecieveBuf[6+index]].settings.set.modific         =RecieveBuf[6+index+1]&0xF;
 193   6                                                                              store_data=1;
 194   6                                                                              
 195   6                                                                      }
 196   5                                                                      index++;
 197   5                                                              }
 198   4                                                              break;
 199   4      
 200   4      
 201   4                                                              default :
 202   4                                                              {
 203   5                                                                      _nop_();
 204   5                                                              }                       
 205   4                                              }
 206   3                                              index=index+3;
 207   3                                      }
 208   2                                      else
 209   2                                      {
 210   3                                              return Request_Error(FR_UNATTENDED_CHANNEL);
 211   3                                      }
 212   2                        }
 213   1                 if(store_data)
 214   1                 {
 215   2                              Store_Channels_Data();  //сохраним настройки каналов в ППЗУ
 216   2                 }
 217   1      
 218   1                 return Request_Error(FR_SUCCESFUL);
 219   1      }
 220          //-----------------------------------------------------------------------------
 221          unsigned char Channel_Set_Order_Query(void) //using 0 //Задать последовательность опроса;
 222          {
 223   1              return 0;
 224   1      }
 225          //-----------------------------------------------------------------------------
 226          unsigned char Channel_Get_Data_Order(void) //using 0 //Выдать данные по каналам, согласно последовательнос
             -ти опроса;
 227          {
 228   1              return 0;
 229   1      }
 230          //-----------------------------------------------------------------------------
 231          unsigned char Channel_Set_State(void) //using 0 //Установить состояния по каналам, согласно абсолютной нум
             -ерации;
 232          {
C51 COMPILER V9.00   PROTO_USO                                                             06/23/2014 16:07:07 PAGE 5   

 233   1              return 0;
 234   1      }
 235          //-----------------------------------------------------------------------------
 236          unsigned char  Channel_Get_Data_Order_M2(void) //using 0 //Выдать данные по каналам, согласно последовател
             -ьности опроса;
 237          {
 238   1              return 0;
 239   1      }
 240          //-----------------------------------------------------------------------------
 241          unsigned char Channel_Set_Reset_State_Flags(void) //using 0 //  Установка/Сброс флагов состояния 
 242          {
 243   1              STATE_BYTE=0x40;
 244   1              i2c_buffer[0]=0x12;//сбросим флаг инициализации ведомого
 245   1              ChannelsInit();
 246   1              return  Request_Error(FR_SUCCESFUL);//ошибки нет, подтверждение
 247   1      }
 248          //-----------------------------------------------------------------------------
 249          #pragma OT(9,Speed)
 250          unsigned char Channel_All_Get_Data(void) //using 0 //Выдать информацию по всем каналам узла (расширенный р
             -ежим);
 251          {
 252   1         unsigned char data index=0,i=0;
 253   1      
 254   1      
 255   1         TransferBuf[0]=0x00;TransferBuf[1]=0xD7;TransferBuf[2]=0x29;
 256   1         TransferBuf[3]=ADRESS_DEV;  // адрес узла
 257   1         TransferBuf[4]=CHANNEL_ALL_GET_DATA_RESP;  // код операции
 258   1         TransferBuf[6]=STATE_BYTE;
 259   1      
 260   1         index=7;//длина заголовка
 261   1       
 262   1          for(i=0;i<channel_number;i++)                                  // данные по каналам
 263   1          {
 264   2                        TransferBuf[index++]=i;
 265   2                        TransferBuf[index++]=((channels[i].settings.set.type)<<4)|channels[i].settings.set.modific; // тип и м
             -одификация канала
 266   2                        switch(channels[i].settings.set.type)
 267   2                          {
 268   3                                       case CHNL_ADC:  //аналоговый канал
 269   3                                       {
 270   4                                               switch(channels[i].settings.set.modific)
 271   4                               {
 272   5                                                        case CHNL_ADC_FIX_16:
 273   5                                                        {
 274   6                                                                      if(channels[i].calibrate.cal.calibrate==1)//калиброванный
 275   6                                                                      {                                                
 276   7                                                                                      TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data_calibrate))[2];
 277   7                                                                              TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data_calibrate))[1];
 278   7                                                                      }
 279   6                                                                      else
 280   6                                                                      {
 281   7                                                                                      TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data))[2];
 282   7                                                                              TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data))[1];  
 283   7                                                                      } 
 284   6      
 285   6                                                                        
 286   6                                                                       TransferBuf[index++]=channels[i].settings.set.state_byte_1;     // первый байт состояния канала
 287   6                                               TransferBuf[index++]=channels[i].settings.set.state_byte_2;     // второй байт сос
             -тояния канала
 288   6                                                        }
 289   5                                                        break; 
 290   5      
C51 COMPILER V9.00   PROTO_USO                                                             06/23/2014 16:07:07 PAGE 6   

 291   5                                                        case CHNL_ADC_FIX_24:
 292   5                                                        {
 293   6                                                              if(channels[i].calibrate.cal.calibrate==1)//калиброванный
 294   6                                                                      {                                                                                                 
 295   7                                                                                      TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data_calibrate))[3];
 296   7                                                                                      TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data_calibrate))[2];
 297   7                                                                              TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data_calibrate))[1];
 298   7                                                                      }
 299   6                                                                      else
 300   6                                                                      {                                                                        
 301   7                                                                                      TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data))[3];
 302   7                                                                                      TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data))[2];
 303   7                                                                              TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data))[1];  
 304   7                                                                      } 
 305   6                        
 306   6                                                                        TransferBuf[index++]=channels[i].settings.set.state_byte_1;    // первый байт состояния канала
 307   6                                                TransferBuf[index++]=channels[i].settings.set.state_byte_2;    // второй байт со
             -стояния канала
 308   6                                                        }
 309   5                                                        break;
 310   5                                                }
 311   4                                        }
 312   3                                        break;
 313   3      
 314   3                                      case CHNL_DOL:   //ДОЛ
 315   3                                      {
 316   4                                                switch(channels[i].settings.set.modific)
 317   4                                            {   
 318   5                                                                case CHNL_DOL_ENC:
 319   5                                                                {
 320   6                                                                                      TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data))[3];
 321   6                                                                                      TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data))[2];
 322   6                                                                              TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data))[1];
 323   6                                                                                      TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data))[0];
 324   6                                                                                  TransferBuf[index++]=channels[i].settings.set.state_byte_1;  // первый байт состояния канала
 325   6                                                                }
 326   5                                                                break; 
 327   5                                                 }
 328   4                                      }
 329   3                                      break;
 330   3      
 331   3                                       case CHNL_FREQ: //частотный
 332   3                                       { 
 333   4                                                switch(channels[i].settings.set.modific)
 334   4                                            {   
 335   5                                                                
 336   5                                                                case CHNL_FREQ_COUNT_T:
 337   5                                                                {
 338   6                                                                                      TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data))[3];
 339   6                                                                                      TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data))[2];
 340   6                                                                                TransferBuf[index++]=channels[i].settings.set.state_byte_1;    // первый байт состояния канала
 341   6                                                                }
 342   5                                                                break;
 343   5      
 344   5                                                                case CHNL_FREQ_256:
 345   5                                                                {
 346   6                                                                                      TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data))[3];
 347   6                                                                                      TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data))[2];
 348   6                                                                                  TransferBuf[index++]=channels[i].settings.set.state_byte_1;  // первый байт состояния канала
 349   6                                                                }
 350   5                                                                break; 
 351   5                                                 }
C51 COMPILER V9.00   PROTO_USO                                                             06/23/2014 16:07:07 PAGE 7   

 352   4                                        }
 353   3                                        break;                 
 354   3                        }
 355   2                 }
 356   1      
 357   1                TransferBuf[5]=index+2-7;                                              // подсчет длины данных двойка это 1(байт статуса)+1(контрольная сумма
             -)
 358   1                TransferBuf[index]=CRC_Check(&TransferBuf[1],(unsigned int)(index)-1); // подсчет кс
 359   1                return (unsigned char)(index+1);
 360   1      }
 361          //-----------------------------------------------------------------------------
 362          #pragma OT(0,Speed)
 363          unsigned char Channel_Set_Calibrate(void)//установить верхнюю или нижнюю точку калибровки
 364          {
 365   1      
 366   1              float K,C;      
 367   1      
 368   1              sym_8_to_float.result_char[0]=RecieveBuf[11];
 369   1              sym_8_to_float.result_char[1]=RecieveBuf[10];
 370   1              sym_8_to_float.result_char[2]=RecieveBuf[9];
 371   1              sym_8_to_float.result_char[3]=RecieveBuf[8];
 372   1      
 373   1              K=sym_8_to_float.result_float;
 374   1      
 375   1              sym_8_to_float.result_char[0]=RecieveBuf[15];
 376   1              sym_8_to_float.result_char[1]=RecieveBuf[14];
 377   1              sym_8_to_float.result_char[2]=RecieveBuf[13];
 378   1              sym_8_to_float.result_char[3]=RecieveBuf[12];
 379   1      
 380   1              C=sym_8_to_float.result_float;
 381   1      
 382   1              switch(RecieveBuf[7])
 383   1              {
 384   2                      case 0:
 385   2                      {
 386   3                              Calibrate(RecieveBuf[6],K,C);   
 387   3                      }
 388   2                      break;
 389   2      
 390   2                      case 1:
 391   2                      {
 392   3                              Calibrate_Set_Flag(RecieveBuf[6],RESET);
 393   3                      }
 394   2                      break;
 395   2      
 396   2                      case 2:
 397   2                      {
 398   3                              Calibrate_Set_Flag(RecieveBuf[6],SET);  
 399   3                      }
 400   2                      break;
 401   2      
 402   2                      default :
 403   2                      {
 404   3                              _nop_();
 405   3                      }
 406   2                      break;
 407   2              }
 408   1      
 409   1      
 410   1              return  Request_Error(FR_SUCCESFUL);//ошибки нет, подтверждение 
 411   1      }
 412          //------------------------------------------------------------------------------
C51 COMPILER V9.00   PROTO_USO                                                             06/23/2014 16:07:07 PAGE 8   

 413          unsigned char Channel_Get_Calibrate_Value(void)//получить коэфициенты калибровки заданного канала
 414          {
 415   1         unsigned char data channel=0;
 416   1      
 417   1      
 418   1         TransferBuf[0]=0x00;TransferBuf[1]=0xD7;TransferBuf[2]=0x29;
 419   1         TransferBuf[3]=ADRESS_DEV;  // адрес узла
 420   1         TransferBuf[4]=CHANNEL_GET_CALIBRATE_RESP;  // код операции
 421   1         TransferBuf[5]=0xB;//длина оставшейся части кадра
 422   1      
 423   1      
 424   1         channel=RecieveBuf[6];
 425   1      
 426   1         if(channel>=channel_number)
 427   1         {
 428   2                      return Request_Error(FR_COMMAND_STRUCT_ERROR);//непрвильный номер канала        
 429   2         }
 430   1      
 431   1         TransferBuf[6]=channel;
 432   1      
 433   1         TransferBuf[7]=channels[channel].calibrate.cal.calibrate;
 434   1      
 435   1         sym_8_to_float.result_float=channels[channel].calibrate.cal.K;
 436   1      
 437   1              TransferBuf[11]=sym_8_to_float.result_char[0];
 438   1              TransferBuf[10]=sym_8_to_float.result_char[1];
 439   1              TransferBuf[9]=sym_8_to_float.result_char[2];
 440   1              TransferBuf[8]=sym_8_to_float.result_char[3];
 441   1      
 442   1         sym_8_to_float.result_float=channels[channel].calibrate.cal.C;
 443   1      
 444   1              TransferBuf[15]=sym_8_to_float.result_char[0];
 445   1              TransferBuf[14]=sym_8_to_float.result_char[1];
 446   1              TransferBuf[13]=sym_8_to_float.result_char[2];
 447   1              TransferBuf[12]=sym_8_to_float.result_char[3];
 448   1      
 449   1              TransferBuf[16]=CRC_Check(&TransferBuf[1],15); // подсчет кс
 450   1              return 0x11;//17        
 451   1      }
 452          //------------------------------------------------------------------------------
 453          unsigned char Channel_Set_Address_Desc(void)//установить новый адрес устройства, имя, описание, версию про
             -шивки и комментарий
 454          {
 455   1              unsigned char  desc_len=0;
 456   1              desc_len=RecieveBuf[5]-27;
 457   1      
 458   1              if(desc_len)
 459   1              {       
 460   2                      Store_Dev_Address_Desc(RecieveBuf[6],&RecieveBuf[7],&RecieveBuf[27],&RecieveBuf[32],desc_len);
 461   2                      return    Request_Error(FR_SUCCESFUL);//ошибки нет, подтверждение
 462   2              }
 463   1              else
 464   1              {
 465   2                      return Request_Error(FR_COMMAND_STRUCT_ERROR);
 466   2              }
 467   1              return 0;
 468   1      }
 469          //-----------------------------------------------------------------------------
 470          unsigned char Channel_Set_All_Default(void)//установить настройки и калибровки каналов по умолчанию
 471          {
 472   1              Channels_Set_Default();
 473   1              Calibrate_Set_Default();
C51 COMPILER V9.00   PROTO_USO                                                             06/23/2014 16:07:07 PAGE 9   

 474   1              return  Request_Error(FR_SUCCESFUL);//ошибки нет, подтверждение         
 475   1      }
 476          //-----------------------------------------------------------------------------
 477          unsigned char Request_Error(unsigned char error_code) //using 0 //      Ошибочный запрос/ответ;
 478          {
 479   1              TransferBuf[0]=0x00;TransferBuf[1]=0xD7;TransferBuf[2]=0x29;
 480   1          TransferBuf[3]=ADRESS_DEV;  // адрес узла
 481   1          TransferBuf[7]=RecieveBuf[4]; // код сбойной команды
 482   1          TransferBuf[4]=0xFF;  // код операции
 483   1      
 484   1              TransferBuf[6]=STATE_BYTE; // байт статуса узла
 485   1          TransferBuf[8]=error_code;   
 486   1          TransferBuf[5]=0x04;          // длина данных
 487   1          TransferBuf[9]=CRC_Check(TransferBuf,9);
 488   1              return 10;
 489   1      }
 490          
 491          //-----------------------------------------------------------------------------
 492          unsigned char Old_CRC_Check(unsigned char xdata *Spool_pr,unsigned char Count_pr)
 493          {
 494   1           unsigned char crc = 0x0;
 495   1               unsigned char i=0;
 496   1      
 497   1               for(i=0;i<Count_pr;i++)
 498   1               {
 499   2                      CY=0;
 500   2                      crc+=Spool_pr[i];
 501   2                      if(CY)
 502   2                      {
 503   3                              crc++;
 504   3                      }
 505   2               }
 506   1               crc=0xFF-crc;
 507   1      
 508   1           return crc;        
 509   1      }
 510          //-----------------------------------------------------------------------------
 511          unsigned char Old_Channel_Get_Data(void)
 512          {
 513   1        unsigned char channel=0;
 514   1        unsigned char len=0;
 515   1        channel=((RecieveBuf[4]>>3)&0x1F);
 516   1        if(channel<CHANNEL_NUMBER)
 517   1        {  
 518   2                 TransferBuf[0]=0x00;TransferBuf[1]=0xD7;TransferBuf[2]=0x28;
 519   2                 TransferBuf[3]=0x0;  // 
 520   2                 TransferBuf[4]=RecieveBuf[4];
 521   2                 TransferBuf[5]=((OLD_CHANNEL_GET_DATA<<5)&0x1F)|0x3;//0x63;// код операции   
 522   2      
 523   2                              switch(channels[channel].settings.set.type)
 524   2                          {
 525   3                                       case CHNL_ADC:  //аналоговый канал
 526   3                                       {
 527   4                                               switch(channels[channel].settings.set.modific)
 528   4                               {
 529   5                                                        case CHNL_ADC_FIX_16:
 530   5                                                        {
 531   6                                                                      if(channels[channel].calibrate.cal.calibrate==1)//калиброванный
 532   6                                                                      {                                                
 533   7                                                                                      TransferBuf[6]=((unsigned char*)(&channels[channel].channel_data_calibrate))[1];
 534   7                                                                              TransferBuf[7]=((unsigned char*)(&channels[channel].channel_data_calibrate))[2];
 535   7                                                                      }
C51 COMPILER V9.00   PROTO_USO                                                             06/23/2014 16:07:07 PAGE 10  

 536   6                                                                      else
 537   6                                                                      {
 538   7                                                                                      TransferBuf[6]=((unsigned char*)(&channels[channel].channel_data))[1];
 539   7                                                                              TransferBuf[7]=((unsigned char*)(&channels[channel].channel_data))[2];  
 540   7                                                                      }                                       
 541   6                                                        }
 542   5                                                        break; 
 543   5      
 544   5                                                        case CHNL_ADC_FIX_24:
 545   5                                                        {
 546   6                                                              if(channels[channel].calibrate.cal.calibrate==1)//калиброванный
 547   6                                                                      {                                                                                                 
 548   7                                                                                      TransferBuf[channel]=((unsigned char*)(&channels[channel].channel_data_calibrate))[1];
 549   7                                                                              TransferBuf[channel]=((unsigned char*)(&channels[channel].channel_data_calibrate))[2];
 550   7                                                                      }
 551   6                                                                      else
 552   6                                                                      {                                                                        
 553   7                                                                                      TransferBuf[6]=((unsigned char*)(&channels[channel].channel_data))[1];
 554   7                                                                              TransferBuf[7]=((unsigned char*)(&channels[channel].channel_data))[2];  
 555   7                                                                      }
 556   6      
 557   6                                                        }
 558   5                                                        break;
 559   5                                                }                                       
 560   4                                        }
 561   3                                        break;
 562   3      
 563   3                                      case CHNL_DOL:   //ДОЛ
 564   3                                      {
 565   4                                                switch(channels[channel].settings.set.modific)
 566   4                                            {   
 567   5                                                                case CHNL_DOL_ENC:
 568   5                                                                {
 569   6                                                                                      TransferBuf[6]=((unsigned char*)(&channels[channel].channel_data))[2];
 570   6                                                                                      TransferBuf[7]=((unsigned char*)(&channels[channel].channel_data))[3];
 571   6      //                                                                      TransferBuf[channel]=((unsigned char*)(&channels[channel].channel_data))[0];
 572   6      //                                                                              TransferBuf[channel]=((unsigned char*)(&channels[channel].channel_data))[1];
 573   6                                                                }
 574   5                                                                break; 
 575   5                                                 }
 576   4                                      }
 577   3                                      break;
 578   3      
 579   3                                       case CHNL_FREQ: //частотный
 580   3                                       { 
 581   4                                                switch(channels[channel].settings.set.modific)
 582   4                                            {   
 583   5                                                                
 584   5                                                                case CHNL_FREQ_COUNT_T:
 585   5                                                                {
 586   6                                                                                      TransferBuf[6]=((unsigned char*)(&channels[channel].channel_data))[2];
 587   6                                                                                      TransferBuf[7]=((unsigned char*)(&channels[channel].channel_data))[3];
 588   6      
 589   6                                                                }
 590   5                                                                break;
 591   5      
 592   5                                                                case CHNL_FREQ_256:
 593   5                                                                {
 594   6                                                                                      TransferBuf[6]=((unsigned char*)(&channels[channel].channel_data))[2];
 595   6                                                                                      TransferBuf[7]=((unsigned char*)(&channels[channel].channel_data))[3];
 596   6                                                                }
 597   5                                                                break; 
C51 COMPILER V9.00   PROTO_USO                                                             06/23/2014 16:07:07 PAGE 11  

 598   5                                                 }                                       
 599   4                                        }
 600   3                                        break;                 
 601   3                        }
 602   2                 
 603   2                 len=Proto_Paste_Null(TransferBuf,8);
 604   2      
 605   2                 TransferBuf[len]=Old_CRC_Check(TransferBuf,len);
 606   2                 return len+1;
 607   2         }
 608   1         return 0;    
 609   1      }
 610          //-----------------------------------------------------------------------------
 611          unsigned char Old_Channel_Get_Data_State(void)
 612          {
 613   1        unsigned char channel=0;
 614   1        unsigned char len=0;
 615   1        channel=((RecieveBuf[4]>>3)&0x1F);
 616   1        if(channel<CHANNEL_NUMBER)
 617   1        {
 618   2                 TransferBuf[0]=0x00;TransferBuf[1]=0xD7;TransferBuf[2]=0x28;
 619   2                 TransferBuf[3]=0x0;  // 
 620   2                 TransferBuf[4]=RecieveBuf[4];
 621   2                 TransferBuf[5]=((OLD_CHANNEL_GET_DATA_STATE<<5)&0x1F)|0x6;//0x66;// код операции     
 622   2      
 623   2                              switch(channels[channel].settings.set.type)
 624   2                          {
 625   3                                       case CHNL_ADC:  //аналоговый канал
 626   3                                       {
 627   4                                               switch(channels[channel].settings.set.modific)
 628   4                               {
 629   5                                                        case CHNL_ADC_FIX_16:
 630   5                                                        {
 631   6                                                                      if(channels[channel].calibrate.cal.calibrate==1)//калиброванный
 632   6                                                                      {                                                
 633   7                                                                                      TransferBuf[6]=((unsigned char*)(&channels[channel].channel_data_calibrate))[1];
 634   7                                                                              TransferBuf[7]=((unsigned char*)(&channels[channel].channel_data_calibrate))[2];
 635   7                                                                      }
 636   6                                                                      else
 637   6                                                                      {
 638   7                                                                                      TransferBuf[6]=((unsigned char*)(&channels[channel].channel_data))[1];
 639   7                                                                              TransferBuf[7]=((unsigned char*)(&channels[channel].channel_data))[2];  
 640   7                                                                      }                                       
 641   6                                                        }
 642   5                                                        break; 
 643   5      
 644   5                                                        case CHNL_ADC_FIX_24:
 645   5                                                        {
 646   6                                                              if(channels[channel].calibrate.cal.calibrate==1)//калиброванный
 647   6                                                                      {                                                                                                 
 648   7                                                                                      TransferBuf[channel]=((unsigned char*)(&channels[channel].channel_data_calibrate))[1];
 649   7                                                                              TransferBuf[channel]=((unsigned char*)(&channels[channel].channel_data_calibrate))[2];
 650   7                                                                      }
 651   6                                                                      else
 652   6                                                                      {                                                                        
 653   7                                                                                      TransferBuf[6]=((unsigned char*)(&channels[channel].channel_data))[1];
 654   7                                                                              TransferBuf[7]=((unsigned char*)(&channels[channel].channel_data))[2];  
 655   7                                                                      }
 656   6      
 657   6                                                        }
 658   5                                                        break;
 659   5                                                }
C51 COMPILER V9.00   PROTO_USO                                                             06/23/2014 16:07:07 PAGE 12  

 660   4                                                
 661   4                                                switch(channels[channel].settings.set.state_byte_1&0x7)
 662   4                                                {
 663   5                                                              case PROTO_ADC_AMP_1:
 664   5                                                              {
 665   6                                                                      TransferBuf[8]=(0x00|(OLD_PROTO_ADC_AMP_1<<1))&0xFE;     // первый байт состояния канала
 666   6                                                              }
 667   5                                                              break;
 668   5      
 669   5                                                              case PROTO_ADC_AMP_2:
 670   5                                                              {
 671   6                                                                      TransferBuf[8]=(0x00|(OLD_PROTO_ADC_AMP_2<<1))&0xFE;     // первый байт состояния канала        
 672   6                                                              }
 673   5                                                              break;
 674   5      
 675   5                                                              case PROTO_ADC_AMP_32:
 676   5                                                              {
 677   6                                                                      TransferBuf[8]=(0x00|(OLD_PROTO_ADC_AMP_32<<1))&0xFE;    // первый байт состояния канала        
 678   6                                                              }
 679   5                                                              break;
 680   5      
 681   5                                                              case PROTO_ADC_AMP_128:
 682   5                                                              {
 683   6                                                                      TransferBuf[8]=(0x00|(OLD_PROTO_ADC_AMP_128<<1))&0xFE;   // первый байт состояния канала
 684   6                                                              }
 685   5                                                              break;
 686   5      
 687   5                                                              default :
 688   5                                                              {
 689   6                                                                      TransferBuf[8]=(0x00|(OLD_PROTO_ADC_AMP_1<<1))&0xFE;     // первый байт состояния канала
 690   6                                                              }
 691   5                                                              break;
 692   5                                                }
 693   4                                                
 694   4                                                TransferBuf[9]=0x0A;   // второй байт состояния канала
 695   4      
 696   4                                        }
 697   3                                        break;
 698   3      
 699   3                                case CHNL_DOL:         //ДОЛ
 700   3                                {
 701   4                                        switch(channels[channel].settings.set.modific)
 702   4                                    {   
 703   5                                                        case CHNL_DOL_ENC:
 704   5                                                        {
 705   6                                                                      TransferBuf[6]=((unsigned char*)(&channels[channel].channel_data))[2];
 706   6                                                                      TransferBuf[7]=((unsigned char*)(&channels[channel].channel_data))[3];
 707   6      //                                                                      TransferBuf[channel]=((unsigned char*)(&channels[channel].channel_data))[0];
 708   6      //                                                                              TransferBuf[channel]=((unsigned char*)(&channels[channel].channel_data))[1];
 709   6      
 710   6                                                                      
 711   6      
 712   6                                                                      switch(channels[channel].settings.set.state_byte_1&0x7)
 713   6                                                                      {
 714   7                                                                                      case PROTO_ADC_AMP_1:
 715   7                                                                                      {
 716   8                                                                                              TransferBuf[8]=(0x40|(OLD_PROTO_ADC_AMP_1<<1))&0xFE;     // первый байт состояния канала
 717   8                                                                                      }
 718   7                                                                                      break;
 719   7                              
 720   7                                                                                      case PROTO_ADC_AMP_2:
 721   7                                                                                      {
C51 COMPILER V9.00   PROTO_USO                                                             06/23/2014 16:07:07 PAGE 13  

 722   8                                                                                              TransferBuf[8]=(0x40|(OLD_PROTO_ADC_AMP_2<<1))&0xFE;     // первый байт состояния канала        
 723   8                                                                                      }
 724   7                                                                                      break;
 725   7                              
 726   7                                                                                      case PROTO_ADC_AMP_32:
 727   7                                                                                      {
 728   8                                                                                              TransferBuf[8]=(0x40|(OLD_PROTO_ADC_AMP_32<<1))&0xFE;    // первый байт состояния канала        
 729   8                                                                                      }
 730   7                                                                                      break;
 731   7                              
 732   7                                                                                      case PROTO_ADC_AMP_128:
 733   7                                                                                      {
 734   8                                                                                              TransferBuf[8]=(0x40|(OLD_PROTO_ADC_AMP_128<<1))&0xFE;   // первый байт состояния канала
 735   8                                                                                      }
 736   7                                                                                      break;
 737   7                              
 738   7                                                                                      default :
 739   7                                                                                      {
 740   8                                                                                              TransferBuf[8]=(0x40|(OLD_PROTO_ADC_AMP_1<<1))&0xFE;
 741   8                                                                                      }
 742   7                                                                                      break;                  
 743   7                                                                      }
 744   6                                                                      TransferBuf[9]=0x00;     // второй байт состояния канала
 745   6                                                        }
 746   5                                                        break; 
 747   5                                                 }
 748   4                                      }
 749   3                                      break;
 750   3      
 751   3                                       case CHNL_FREQ: //частотный
 752   3                                       { 
 753   4                                                switch(channels[channel].settings.set.modific)
 754   4                                            {   
 755   5                                                                
 756   5                                                                case CHNL_FREQ_COUNT_T:
 757   5                                                                {
 758   6                                                                                      TransferBuf[6]=((unsigned char*)(&channels[channel].channel_data))[2];
 759   6                                                                                      TransferBuf[7]=((unsigned char*)(&channels[channel].channel_data))[3];
 760   6      
 761   6                                                                }
 762   5                                                                break;
 763   5      
 764   5                                                                case CHNL_FREQ_256:
 765   5                                                                {
 766   6                                                                                      TransferBuf[6]=((unsigned char*)(&channels[channel].channel_data))[2];
 767   6                                                                                      TransferBuf[7]=((unsigned char*)(&channels[channel].channel_data))[3];
 768   6                                                                }
 769   5                                                                break; 
 770   5                                                 }
 771   4                                                 
 772   4                                              TransferBuf[8]=0x40;     // первый байт состояния канала
 773   4                                      TransferBuf[9]=0x00;     // второй байт состояния канала
 774   4                                        }
 775   3                                        break;                 
 776   3                        }
 777   2      
 778   2                 TransferBuf[10]=0xFF;
 779   2      
 780   2                 len=Proto_Paste_Null(TransferBuf,11);
 781   2      
 782   2                 TransferBuf[len]=Old_CRC_Check(TransferBuf,len);
 783   2                 return len+1;
C51 COMPILER V9.00   PROTO_USO                                                             06/23/2014 16:07:07 PAGE 14  

 784   2         }
 785   1         return 0;
 786   1      
 787   1      }
 788          //-----------------------------------------------------------------------------
 789          unsigned char Old_Channel_Get_State(void)
 790          {
 791   1        unsigned char channel=0;
 792   1        unsigned char len=0;
 793   1        channel=((RecieveBuf[4]>>3)&0x1F);
 794   1        if(channel<CHANNEL_NUMBER)
 795   1        {
 796   2        
 797   2                 TransferBuf[0]=0x00;TransferBuf[1]=0xD7;TransferBuf[2]=0x28;
 798   2                 TransferBuf[3]=0x0;  // 
 799   2                 TransferBuf[4]=RecieveBuf[4];
 800   2                 TransferBuf[5]=((OLD_CHANNEL_GET_STATE<<5)&0x1F)|0x3;//0x43;// код операции  
 801   2      
 802   2                              switch(channels[channel].settings.set.type)
 803   2                          {
 804   3                                       case CHNL_ADC:  //аналоговый канал
 805   3                                       {                
 806   4                                                switch(channels[channel].settings.set.state_byte_1&0x7)
 807   4                                                {
 808   5                                                              case PROTO_ADC_AMP_1:
 809   5                                                              {
 810   6                                                                      TransferBuf[6]=0x00|(OLD_PROTO_ADC_AMP_1<<1);    // первый байт состояния канала
 811   6                                                              }
 812   5                                                              break;
 813   5      
 814   5                                                              case PROTO_ADC_AMP_2:
 815   5                                                              {
 816   6                                                                      TransferBuf[6]=0x00|(OLD_PROTO_ADC_AMP_2<<1);    // первый байт состояния канала        
 817   6                                                              }
 818   5                                                              break;
 819   5      
 820   5                                                              case PROTO_ADC_AMP_32:
 821   5                                                              {
 822   6                                                                      TransferBuf[6]=0x00|(OLD_PROTO_ADC_AMP_32<<1);   // первый байт состояния канала        
 823   6                                                              }
 824   5                                                              break;
 825   5      
 826   5                                                              case PROTO_ADC_AMP_128:
 827   5                                                              {
 828   6                                                                      TransferBuf[6]=0x00|(OLD_PROTO_ADC_AMP_128<<1);  // первый байт состояния канала
 829   6                                                              }
 830   5                                                              break;
 831   5      
 832   5                                                              default :
 833   5                                                              {
 834   6                                                                      TransferBuf[6]=0x00|(OLD_PROTO_ADC_AMP_1<<1);    // первый байт состояния канала
 835   6                                                              }
 836   5                                                              break;
 837   5                                                }
 838   4                                                
 839   4                                                TransferBuf[7]=0x0A;   // второй байт состояния канала
 840   4                                        }
 841   3                                        break;
 842   3      
 843   3                                      case CHNL_DOL:   //ДОЛ
 844   3                                      {
 845   4      
C51 COMPILER V9.00   PROTO_USO                                                             06/23/2014 16:07:07 PAGE 15  

 846   4                                                      switch(channels[channel].settings.set.state_byte_1&0x7)
 847   4                                                      {
 848   5                                                                      case PROTO_ADC_AMP_1:
 849   5                                                                      {
 850   6                                                                              TransferBuf[6]=0x40|(OLD_PROTO_ADC_AMP_1<<1);    // первый байт состояния канала
 851   6                                                                      }
 852   5                                                                      break;
 853   5              
 854   5                                                                      case PROTO_ADC_AMP_2:
 855   5                                                                      {
 856   6                                                                              TransferBuf[6]=0x40|(OLD_PROTO_ADC_AMP_2<<1);    // первый байт состояния канала        
 857   6                                                                      }
 858   5                                                                      break;
 859   5              
 860   5                                                                      case PROTO_ADC_AMP_32:
 861   5                                                                      {
 862   6                                                                              TransferBuf[6]=0x40|(OLD_PROTO_ADC_AMP_32<<1);   // первый байт состояния канала        
 863   6                                                                      }
 864   5                                                                      break;
 865   5              
 866   5                                                                      case PROTO_ADC_AMP_128:
 867   5                                                                      {
 868   6                                                                              TransferBuf[6]=0x40|(OLD_PROTO_ADC_AMP_128<<1);  // первый байт состояния канала
 869   6                                                                      }
 870   5                                                                      break;
 871   5              
 872   5                                                                      default :
 873   5                                                                      {
 874   6                                                                              TransferBuf[6]=0x40;     // первый байт состояния канала
 875   6                                                                      }
 876   5                                                                      break;
 877   5              
 878   5                                                      }
 879   4                                                      TransferBuf[7]=0x00;     // второй байт состояния канала
 880   4                                      }
 881   3                                      break;
 882   3      
 883   3                                       case CHNL_FREQ: //частотный
 884   3                                       { 
 885   4                                                 
 886   4                                              TransferBuf[6]=0x40;     // первый байт состояния канала
 887   4                                      TransferBuf[7]=0x00;     // второй байт состояния канала
 888   4                                       }
 889   3                                       break;          
 890   3                        }
 891   2                 
 892   2                 len=Proto_Paste_Null(TransferBuf,8);
 893   2      
 894   2                 TransferBuf[len]=Old_CRC_Check(TransferBuf,len);
 895   2                 return len+1;
 896   2         }
 897   1         return 0;    
 898   1      }
 899          //-----------------------------------------------------------------------------
 900          unsigned char Old_Reinit_Block(void)
 901          {
 902   1              return 0;       
 903   1      }
 904          //-----------------------------------------------------------------------------
 905          unsigned char Old_Channel_Set_ADC_Range(void)
 906          {
 907   1        unsigned char channel=0;
C51 COMPILER V9.00   PROTO_USO                                                             06/23/2014 16:07:07 PAGE 16  

 908   1        channel=((RecieveBuf[4]>>3)&0x1F);
 909   1        if(channel<CHANNEL_NUMBER)
 910   1        {     
 911   2              switch((RecieveBuf[6]>>1)&0x3)
 912   2              {
 913   3                              case OLD_PROTO_ADC_AMP_1:
 914   3                              {
 915   4                                   channels[channel].settings.set.state_byte_1&=0xF0;
 916   4                                       channels[channel].settings.set.state_byte_1|=PROTO_ADC_AMP_1;
 917   4                              }
 918   3                              break;
 919   3      
 920   3                              case OLD_PROTO_ADC_AMP_2:
 921   3                              {
 922   4                                       channels[channel].settings.set.state_byte_1&=0xF0;
 923   4                                       channels[channel].settings.set.state_byte_1|=PROTO_ADC_AMP_2;
 924   4                              }
 925   3                              break;
 926   3      
 927   3                              case OLD_PROTO_ADC_AMP_32:
 928   3                              {
 929   4                                       channels[channel].settings.set.state_byte_1&=0xF0;
 930   4                                       channels[channel].settings.set.state_byte_1|=PROTO_ADC_AMP_32;
 931   4                              }
 932   3                              break;
 933   3      
 934   3                              case OLD_PROTO_ADC_AMP_128:
 935   3                              {
 936   4                                   channels[channel].settings.set.state_byte_1&=0xF0;
 937   4                                       channels[channel].settings.set.state_byte_1|=PROTO_ADC_AMP_128;
 938   4                              }
 939   3                              break;
 940   3      
 941   3                              default :
 942   3                              {
 943   4                                   channels[channel].settings.set.state_byte_1&=0xF0;
 944   4                                       channels[channel].settings.set.state_byte_1|=PROTO_ADC_AMP_1;
 945   4                              }
 946   3                              break;
 947   3              }
 948   2        }
 949   1        return 0;
 950   1      }
 951          //-----------------------------------------------------------------------------
 952          unsigned char Proto_Paste_Null(unsigned char *buf,unsigned char len)//т.к. старый протокол прибавляет к дл
             -ине количество 0 после D7 то обрабатываем вне прерывания
 953          {
 954   1              volatile unsigned char xdata i=0,j=0;
 955   1      
 956   1              for(i=3;i<len;i++) //пропустим заголовок 0x00 0xD7 0x28
 957   1              {
 958   2                       if(buf[i]==0xD7)
 959   2                       {
 960   3                               for(j=(len-1);j>i;j--)
 961   3                               {
 962   4                                      buf[j+1]=buf[j];//сдвигаем элементы буфера вправо на одну позицию до D7
 963   4                               }
 964   3                               buf[i+1]=0x0;//вставляем 0x00 после 0xD7
 965   3      
 966   3                               if(protocol_type==PROTO_TYPE_OLD)
 967   3                               {
 968   4                                      buf[5]++;//длина кадра увеличилась на 1
C51 COMPILER V9.00   PROTO_USO                                                             06/23/2014 16:07:07 PAGE 17  

 969   4                               }
 970   3      
 971   3                               len++;
 972   3                               i++;//не проверяем 0 спереди
 973   3                       }
 974   2              }
 975   1              return len;
 976   1      }
 977          //-----------------------------------------------------------------------------
 978          void ProtoBufHandling(void) //using 0 //процесс обработки принятого запроса
 979          {
 980   1              switch(protocol_type)
 981   1              {
 982   2                      case PROTO_TYPE_NEW:
 983   2                      {
 984   3                               // channels[11].settings.set.state_byte_1=0x40; //восстановим байты статуса дола
 985   3                               // channels[11].settings.set.state_byte_2=0x0A;
 986   3                                switch(RecieveBuf[4])
 987   3                                {
 988   4                              //---------------------------------------
 989   4                                      case GET_DEV_INFO_REQ:
 990   4                                      {
 991   5                                              buf_len=Send_Info();    
 992   5                                      }
 993   4                                      break;
 994   4                              //---------------------------------------
 995   4                                      case NODE_FULL_INIT_REQ:
 996   4                                      {
 997   5                                              buf_len=Node_Full_Init();
 998   5                                      }
 999   4                                      break;
1000   4                              //---------------------------------------
1001   4                                      case CHANNEL_LIST_INIT_REQ:
1002   4                                      {       
1003   5                                              buf_len=Channel_List_Init();    
1004   5                                      }
1005   4                                      break;
1006   4                              //---------------------------------------
1007   4                                      case CHANNEL_GET_DATA_REQ:
1008   4                                      {
1009   5                                              buf_len=Channel_Get_Data();     
1010   5                                      }
1011   4                                      break;
1012   4                                      //-----------------------------------
1013   4                                      case CHANNEL_SET_PARAMETERS_REQ:
1014   4                                      {
1015   5                                              buf_len=Channel_Set_Parameters();
1016   5                                      }
1017   4                                      break;
1018   4                                      //-----------------------------------
1019   4                                      case CHANNEL_SET_ORDER_QUERY_REQ:
1020   4                                      {
1021   5                                              buf_len=Channel_Set_Order_Query();
1022   5                                      }
1023   4                                      break;
1024   4                              //----------------------------------------
1025   4                                      case CHANNEL_GET_DATA_ORDER_REQ:
1026   4                                      {
1027   5                                               buf_len=Channel_Get_Data_Order();
1028   5                                      }
1029   4                                      break;
1030   4                              //----------------------------------------
C51 COMPILER V9.00   PROTO_USO                                                             06/23/2014 16:07:07 PAGE 18  

1031   4                                      case CHANNEL_SET_STATE_REQ:
1032   4                                      {
1033   5                                               buf_len=Channel_Set_State();
1034   5                                      }
1035   4                                      break;
1036   4                              //----------------------------------------
1037   4                                      case CHANNEL_GET_DATA_ORDER_M2_REQ:
1038   4                                      {
1039   5                                               buf_len=Channel_Get_Data_Order_M2();
1040   5                                      }
1041   4                                      break;
1042   4                              //------------------------------------------
1043   4                                      case CHANNEL_SET_RESET_STATE_FLAGS_REQ:
1044   4                                      {
1045   5                                              buf_len=Channel_Set_Reset_State_Flags();
1046   5                                      }
1047   4                                      break;
1048   4                              //------------------------------------------
1049   4                                      case CHANNEL_ALL_GET_DATA_REQ:
1050   4                                      {
1051   5                                               buf_len=Channel_All_Get_Data();
1052   5                                      }
1053   4                                      break;
1054   4                              //------------------------------------------
1055   4                                      case CHANNEL_SET_ADDRESS_DESC:
1056   4                                      {
1057   5                                               buf_len=Channel_Set_Address_Desc();
1058   5                                      }
1059   4                                      break;
1060   4                              //------------------------------------------
1061   4                                      case CHANNEL_SET_CALIBRATE:
1062   4                                      {
1063   5                                               buf_len=Channel_Set_Calibrate();
1064   5                                      }
1065   4                                      break;
1066   4                              //------------------------------------------
1067   4                                      case CHANNEL_SET_ALL_DEFAULT:
1068   4                                      {
1069   5                                               buf_len=Channel_Set_All_Default();
1070   5                                      }
1071   4                                      break;
1072   4                              //------------------------------------------
1073   4                                      case CHANNEL_GET_CALIBRATE_REQ:
1074   4                                      {
1075   5                                               buf_len=Channel_Get_Calibrate_Value();
1076   5                                      }
1077   4                                      break;
1078   4                              //------------------------------------------
1079   4                                  default:
1080   4                                      {
1081   5                                         buf_len=Request_Error(FR_COMMAND_NOT_EXIST);
1082   5                                  }                                                              
1083   4                                }
1084   3                      }
1085   2                      break;
1086   2      
1087   2                      case PROTO_TYPE_OLD: //старый протокол
1088   2                      {
1089   3                                switch((RecieveBuf[5]>>5)&0x7)
1090   3                                {
1091   4                              //---------------------------------------
1092   4                                      case OLD_CHANNEL_REINIT_BLOCK:
C51 COMPILER V9.00   PROTO_USO                                                             06/23/2014 16:07:07 PAGE 19  

1093   4                                      {
1094   5                                              buf_len=Old_Reinit_Block();     
1095   5                                      }
1096   4                                      break;
1097   4                              //---------------------------------------
1098   4                                      case OLD_CHANNEL_SET_ADC_RANGE:
1099   4                                      {
1100   5                                              buf_len=Old_Channel_Set_ADC_Range();
1101   5                                      }
1102   4                                      break;
1103   4                              //---------------------------------------
1104   4                                      case OLD_CHANNEL_GET_STATE:
1105   4                                      {       
1106   5                                              buf_len=Old_Channel_Get_State();        
1107   5                                      }
1108   4                                      break;
1109   4                              //---------------------------------------
1110   4                                      case OLD_CHANNEL_GET_DATA:
1111   4                                      {
1112   5                                              buf_len=Old_Channel_Get_Data(); 
1113   5                                      }
1114   4                                      break;
1115   4                                      //-----------------------------------
1116   4                                      case OLD_CHANNEL_GET_DATA_STATE:
1117   4                                      {
1118   5                                              buf_len=Old_Channel_Get_Data_State();
1119   5                                      }
1120   4                                      break;
1121   4                                      //-----------------------------------
1122   4                                  default:
1123   4                                      {
1124   5                                         
1125   5                                  }                                                              
1126   4                                }     
1127   3                       }
1128   2                       break;
1129   2                       
1130   2                       case PROTO_TYPE_MODBUS_ASCII:
1131   2                       {
1132   3                                switch(MBCHAR2BIN(RecieveBuf[3])<<4| MBCHAR2BIN(RecieveBuf[4]))
1133   3                                {
1134   4                                      //---------------------------------------
1135   4                                              case MB_FUNC_READ_HOLDING_REGISTER:
1136   4                                              {
1137   5                                                      buf_len=ReadHoldingReg();       
1138   5                                              }
1139   4                                              break;
1140   4                                      //------------------------------------------
1141   4                                          default:
1142   4                                              {
1143   5                                                 buf_len=0x0;
1144   5                                          }                                                              
1145   4                                }
1146   3                       }
1147   2                       break; 
1148   2              }
1149   1      
1150   1        return;
1151   1      }
1152          //-----------------------------------------------------------------------------------
1153          PT_THREAD(ProtoProcess(struct pt *pt))
1154           {
C51 COMPILER V9.00   PROTO_USO                                                             06/23/2014 16:07:07 PAGE 20  

1155   1       static unsigned char  CRC=0x0, LRC=0x0;
1156   1        PT_BEGIN(pt);
1157   3      
1158   3        while(1) 
1159   3        {
1160   4        //----------restart------------
1161   4                      recieve_count=0x0;//??
1162   4                      REN=1;//recieve enqble
1163   4                      DE_RE=0;//линия на прием
1164   4                      ES=1;
1165   4        //-----------------------------
1166   4                // PT_WAIT_UNTIL(pt,RECIEVED); //ждем команды на старт
1167   4                 wdt_count[Proto_Proc].process_state=IDLE;
1168   4      
1169   4                 PT_YIELD_UNTIL(pt,RECIEVED); //ждем команды на старт 
1170   4                 wdt_count[Proto_Proc].process_state=RUN;
1171   4                 
1172   4      
1173   4                  RECIEVED=0;
1174   4                      
1175   4      
1176   4                      switch(protocol_type)
1177   4                      {
1178   5                              case PROTO_TYPE_NEW:
1179   5                              {
1180   6                                      if(RecieveBuf[3]!=ADRESS_DEV)//если адрес совпал          
1181   6                                      {
1182   7                                              PT_RESTART(pt);//если адрес не сошелся-перезапустим протокол                    
1183   7                                      }
1184   6      
1185   6                                      CRC=RecieveBuf[recieve_count-1];
1186   6      
1187   6                                  if(CRC_Check(&RecieveBuf,(recieve_count-CRC_LEN))!=CRC)
1188   6                                      {
1189   7                                              PT_RESTART(pt);//если CRC не сошлось-перезапустим протокол       
1190   7                                      }
1191   6                              }
1192   5                              break;
1193   5              
1194   5                              case PROTO_TYPE_OLD:
1195   5                              {
1196   6                                      CRC=RecieveBuf[recieve_count-1];
1197   6      
1198   6                                      if(Old_CRC_Check(&RecieveBuf,(recieve_count-CRC_LEN))!=CRC)
1199   6                                      {
1200   7                                              PT_RESTART(pt);//если CRC не сошлось-перезапустим протокол       
1201   7                                      }
1202   6                              }
1203   5                              break;
1204   5              
1205   5                              case PROTO_TYPE_MODBUS_ASCII:
1206   5                              {
1207   6                                      if((unsigned char)(MBCHAR2BIN(RecieveBuf[1])<<4| MBCHAR2BIN(RecieveBuf[2]))!=ADRESS_DEV)
1208   6                                      {
1209   7                                              PT_RESTART(pt); 
1210   7                                      }       
1211   6                                      
1212   6                      
1213   6                                      LRC=((MBCHAR2BIN(RecieveBuf[recieve_count-LRC_LEN])<<4)|(MBCHAR2BIN(RecieveBuf[recieve_count-LRC_LEN+1
             -])));
1214   6                                              
1215   6                                      if(LRC_Check(&RecieveBuf[1],(recieve_count-LRC_LEN-1))!=LRC)
C51 COMPILER V9.00   PROTO_USO                                                             06/23/2014 16:07:07 PAGE 21  

1216   6                                      {
1217   7                                              PT_RESTART(pt);//если LRC не сошлось-перезапустим протокол                       
1218   7                                      }
1219   6                              }
1220   5                              break;
1221   5                      }
1222   4      
1223   4              //      PT_YIELD(pt);//дадим другим процессам время
1224   4        //-----------------------------
1225   4                      ProtoBufHandling();//процедура обработки сообщения      
1226   4                      if(buf_len==0)//если в буфере пусто
1227   4                      {
1228   5                              PT_RESTART(pt);//перезапустим протокол  
1229   5                      }
1230   4                      else
1231   4                      {
1232   5                              if(protocol_type==PROTO_TYPE_NEW)
1233   5                              {
1234   6                                      buf_len=Proto_Paste_Null(TransferBuf,buf_len);
1235   6                              }
1236   5      
1237   5                              DE_RE=1; //переключаем RS485 в режим передачи
1238   5                                                              
1239   5                              REN=0;  //запрет приема-только передача
1240   5                              transf_count=0;
1241   5                              SBUF=TransferBuf[transf_count];//передача байта, остальным займется автомат
1242   5                              transf_count++;//инкрементируем счетчик переданных
1243   5                              ES=1; //включим прерывание уарт 
1244   5      
1245   5                          if(protocol_type==PROTO_TYPE_NEW)
1246   5                              {
1247   6                                      PT_DELAY(pt,50);
1248   6                              }
1249   5                              else
1250   5                              {
1251   6                                      PT_DELAY(pt,20);
1252   6                              }                       
1253   5                      }               
1254   4        //-----------------------------
1255   4        wdt_count[Proto_Proc].count++;
1256   4        }
1257   3      
1258   3       PT_END(pt);
1259   1      }
1260          //-----------------------------------------------------------------------------------------------
1261          void Store_Dev_Address_Desc(unsigned char addr,void* name,void* ver,void* desc,unsigned char desc_len)//со
             -хранить в ППЗУ новый адрес устройства, имя, версию, описание
1262          {
1263   1      //небезопасная
1264   1              
1265   1              unsigned int blocks=0;//здесь будет количество блоков, нужных дя сохранения комментария
1266   1              
1267   1              EEPROM_Write(&addr,1,DEVICE_ADDR_EEPROM);        //1 блок
1268   1              EEPROM_Write(name,DEVICE_NAME_LENGTH,DEVICE_NAME_EEPROM); //5 блоков
1269   1              memcpy(DEV_NAME,name,DEVICE_NAME_LENGTH_SYM);//копируем полученное имя в буфер
1270   1      
1271   1              EEPROM_Write(ver,DEVICE_VER_LENGTH,DEVICE_VER_EEPROM);          //2 блока
1272   1              memcpy(VERSION,ver,DEVICE_VER_LENGTH_SYM);//копируем версию в буфер
1273   1      
1274   1              blocks=desc_len>>2;//в блоке 4 байта, делим на 4
1275   1              if(desc_len&0xFC)//если есть остаток, то берем еще один блок
1276   1                      blocks++;
C51 COMPILER V9.00   PROTO_USO                                                             06/23/2014 16:07:07 PAGE 22  

1277   1              
1278   1              if(blocks>DEVICE_DESC_MAX_LENGTH) //ограничение на количество блоков для комментария
1279   1                      blocks=DEVICE_DESC_MAX_LENGTH;
1280   1      
1281   1              EEPROM_Write(desc,(unsigned int)blocks,DEVICE_DESC_EEPROM);
1282   1              dev_desc_len=desc_len;
1283   1              EEPROM_Write(&desc_len,1,DEVICE_DESC_LEN_EEPROM);//сохраним длину комментария
1284   1              
1285   1              memcpy(NOTICE,desc,desc_len);//копируем описание в буфер
1286   1              
1287   1              return;
1288   1      }
1289          //-----------------------------------------------------------------------------------------------
1290          void Restore_Dev_Address_Desc(void)//восстановить из ппзу адрес и информацию об устройстве
1291          {
1292   1              unsigned int blocks=0;//здесь будет количество блоков, нужных дя сохранения комментария
1293   1              
1294   1              EEPROM_Read(&ADRESS_DEV,1,DEVICE_ADDR_EEPROM);   //1 блок восстанавливаем адрес из ППЗУ
1295   1      
1296   1              if(ADRESS_DEV<1 || ADRESS_DEV>15)
1297   1                      ADRESS_DEV=1; 
1298   1      
1299   1              EEPROM_Read(DEV_NAME,DEVICE_NAME_LENGTH,DEVICE_NAME_EEPROM); //5 блоков
1300   1          EEPROM_Read(VERSION,DEVICE_VER_LENGTH,DEVICE_VER_EEPROM);
1301   1      
1302   1              EEPROM_Read(&dev_desc_len,1,DEVICE_DESC_LEN_EEPROM);//длина описания устройства в байтах
1303   1      
1304   1              if(dev_desc_len>DEVICE_DESC_MAX_LENGTH_SYM)
1305   1                      dev_desc_len=DEVICE_DESC_MAX_LENGTH_SYM;
1306   1      
1307   1              blocks=dev_desc_len>>2;//в блоке 4 байта, делим на 4
1308   1              if(dev_desc_len&0xFC)//если есть остаток, то берем еще один блок
1309   1                      blocks++;
1310   1      
1311   1              if(blocks>DEVICE_DESC_MAX_LENGTH) //ограничение на количество блоков для комментария     ???
1312   1                      blocks=DEVICE_DESC_MAX_LENGTH;
1313   1      
1314   1              EEPROM_Read(NOTICE,(unsigned int)blocks,DEVICE_DESC_EEPROM);
1315   1              return;
1316   1      }
1317          //-----------------------------------------------------------------------------------------------
1318           PT_THREAD(RingBufHandling(struct pt *pt))//обработка кольцевого буфера
1319           {
1320   1              static unsigned char temp_count=0;//временные копии конца  и счетчика буфера
1321   1              static unsigned char temp_tail=0;
1322   1      
1323   1              static unsigned char i=0;
1324   1              static unsigned char CUT_OUT_NULL=0;//флаг-вырезаем 0 после 0xD7
1325   1      
1326   1        PT_BEGIN(pt);
1327   3      
1328   3        CUT_OUT_NULL=0;
1329   3      
1330   3        while(1) 
1331   3        {
1332   4                      wdt_count[RingBufHandling_Proc].process_state=IDLE;
1333   4                      PT_YIELD_UNTIL(pt,(rngbuf.count>0x0));//в буфере есть данные
1334   4                      wdt_count[RingBufHandling_Proc].process_state=RUN;
1335   4              
1336   4      
1337   4                      ES=0;
1338   4                      temp_count=rngbuf.count;
C51 COMPILER V9.00   PROTO_USO                                                             06/23/2014 16:07:07 PAGE 23  

1339   4                      rngbuf.count=0x0;
1340   4                      temp_tail =rngbuf.tail;
1341   4                      ES=1;
1342   4      
1343   4                      for(i=(temp_tail-temp_count);i!=temp_tail;i++)//поиск стартовой последовательности
1344   4                      {
1345   5                              switch(rngbuf.buf[i])
1346   5                              {
1347   6                                              case (char)(0xD7):
1348   6                                              {
1349   7                                                      RecieveBuf[recieve_count]=rngbuf.buf[i];
1350   7                                                      recieve_count++;
1351   7                                                      CUT_OUT_NULL=1;          
1352   7                                              }
1353   6                                              break;
1354   6                      
1355   6                                              case (char)(0x29):
1356   6                                              {
1357   7                                                      if(CUT_OUT_NULL==1)
1358   7                                                      {
1359   8                                                              RecieveBuf[0]=0x0;
1360   8                                                              RecieveBuf[1]=0xD7;
1361   8                                                              RecieveBuf[2]=0x29;
1362   8                                                              recieve_count=0x3;
1363   8                                                              protocol_type=PROTO_TYPE_NEW;                   
1364   8                                                      }
1365   7                                                      else
1366   7                                                      {
1367   8                                                              RecieveBuf[recieve_count]=rngbuf.buf[i];
1368   8                                                              recieve_count++;        
1369   8                                                      }
1370   7                                                      CUT_OUT_NULL=0;
1371   7                                              }
1372   6                                              break;
1373   6                      
1374   6                                              case (char)(0x28):
1375   6                                              {
1376   7                                                      if(CUT_OUT_NULL==1)
1377   7                                                      {
1378   8                                                              RecieveBuf[0]=0x0;
1379   8                                                              RecieveBuf[1]=0xD7;
1380   8                                                              RecieveBuf[2]=0x28;
1381   8                                                              recieve_count=0x3;
1382   8                                                              protocol_type=PROTO_TYPE_OLD;                   
1383   8                                                      }
1384   7                                                      else
1385   7                                                      {
1386   8                                                              RecieveBuf[recieve_count]=rngbuf.buf[i];
1387   8                                                              recieve_count++;        
1388   8                                                      }
1389   7                                                      CUT_OUT_NULL=0;
1390   7                                              }
1391   6                                              break;
1392   6                      
1393   6                                              case (char)(0x0):
1394   6                                              {
1395   7                                                      if(CUT_OUT_NULL==1)       //если после 0xD7-пропускаем
1396   7                                                      {
1397   8                                                              CUT_OUT_NULL=0;         
1398   8                                                      }
1399   7                                                      else
1400   7                                                      {
C51 COMPILER V9.00   PROTO_USO                                                             06/23/2014 16:07:07 PAGE 24  

1401   8                                                              RecieveBuf[recieve_count]=rngbuf.buf[i];
1402   8                                                              recieve_count++;        
1403   8                                                      }
1404   7                                              }
1405   6                                              break;
1406   6                      
1407   6                                              //---------MD ASCII------
1408   6                                              case  0x3A:      //":"
1409   6                                              {
1410   7                                                      
1411   7                                                      RecieveBuf[recieve_count]=rngbuf.buf[i];
1412   7                                                      recieve_count++;
1413   7      
1414   7                                                      if(recieve_count==0x0)
1415   7                                                      {
1416   8                                                              protocol_type=PROTO_TYPE_MODBUS_ASCII;
1417   8                                                      }                                                                
1418   7                                              }
1419   6                                              break;
1420   6                      
1421   6                                              case 0xA:        //"LF"
1422   6                                              {
1423   7                                                      RECIEVED=1;//буфер принят
1424   7                                                      ES=0;
1425   7                                                      REN=0;  //recieve disable 
1426   7                                              }
1427   6                                              break;
1428   6                      
1429   6                                              case 0xD:        //"CR"
1430   6                                              {
1431   7                                                      //
1432   7                                              }
1433   6                                              break;
1434   6                                              //-----------------------
1435   6                      
1436   6                                              default :
1437   6                                              {
1438   7                                                      RecieveBuf[recieve_count]=rngbuf.buf[i];
1439   7                                                      recieve_count++;
1440   7                                                      CUT_OUT_NULL=0;         
1441   7                                              }
1442   6                                      }
1443   5                      
1444   5                                 if(recieve_count>6)
1445   5                                 {
1446   6                                                if(recieve_count==6+frame_len)          // принимаем указанное в frame_len число байт данные, 6 значит 
             -что обмен идет с компом, надо ставаить 5 чтобы обмениваться с устройствами
1447   6                                                {
1448   7                                                              RECIEVED=1;//буфер принят
1449   7                                                              ES=0;
1450   7                                                              REN=0;  //recieve disable -запрещаем принимать в буфер  
1451   7                                                              CUT_OUT_NULL=0;                                                 
1452   7                                                }      
1453   6                                                
1454   6                                                //----------------------обрабатываем возможные ошибки длины кадра-------------
1455   6                                            if(recieve_count>MAX_LENGTH_REC_BUF)      //если посылка слишком длинная
1456   6                                                {
1457   7                                                              PT_RESTART(&pt_proto);  //внепроцессный рестарт
1458   7                                                }  
1459   6                                 }
1460   5                                 else
1461   5                                 {
C51 COMPILER V9.00   PROTO_USO                                                             06/23/2014 16:07:07 PAGE 25  

1462   6                                                 if(recieve_count==6)
1463   6                                                 {     
1464   7                                                      
1465   7                                                              frame_len=RecieveBuf[recieve_count-1];  // получаем длину данных после заголовка
1466   7                                                              if(protocol_type==PROTO_TYPE_OLD)
1467   7                                                              {
1468   8                                                                      frame_len&=0x1F;//в старом протоколе только 5 младших бит -длина оставшейся части       
1469   8                                                              }                                        
1470   7                                                 }                    
1471   6                                 }
1472   5                                                                                                                                      
1473   5                      }
1474   4                      wdt_count[RingBufHandling_Proc].count++;
1475   4                      PT_YIELD(pt);//дадим другим процессам время     
1476   4        }
1477   3      
1478   3        PT_END(pt);
1479   1       }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   8265    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    946       1
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      1       2
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
