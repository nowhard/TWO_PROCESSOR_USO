C51 COMPILER V9.00   PROTO_USO                                                             06/23/2014 10:13:56 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE PROTO_USO
OBJECT MODULE PLACED IN proto_uso.obj
COMPILER INVOKED BY: C:\Program Files\Keil\C51\BIN\C51.EXE proto_uso\proto_uso.c LARGE OPTIMIZE(6,SPEED) BROWSE ORDER NO
                    -AREGS DEBUG OBJECTEXTEND PRINT(.\proto_uso.lst) OBJECT(proto_uso.obj)

line level    source

   1          #include "proto_uso.h"
   2          #include "calibrate\calibrate.h"
   3          #include "i2c.h"
   4          #include <intrins.h>
   5          #include "crc_table.h"
   6          #include "channels.h"
   7          #include "watchdog.h"
   8          #include "modbus\modbus_ascii.h"
   9          //-----------------------------------------------------------------------------------
  10          
  11          sbit DE_RE=P3^5;
  12          
  13          //-----------------------------------------------------------------------------------
  14          volatile unsigned char xdata DEV_NAME[DEVICE_NAME_LENGTH_SYM] ="<<uUSO_2>>"; //имя устройства
  15          volatile unsigned char xdata NOTICE[DEVICE_DESC_MAX_LENGTH_SYM]="<-- GEOSPHERA_2012 -->";//примечание   
  16          volatile unsigned char xdata VERSION[DEVICE_VER_LENGTH_SYM] ="\x30\x30\x30\x30\x31";    // версия программы П
             -ЗУ        не больше 5 байт
  17          
  18          volatile unsigned char xdata ADRESS_DEV=0x1;
  19          
  20          volatile unsigned char xdata dev_desc_len=20;//длина описания устройства
  21          //--------------------------------global variable------------------------------------
  22          volatile unsigned char idata    RECIEVED=0;//принято
  23          volatile unsigned char xdata    recieve_count;//счетчик приемного буфера
  24          volatile unsigned char xdata    transf_count;//счетчик передаваемых байтов         
  25          volatile unsigned char xdata    buf_len;//длина передаваемого буфера
  26          
  27          //------------------------флаги ошибок--------------------------------
  28          volatile unsigned char idata  CUT_OUT_NULL;//флаг-вырезаем 0 после 0xD7
  29          volatile unsigned char xdata frame_len=0;//длина кадра, которую вытаскиваем из шестого байта кадра
  30          //--------------------------------------------------------------------
  31          volatile unsigned char xdata  RecieveBuf[MAX_LENGTH_REC_BUF]={0} ; //буфер принимаемых данных
  32          //volatile unsigned char xdata                  *TransferBuf;
  33          volatile unsigned char xdata  TransferBuf[MAX_LENGTH_TR_BUF]={0} ; //буфер передаваемых данных
  34          //--------------------------------------------------------------------
  35          volatile unsigned char xdata  STATE_BYTE=0xC0;//байт состояния устройства
  36          volatile unsigned char idata symbol=0xFF;//принятый символ
  37          
  38          volatile unsigned char xdata protocol_type=PROTO_TYPE_NEW;//тип протокола
  39          
  40          volatile struct pt pt_proto, pt_buf_handle;
  41          
  42          struct RingBuf rngbuf;
  43          //-----------------------------------------------------------------------------------
  44          union //объединение для конвертирования char->long
  45          {
  46                  float result_float;
  47                  unsigned char result_char[4];
  48          }
  49          sym_8_to_float;
  50          
  51          extern unsigned char idata i2c_buffer[6];
  52          extern unsigned char channel_number;//количество каналов
  53          
C51 COMPILER V9.00   PROTO_USO                                                             06/23/2014 10:13:56 PAGE 2   

  54          //-----------------------------------------------------------------------------------
  55          //#pragma OT(0,Speed)
  56          void UART_ISR(void) interrupt 4 //using 1
  57          {       
  58   1              EA=0;   //запрет прерывания
  59   1              
  60   1              if(RI)
  61   1              {
  62   2                      RI=0; 
  63   2                      rngbuf.buf[rngbuf.tail]=SBUF;
  64   2                      rngbuf.tail++;
  65   2                      rngbuf.count++;
  66   2                      //if(rngbuf.tail==RING_BUF_SIZE) rngbuf.tail=0x0;
  67   2      
  68   2      //----------------------обрабатываем возможные ошибки длины кадра-------------
  69   2      //              if(recieve_count>MAX_LENGTH_REC_BUF)    //если посылка слишком длинная
  70   2      //              {
  71   2      //                      PT_RESTART_OUT(pt_proto);  //внепроцессный рестарт
  72   2      //                      return;
  73   2      //              } 
  74   2      //
  75   2      //
  76   2      //              symbol=SBUF;
  77   2      //
  78   2      //              wdt_count[Proto_Proc].process_state=RUN;
  79   2      //
  80   2      //
  81   2      //              if((recieve_count==0x0)&&(symbol==':'))
  82   2      //              {
  83   2      //                      protocol_type=PROTO_TYPE_MODBUS_ASCII;                  
  84   2      //              }
  85   2      //
  86   2      //              switch(symbol)
  87   2      //              {
  88   2      //                      case (char)(0xD7):
  89   2      //                      {
  90   2      //                              RecieveBuf[recieve_count]=symbol;
  91   2      //                              recieve_count++;
  92   2      //                              CUT_OUT_NULL=1;          
  93   2      //                      }
  94   2      //                      break;
  95   2      //
  96   2      //                      case (char)(0x29):
  97   2      //                      {
  98   2      //                              if(CUT_OUT_NULL==1)
  99   2      //                              {
 100   2      //                                      RecieveBuf[0]=0x0;
 101   2      //                                      RecieveBuf[1]=0xD7;
 102   2      //                                      RecieveBuf[2]=0x29;
 103   2      //                                      recieve_count=0x3;
 104   2      //                                      protocol_type=PROTO_TYPE_NEW;                   
 105   2      //                              }
 106   2      //                              else
 107   2      //                              {
 108   2      //                                      RecieveBuf[recieve_count]=symbol;
 109   2      //                                      recieve_count++;        
 110   2      //                              }
 111   2      //                              CUT_OUT_NULL=0;
 112   2      //                      }
 113   2      //                      break;
 114   2      //
 115   2      //                      case (char)(0x28):
C51 COMPILER V9.00   PROTO_USO                                                             06/23/2014 10:13:56 PAGE 3   

 116   2      //                      {
 117   2      //                              if(CUT_OUT_NULL==1)
 118   2      //                              {
 119   2      //                                      RecieveBuf[0]=0x0;
 120   2      //                                      RecieveBuf[1]=0xD7;
 121   2      //                                      RecieveBuf[2]=0x28;
 122   2      //                                      recieve_count=0x3;
 123   2      //                                      protocol_type=PROTO_TYPE_OLD;                   
 124   2      //                              }
 125   2      //                              else
 126   2      //                              {
 127   2      //                                      RecieveBuf[recieve_count]=symbol;
 128   2      //                                      recieve_count++;        
 129   2      //                              }
 130   2      //                              CUT_OUT_NULL=0;
 131   2      //                      }
 132   2      //                      break;
 133   2      //
 134   2      //                      case (char)(0x0):
 135   2      //                      {
 136   2      //                              if(CUT_OUT_NULL==1)       //если после 0xD7-пропускаем
 137   2      //                              {
 138   2      //                                      CUT_OUT_NULL=0;         
 139   2      //                              }
 140   2      //                              else
 141   2      //                              {
 142   2      //                                      RecieveBuf[recieve_count]=symbol;
 143   2      //                                      recieve_count++;        
 144   2      //                              }
 145   2      //                      }
 146   2      //                      break;
 147   2      //
 148   2      //                      //---------MD ASCII------
 149   2      //                      case  0x3A:      //":"
 150   2      //                      {
 151   2      //                              RecieveBuf[recieve_count]=symbol;
 152   2      //                              recieve_count++;
 153   2      //                              protocol_type=PROTO_TYPE_MODBUS_ASCII;                                                           
 154   2      //                      }
 155   2      //                      break;
 156   2      //
 157   2      //                      case 0xA:        //"LF"
 158   2      //                      {
 159   2      //                              ES=0;
 160   2      //                              REN=0;  //recieve disable 
 161   2      //                      }
 162   2      //                      break;
 163   2      //
 164   2      //                      case 0xD:        //"CR"
 165   2      //                      {
 166   2      //                              //
 167   2      //                      }
 168   2      //                      break;
 169   2      //                      //-----------------------
 170   2      //
 171   2      //                      default :
 172   2      //                      {
 173   2      //                              RecieveBuf[recieve_count]=symbol;
 174   2      //                              recieve_count++;
 175   2      //                              CUT_OUT_NULL=0;
 176   2      //                              
 177   2      //                      }
C51 COMPILER V9.00   PROTO_USO                                                             06/23/2014 10:13:56 PAGE 4   

 178   2      //              }
 179   2      //
 180   2      //         if(recieve_count>6)
 181   2      //         {
 182   2      //                        if(recieve_count==6+frame_len)          // принимаем указанное в frame_len число байт данные, 6 значит 
             -что обмен идет с компом, надо ставаить 5 чтобы обмениваться с устройствами
 183   2      //                        {
 184   2      //                                      RECIEVED=1;//буфер принят
 185   2      //                                      ES=0;
 186   2      //                                      REN=0;  //recieve disable -запрещаем принимать в буфер  
 187   2      //                                      CUT_OUT_NULL=0;                                                 
 188   2      //                        }       
 189   2      //         }
 190   2      //         else
 191   2      //         {
 192   2      //                         if(recieve_count==6)
 193   2      //                         {     
 194   2      //                              
 195   2      //                                      frame_len=RecieveBuf[recieve_count-1];  // получаем длину данных после заголовка
 196   2      //                                      if(protocol_type==PROTO_TYPE_OLD)
 197   2      //                                      {
 198   2      //                                              frame_len&=0x1F;//в старом протоколе только 5 младших бит -длина оставшейся части       
 199   2      //                                      }                                        
 200   2      //                         }                    
 201   2      //         }                                                                            
 202   2              }
 203   1      //----------------------------передача----------------------------------------------------------------
 204   1              if(TI)
 205   1              {
 206   2                      TI=0;
 207   2                       
 208   2                      if(transf_count<buf_len)
 209   2                      {
 210   3                              if((transf_count<3)||(protocol_type==PROTO_TYPE_OLD))//передаем заголовок или все подряд, если старый п
             -ротокол
 211   3                              {
 212   4                                      SBUF=TransferBuf[transf_count];                 
 213   4                                      transf_count++;
 214   4                              }
 215   3                              else   //тело...   подставляем 0 после 0xD7
 216   3                              {
 217   4                                              if(CUT_OUT_NULL==0)
 218   4                                              {
 219   5                                                      if(TransferBuf[transf_count]==(unsigned char)0xD7)//проверим, это  ,0xD7 или другое
 220   5                                                      {                       
 221   6                                                              CUT_OUT_NULL=0x1;       
 222   6                                                      }
 223   5                                                      SBUF=TransferBuf[transf_count];                 
 224   5                                                      transf_count++;
 225   5                                              }
 226   4                                              else
 227   4                                              {
 228   5                                                      SBUF=(unsigned char)0x0;
 229   5                                                      CUT_OUT_NULL=0;         
 230   5                                              }       
 231   4                              }       
 232   3                      }
 233   2                      else
 234   2                      {
 235   3                              transf_count=0;         //обнуляем счетчик
 236   3                              CUT_OUT_NULL=0;
 237   3                              PT_RESTART_OUT(pt_proto);  //внепроцессный рестарт                      
C51 COMPILER V9.00   PROTO_USO                                                             06/23/2014 10:13:56 PAGE 5   

 238   3                      }                                          
 239   2              }                       
 240   1              EA=1;
 241   1              return;
 242   1      }
 243          //------------------------------------------------------------------------------
 244          //#pragma OT(6,Speed)
 245          void Protocol_Init(void) //using 0
 246          {
 247   1              TI=0;
 248   1              RI=0;
 249   1              
 250   1      //      TransferBuf=&RecieveBuf[0];      //буфер ответа =буфер запроса
 251   1      
 252   1              Restore_Dev_Address_Desc();
 253   1      
 254   1              rngbuf.tail=0;
 255   1              rngbuf.head=0;
 256   1              rngbuf.count=0;
 257   1      
 258   1              recieve_count=0x0;//счетчик буфера приема
 259   1              transf_count=0x0;//счетчик передаваемых байтов
 260   1              buf_len=0x0;//длина передаваемого буфера
 261   1              DE_RE=0;//линия на прием
 262   1              CUT_OUT_NULL=0;
 263   1              STATE_BYTE=0xC0;
 264   1              PT_INIT(&pt_proto);
 265   1              PT_INIT(&pt_buf_handle);
 266   1              return;
 267   1      }
 268          //-----------------------------------------------------------------------------
 269          unsigned char Send_Info(void) //using 0    //посылка информации об устройстве
 270          {
 271   1                  unsigned char    i=0;
 272   1                                                                                      
 273   1                 //заголовок кадра---
 274   1                 TransferBuf[0]=0x00;
 275   1                 TransferBuf[1]=0xD7;
 276   1                 TransferBuf[2]=0x29;
 277   1                 //------------------
 278   1                 TransferBuf[3]=ADRESS_DEV;  // адрес узла
 279   1                 TransferBuf[4]=GET_DEV_INFO_RESP;  // код операции
 280   1                 TransferBuf[6]=STATE_BYTE;
 281   1      
 282   1                 for(i=0;i<20;i++)
 283   1                 {                              // записываем наименование изделия
 284   2                                 if(i<DEVICE_NAME_LENGTH_SYM)
 285   2                                 {
 286   3                                      TransferBuf[i+7]=DEV_NAME[i];
 287   3                                 }
 288   2                                 else
 289   2                                 {
 290   3                                              TransferBuf[i+7]=0x00;
 291   3                                 }
 292   2                      }
 293   1              
 294   1                 for(i=0;i<5;i++)                   // записываем версию ПЗУ
 295   1                 {
 296   2                     if(i<DEVICE_VER_LENGTH_SYM)
 297   2                         {
 298   3                               TransferBuf[i+27]=VERSION[i];
 299   3                         }
C51 COMPILER V9.00   PROTO_USO                                                             06/23/2014 10:13:56 PAGE 6   

 300   2                 }
 301   1      
 302   1                 TransferBuf[32]=channel_number;                 // количество каналов
 303   1      
 304   1                 for(i=0;i<channel_number;i++)                                   // данные по каналу
 305   1             {
 306   2                              TransferBuf[i*2+33]=((channels[i].settings.set.type)<<4)|channels[i].settings.set.modific; // байт да
             -нных
 307   2                              TransferBuf[i*2+33+1]=0x00;                                                     // резерв байт
 308   2                 }    
 309   1                 for(i=0;i<dev_desc_len;i++)                                  // записываем примечание
 310   1                 {
 311   2                               TransferBuf[i+33+channel_number*2]=NOTICE[i];
 312   2                 }
 313   1                              
 314   1                 TransferBuf[5]=28+channel_number*2+dev_desc_len;                     // подсчет длины данных 
 315   1                 TransferBuf[33+channel_number*2+dev_desc_len]=CRC_Check(&TransferBuf[1],32+channel_number*2+dev_desc_l
             -en); // подсчет контрольной суммы
 316   1      
 317   1              return (34+channel_number*2+dev_desc_len);
 318   1      }
 319          //-----------------------------------------------------------------------------
 320          unsigned char Node_Full_Init(void) //using 0 //полная инициализация узла
 321          {
 322   1              return 0;
 323   1      }
 324          //-----------------------------------------------------------------------------
 325          unsigned char Channel_List_Init(void) //using 0 //Инициализация списка каналов узла (без потери данных);
 326          {
 327   1              return 0;
 328   1      }
 329          //-----------------------------------------------------------------------------
 330          unsigned char Channel_Get_Data(void) //using 0 //Выдать данные по каналам, согласно абсолютной нумерации;
 331          {
 332   1              return 0;
 333   1      }
 334          //-----------------------------------------------------------------------------
 335          unsigned char  Channel_Set_Parameters(void) //using 0 //Установить параметры по каналам, согласно абсолютн
             -ой нумерации;
 336          {
 337   1             unsigned char  index=0, store_data=0;//i=0;
 338   1               
 339   1                 while(index<RecieveBuf[5]-1)                            // данные по каналам
 340   1                    {
 341   2                                      if(RecieveBuf[6+index]<channel_number)
 342   2                                  {
 343   3                                              switch((RecieveBuf[6+index+1]>>4)&0xF)
 344   3                                              {
 345   4                                                              case CHNL_ADC://АЦП
 346   4                                                              {
 347   5                                                                      if((channels[RecieveBuf[6+index]].settings.set.modific!=RecieveBuf[6+index+1])||(channels[RecieveB
             -uf[6+index]].settings.set.state_byte_1!=RecieveBuf[6+index+2]) || (channels[RecieveBuf[6+index]].settings.set.state_byte
             -_2!=RecieveBuf[6+index+3]))
 348   5                                                                      {  
 349   6                                                                              channels[RecieveBuf[6+index]].settings.set.state_byte_1=RecieveBuf[6+index+2];
 350   6                                                                              channels[RecieveBuf[6+index]].settings.set.state_byte_2=RecieveBuf[6+index+3];
 351   6                                                                              channels[RecieveBuf[6+index]].settings.set.modific         =RecieveBuf[6+index+1]&0xF;
 352   6                                                                              store_data=1;
 353   6                                                                              
 354   6                                                                      }
 355   5                                                                      index++;
 356   5                                                              }
C51 COMPILER V9.00   PROTO_USO                                                             06/23/2014 10:13:56 PAGE 7   

 357   4                                                              break;
 358   4      
 359   4      
 360   4                                                              default :
 361   4                                                              {
 362   5                                                                      _nop_();
 363   5                                                              }                       
 364   4                                              }
 365   3                                              index=index+3;
 366   3                                      }
 367   2                                      else
 368   2                                      {
 369   3                                              return Request_Error(FR_UNATTENDED_CHANNEL);
 370   3                                      }
 371   2                        }
 372   1                 if(store_data)
 373   1                 {
 374   2                              Store_Channels_Data();  //сохраним настройки каналов в ППЗУ
 375   2                 }
 376   1      
 377   1                 return Request_Error(FR_SUCCESFUL);
 378   1      }
 379          //-----------------------------------------------------------------------------
 380          unsigned char Channel_Set_Order_Query(void) //using 0 //Задать последовательность опроса;
 381          {
 382   1              return 0;
 383   1      }
 384          //-----------------------------------------------------------------------------
 385          unsigned char Channel_Get_Data_Order(void) //using 0 //Выдать данные по каналам, согласно последовательнос
             -ти опроса;
 386          {
 387   1              return 0;
 388   1      }
 389          //-----------------------------------------------------------------------------
 390          unsigned char Channel_Set_State(void) //using 0 //Установить состояния по каналам, согласно абсолютной нум
             -ерации;
 391          {
 392   1              return 0;
 393   1      }
 394          //-----------------------------------------------------------------------------
 395          unsigned char  Channel_Get_Data_Order_M2(void) //using 0 //Выдать данные по каналам, согласно последовател
             -ьности опроса;
 396          {
 397   1              return 0;
 398   1      }
 399          //-----------------------------------------------------------------------------
 400          unsigned char Channel_Set_Reset_State_Flags(void) //using 0 //  Установка/Сброс флагов состояния 
 401          {
 402   1              STATE_BYTE=0x40;
 403   1              i2c_buffer[0]=0x12;//сбросим флаг инициализации ведомого
 404   1              ChannelsInit();
 405   1              return  Request_Error(FR_SUCCESFUL);//ошибки нет, подтверждение
 406   1      }
 407          //-----------------------------------------------------------------------------
 408          #pragma OT(9,Speed)
 409          unsigned char Channel_All_Get_Data(void) //using 0 //Выдать информацию по всем каналам узла (расширенный р
             -ежим);
 410          {
 411   1         unsigned char data index=0,i=0;
 412   1      
 413   1      
 414   1         TransferBuf[0]=0x00;TransferBuf[1]=0xD7;TransferBuf[2]=0x29;
C51 COMPILER V9.00   PROTO_USO                                                             06/23/2014 10:13:56 PAGE 8   

 415   1         TransferBuf[3]=ADRESS_DEV;  // адрес узла
 416   1         TransferBuf[4]=CHANNEL_ALL_GET_DATA_RESP;  // код операции
 417   1         TransferBuf[6]=STATE_BYTE;
 418   1      
 419   1         index=7;//длина заголовка
 420   1       
 421   1          for(i=0;i<channel_number;i++)                                  // данные по каналам
 422   1          {
 423   2                        TransferBuf[index++]=i;
 424   2                        TransferBuf[index++]=((channels[i].settings.set.type)<<4)|channels[i].settings.set.modific; // тип и м
             -одификация канала
 425   2                        switch(channels[i].settings.set.type)
 426   2                          {
 427   3                                       case CHNL_ADC:  //аналоговый канал
 428   3                                       {
 429   4                                               switch(channels[i].settings.set.modific)
 430   4                               {
 431   5                                                        case CHNL_ADC_FIX_16:
 432   5                                                        {
 433   6                                                                      if(channels[i].calibrate.cal.calibrate==1)//калиброванный
 434   6                                                                      {                                                
 435   7                                                                                      TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data_calibrate))[2];
 436   7                                                                              TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data_calibrate))[1];
 437   7                                                                      }
 438   6                                                                      else
 439   6                                                                      {
 440   7                                                                                      TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data))[2];
 441   7                                                                              TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data))[1];  
 442   7                                                                      } 
 443   6      
 444   6                                                                        
 445   6                                                                       TransferBuf[index++]=channels[i].settings.set.state_byte_1;     // первый байт состояния канала
 446   6                                               TransferBuf[index++]=channels[i].settings.set.state_byte_2;     // второй байт сос
             -тояния канала
 447   6                                                        }
 448   5                                                        break; 
 449   5      
 450   5                                                        case CHNL_ADC_FIX_24:
 451   5                                                        {
 452   6                                                              if(channels[i].calibrate.cal.calibrate==1)//калиброванный
 453   6                                                                      {                                                                                                 
 454   7                                                                                      TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data_calibrate))[3];
 455   7                                                                                      TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data_calibrate))[2];
 456   7                                                                              TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data_calibrate))[1];
 457   7                                                                      }
 458   6                                                                      else
 459   6                                                                      {                                                                        
 460   7                                                                                      TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data))[3];
 461   7                                                                                      TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data))[2];
 462   7                                                                              TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data))[1];  
 463   7                                                                      } 
 464   6                        
 465   6                                                                        TransferBuf[index++]=channels[i].settings.set.state_byte_1;    // первый байт состояния канала
 466   6                                                TransferBuf[index++]=channels[i].settings.set.state_byte_2;    // второй байт со
             -стояния канала
 467   6                                                        }
 468   5                                                        break;
 469   5                                                }
 470   4                                        }
 471   3                                        break;
 472   3      
 473   3                                      case CHNL_DOL:   //ДОЛ
C51 COMPILER V9.00   PROTO_USO                                                             06/23/2014 10:13:56 PAGE 9   

 474   3                                      {
 475   4                                                switch(channels[i].settings.set.modific)
 476   4                                            {   
 477   5                                                                case CHNL_DOL_ENC:
 478   5                                                                {
 479   6                                                                                      TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data))[3];
 480   6                                                                                      TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data))[2];
 481   6                                                                              TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data))[1];
 482   6                                                                                      TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data))[0];
 483   6                                                                                  TransferBuf[index++]=channels[i].settings.set.state_byte_1;  // первый байт состояния канала
 484   6                                                                }
 485   5                                                                break; 
 486   5                                                 }
 487   4                                      }
 488   3                                      break;
 489   3      
 490   3                                       case CHNL_FREQ: //частотный
 491   3                                       { 
 492   4                                                switch(channels[i].settings.set.modific)
 493   4                                            {   
 494   5                                                                
 495   5                                                                case CHNL_FREQ_COUNT_T:
 496   5                                                                {
 497   6                                                                                      TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data))[3];
 498   6                                                                                      TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data))[2];
 499   6                                                                                TransferBuf[index++]=channels[i].settings.set.state_byte_1;    // первый байт состояния канала
 500   6                                                                }
 501   5                                                                break;
 502   5      
 503   5                                                                case CHNL_FREQ_256:
 504   5                                                                {
 505   6                                                                                      TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data))[3];
 506   6                                                                                      TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data))[2];
 507   6                                                                                  TransferBuf[index++]=channels[i].settings.set.state_byte_1;  // первый байт состояния канала
 508   6                                                                }
 509   5                                                                break; 
 510   5                                                 }
 511   4                                        }
 512   3                                        break;                 
 513   3                        }
 514   2                 }
 515   1      
 516   1                TransferBuf[5]=index+2-7;                                              // подсчет длины данных двойка это 1(байт статуса)+1(контрольная сумма
             -)
 517   1                TransferBuf[index]=CRC_Check(&TransferBuf[1],(unsigned int)(index)-1); // подсчет кс
 518   1                return (unsigned char)(index+1);
 519   1      }
 520          //-----------------------------------------------------------------------------
 521          #pragma OT(0,Speed)
 522          unsigned char Channel_Set_Calibrate(void)//установить верхнюю или нижнюю точку калибровки
 523          {
 524   1      
 525   1              float K,C;      
 526   1      
 527   1              sym_8_to_float.result_char[0]=RecieveBuf[11];
 528   1              sym_8_to_float.result_char[1]=RecieveBuf[10];
 529   1              sym_8_to_float.result_char[2]=RecieveBuf[9];
 530   1              sym_8_to_float.result_char[3]=RecieveBuf[8];
 531   1      
 532   1              K=sym_8_to_float.result_float;
 533   1      
 534   1              sym_8_to_float.result_char[0]=RecieveBuf[15];
C51 COMPILER V9.00   PROTO_USO                                                             06/23/2014 10:13:56 PAGE 10  

 535   1              sym_8_to_float.result_char[1]=RecieveBuf[14];
 536   1              sym_8_to_float.result_char[2]=RecieveBuf[13];
 537   1              sym_8_to_float.result_char[3]=RecieveBuf[12];
 538   1      
 539   1              C=sym_8_to_float.result_float;
 540   1      
 541   1              switch(RecieveBuf[7])
 542   1              {
 543   2                      case 0:
 544   2                      {
 545   3                              Calibrate(RecieveBuf[6],K,C);   
 546   3                      }
 547   2                      break;
 548   2      
 549   2                      case 1:
 550   2                      {
 551   3                              Calibrate_Set_Flag(RecieveBuf[6],RESET);
 552   3                      }
 553   2                      break;
 554   2      
 555   2                      case 2:
 556   2                      {
 557   3                              Calibrate_Set_Flag(RecieveBuf[6],SET);  
 558   3                      }
 559   2                      break;
 560   2      
 561   2                      default :
 562   2                      {
 563   3                              _nop_();
 564   3                      }
 565   2                      break;
 566   2              }
 567   1      
 568   1      
 569   1              return  Request_Error(FR_SUCCESFUL);//ошибки нет, подтверждение 
 570   1      }
 571          //------------------------------------------------------------------------------
 572          unsigned char Channel_Get_Calibrate_Value(void)//получить коэфициенты калибровки заданного канала
 573          {
 574   1         unsigned char data channel=0;
 575   1      
 576   1      
 577   1         TransferBuf[0]=0x00;TransferBuf[1]=0xD7;TransferBuf[2]=0x29;
 578   1         TransferBuf[3]=ADRESS_DEV;  // адрес узла
 579   1         TransferBuf[4]=CHANNEL_GET_CALIBRATE_RESP;  // код операции
 580   1         TransferBuf[5]=0xB;//длина оставшейся части кадра
 581   1      
 582   1      
 583   1         channel=RecieveBuf[6];
 584   1      
 585   1         if(channel>=channel_number)
 586   1         {
 587   2                      return Request_Error(FR_COMMAND_STRUCT_ERROR);//непрвильный номер канала        
 588   2         }
 589   1      
 590   1         TransferBuf[6]=channel;
 591   1      
 592   1         TransferBuf[7]=channels[channel].calibrate.cal.calibrate;
 593   1      
 594   1         sym_8_to_float.result_float=channels[channel].calibrate.cal.K;
 595   1      
 596   1              TransferBuf[11]=sym_8_to_float.result_char[0];
C51 COMPILER V9.00   PROTO_USO                                                             06/23/2014 10:13:56 PAGE 11  

 597   1              TransferBuf[10]=sym_8_to_float.result_char[1];
 598   1              TransferBuf[9]=sym_8_to_float.result_char[2];
 599   1              TransferBuf[8]=sym_8_to_float.result_char[3];
 600   1      
 601   1         sym_8_to_float.result_float=channels[channel].calibrate.cal.C;
 602   1      
 603   1              TransferBuf[15]=sym_8_to_float.result_char[0];
 604   1              TransferBuf[14]=sym_8_to_float.result_char[1];
 605   1              TransferBuf[13]=sym_8_to_float.result_char[2];
 606   1              TransferBuf[12]=sym_8_to_float.result_char[3];
 607   1      
 608   1              TransferBuf[16]=CRC_Check(&TransferBuf[1],15); // подсчет кс
 609   1              return 0x11;//17        
 610   1      }
 611          //------------------------------------------------------------------------------
 612          unsigned char Channel_Set_Address_Desc(void)//установить новый адрес устройства, имя, описание, версию про
             -шивки и комментарий
 613          {
 614   1              unsigned char  desc_len=0;
 615   1              desc_len=RecieveBuf[5]-27;
 616   1      
 617   1              if(desc_len)
 618   1              {       
 619   2                      Store_Dev_Address_Desc(RecieveBuf[6],&RecieveBuf[7],&RecieveBuf[27],&RecieveBuf[32],desc_len);
 620   2                      return    Request_Error(FR_SUCCESFUL);//ошибки нет, подтверждение
 621   2              }
 622   1              else
 623   1              {
 624   2                      return Request_Error(FR_COMMAND_STRUCT_ERROR);
 625   2              }
 626   1              return 0;
 627   1      }
 628          //-----------------------------------------------------------------------------
 629          unsigned char Channel_Set_All_Default(void)//установить настройки и калибровки каналов по умолчанию
 630          {
 631   1              Channels_Set_Default();
 632   1              Calibrate_Set_Default();
 633   1              return  Request_Error(FR_SUCCESFUL);//ошибки нет, подтверждение         
 634   1      }
 635          //-----------------------------------------------------------------------------
 636          unsigned char Request_Error(unsigned char error_code) //using 0 //      Ошибочный запрос/ответ;
 637          {
 638   1              TransferBuf[0]=0x00;TransferBuf[1]=0xD7;TransferBuf[2]=0x29;
 639   1          TransferBuf[3]=ADRESS_DEV;  // адрес узла
 640   1          TransferBuf[7]=RecieveBuf[4]; // код сбойной команды
 641   1          TransferBuf[4]=0xFF;  // код операции
 642   1      
 643   1              TransferBuf[6]=STATE_BYTE; // байт статуса узла
 644   1          TransferBuf[8]=error_code;   
 645   1          TransferBuf[5]=0x04;          // длина данных
 646   1          TransferBuf[9]=CRC_Check(TransferBuf,9);
 647   1              return 10;
 648   1      }
 649          
 650          //-----------------------------------------------------------------------------
 651          unsigned char Old_CRC_Check(unsigned char xdata *Spool_pr,unsigned char Count_pr)
 652          {
 653   1           unsigned char crc = 0x0;
 654   1               unsigned char i=0;
 655   1      
 656   1               for(i=0;i<Count_pr;i++)
 657   1               {
C51 COMPILER V9.00   PROTO_USO                                                             06/23/2014 10:13:56 PAGE 12  

 658   2                      CY=0;
 659   2                      crc+=Spool_pr[i];
 660   2                      if(CY)
 661   2                      {
 662   3                              crc++;
 663   3                      }
 664   2               }
 665   1               crc=0xFF-crc;
 666   1      
 667   1           return crc;        
 668   1      }
 669          //-----------------------------------------------------------------------------
 670          unsigned char Old_Channel_Get_Data(void)
 671          {
 672   1        unsigned char channel=0;
 673   1        unsigned char len=0;
 674   1        channel=((RecieveBuf[4]>>3)&0x1F);
 675   1        if(channel<CHANNEL_NUMBER)
 676   1        {  
 677   2                 TransferBuf[0]=0x00;TransferBuf[1]=0xD7;TransferBuf[2]=0x28;
 678   2                 TransferBuf[3]=0x0;  // 
 679   2                 TransferBuf[4]=RecieveBuf[4];
 680   2                 TransferBuf[5]=((OLD_CHANNEL_GET_DATA<<5)&0x1F)|0x3;//0x63;// код операции   
 681   2      
 682   2                              switch(channels[channel].settings.set.type)
 683   2                          {
 684   3                                       case CHNL_ADC:  //аналоговый канал
 685   3                                       {
 686   4                                               switch(channels[channel].settings.set.modific)
 687   4                               {
 688   5                                                        case CHNL_ADC_FIX_16:
 689   5                                                        {
 690   6                                                                      if(channels[channel].calibrate.cal.calibrate==1)//калиброванный
 691   6                                                                      {                                                
 692   7                                                                                      TransferBuf[6]=((unsigned char*)(&channels[channel].channel_data_calibrate))[1];
 693   7                                                                              TransferBuf[7]=((unsigned char*)(&channels[channel].channel_data_calibrate))[2];
 694   7                                                                      }
 695   6                                                                      else
 696   6                                                                      {
 697   7                                                                                      TransferBuf[6]=((unsigned char*)(&channels[channel].channel_data))[1];
 698   7                                                                              TransferBuf[7]=((unsigned char*)(&channels[channel].channel_data))[2];  
 699   7                                                                      }                                       
 700   6                                                        }
 701   5                                                        break; 
 702   5      
 703   5                                                        case CHNL_ADC_FIX_24:
 704   5                                                        {
 705   6                                                              if(channels[channel].calibrate.cal.calibrate==1)//калиброванный
 706   6                                                                      {                                                                                                 
 707   7                                                                                      TransferBuf[channel]=((unsigned char*)(&channels[channel].channel_data_calibrate))[1];
 708   7                                                                              TransferBuf[channel]=((unsigned char*)(&channels[channel].channel_data_calibrate))[2];
 709   7                                                                      }
 710   6                                                                      else
 711   6                                                                      {                                                                        
 712   7                                                                                      TransferBuf[6]=((unsigned char*)(&channels[channel].channel_data))[1];
 713   7                                                                              TransferBuf[7]=((unsigned char*)(&channels[channel].channel_data))[2];  
 714   7                                                                      }
 715   6      
 716   6                                                        }
 717   5                                                        break;
 718   5                                                }                                       
 719   4                                        }
C51 COMPILER V9.00   PROTO_USO                                                             06/23/2014 10:13:56 PAGE 13  

 720   3                                        break;
 721   3      
 722   3                                      case CHNL_DOL:   //ДОЛ
 723   3                                      {
 724   4                                                switch(channels[channel].settings.set.modific)
 725   4                                            {   
 726   5                                                                case CHNL_DOL_ENC:
 727   5                                                                {
 728   6                                                                                      TransferBuf[6]=((unsigned char*)(&channels[channel].channel_data))[2];
 729   6                                                                                      TransferBuf[7]=((unsigned char*)(&channels[channel].channel_data))[3];
 730   6      //                                                                      TransferBuf[channel]=((unsigned char*)(&channels[channel].channel_data))[0];
 731   6      //                                                                              TransferBuf[channel]=((unsigned char*)(&channels[channel].channel_data))[1];
 732   6                                                                }
 733   5                                                                break; 
 734   5                                                 }
 735   4                                      }
 736   3                                      break;
 737   3      
 738   3                                       case CHNL_FREQ: //частотный
 739   3                                       { 
 740   4                                                switch(channels[channel].settings.set.modific)
 741   4                                            {   
 742   5                                                                
 743   5                                                                case CHNL_FREQ_COUNT_T:
 744   5                                                                {
 745   6                                                                                      TransferBuf[6]=((unsigned char*)(&channels[channel].channel_data))[2];
 746   6                                                                                      TransferBuf[7]=((unsigned char*)(&channels[channel].channel_data))[3];
 747   6      
 748   6                                                                }
 749   5                                                                break;
 750   5      
 751   5                                                                case CHNL_FREQ_256:
 752   5                                                                {
 753   6                                                                                      TransferBuf[6]=((unsigned char*)(&channels[channel].channel_data))[2];
 754   6                                                                                      TransferBuf[7]=((unsigned char*)(&channels[channel].channel_data))[3];
 755   6                                                                }
 756   5                                                                break; 
 757   5                                                 }                                       
 758   4                                        }
 759   3                                        break;                 
 760   3                        }
 761   2                 
 762   2                 len=Old_Proto_Paste_Null(TransferBuf,8);
 763   2      
 764   2                 TransferBuf[len]=Old_CRC_Check(TransferBuf,len);
 765   2                 return len+1;
 766   2         }
 767   1         return 0;    
 768   1      }
 769          //-----------------------------------------------------------------------------
 770          unsigned char Old_Channel_Get_Data_State(void)
 771          {
 772   1        unsigned char channel=0;
 773   1        unsigned char len=0;
 774   1        channel=((RecieveBuf[4]>>3)&0x1F);
 775   1        if(channel<CHANNEL_NUMBER)
 776   1        {
 777   2                 TransferBuf[0]=0x00;TransferBuf[1]=0xD7;TransferBuf[2]=0x28;
 778   2                 TransferBuf[3]=0x0;  // 
 779   2                 TransferBuf[4]=RecieveBuf[4];
 780   2                 TransferBuf[5]=((OLD_CHANNEL_GET_DATA_STATE<<5)&0x1F)|0x6;//0x66;// код операции     
 781   2      
C51 COMPILER V9.00   PROTO_USO                                                             06/23/2014 10:13:56 PAGE 14  

 782   2                              switch(channels[channel].settings.set.type)
 783   2                          {
 784   3                                       case CHNL_ADC:  //аналоговый канал
 785   3                                       {
 786   4                                               switch(channels[channel].settings.set.modific)
 787   4                               {
 788   5                                                        case CHNL_ADC_FIX_16:
 789   5                                                        {
 790   6                                                                      if(channels[channel].calibrate.cal.calibrate==1)//калиброванный
 791   6                                                                      {                                                
 792   7                                                                                      TransferBuf[6]=((unsigned char*)(&channels[channel].channel_data_calibrate))[1];
 793   7                                                                              TransferBuf[7]=((unsigned char*)(&channels[channel].channel_data_calibrate))[2];
 794   7                                                                      }
 795   6                                                                      else
 796   6                                                                      {
 797   7                                                                                      TransferBuf[6]=((unsigned char*)(&channels[channel].channel_data))[1];
 798   7                                                                              TransferBuf[7]=((unsigned char*)(&channels[channel].channel_data))[2];  
 799   7                                                                      }                                       
 800   6                                                        }
 801   5                                                        break; 
 802   5      
 803   5                                                        case CHNL_ADC_FIX_24:
 804   5                                                        {
 805   6                                                              if(channels[channel].calibrate.cal.calibrate==1)//калиброванный
 806   6                                                                      {                                                                                                 
 807   7                                                                                      TransferBuf[channel]=((unsigned char*)(&channels[channel].channel_data_calibrate))[1];
 808   7                                                                              TransferBuf[channel]=((unsigned char*)(&channels[channel].channel_data_calibrate))[2];
 809   7                                                                      }
 810   6                                                                      else
 811   6                                                                      {                                                                        
 812   7                                                                                      TransferBuf[6]=((unsigned char*)(&channels[channel].channel_data))[1];
 813   7                                                                              TransferBuf[7]=((unsigned char*)(&channels[channel].channel_data))[2];  
 814   7                                                                      }
 815   6      
 816   6                                                        }
 817   5                                                        break;
 818   5                                                }
 819   4                                                
 820   4                                                switch(channels[channel].settings.set.state_byte_1&0x7)
 821   4                                                {
 822   5                                                              case PROTO_ADC_AMP_1:
 823   5                                                              {
 824   6                                                                      TransferBuf[8]=(0x00|(OLD_PROTO_ADC_AMP_1<<1))&0xFE;     // первый байт состояния канала
 825   6                                                              }
 826   5                                                              break;
 827   5      
 828   5                                                              case PROTO_ADC_AMP_2:
 829   5                                                              {
 830   6                                                                      TransferBuf[8]=(0x00|(OLD_PROTO_ADC_AMP_2<<1))&0xFE;     // первый байт состояния канала        
 831   6                                                              }
 832   5                                                              break;
 833   5      
 834   5                                                              case PROTO_ADC_AMP_32:
 835   5                                                              {
 836   6                                                                      TransferBuf[8]=(0x00|(OLD_PROTO_ADC_AMP_32<<1))&0xFE;    // первый байт состояния канала        
 837   6                                                              }
 838   5                                                              break;
 839   5      
 840   5                                                              case PROTO_ADC_AMP_128:
 841   5                                                              {
 842   6                                                                      TransferBuf[8]=(0x00|(OLD_PROTO_ADC_AMP_128<<1))&0xFE;   // первый байт состояния канала
 843   6                                                              }
C51 COMPILER V9.00   PROTO_USO                                                             06/23/2014 10:13:56 PAGE 15  

 844   5                                                              break;
 845   5      
 846   5                                                              default :
 847   5                                                              {
 848   6                                                                      TransferBuf[8]=(0x00|(OLD_PROTO_ADC_AMP_1<<1))&0xFE;     // первый байт состояния канала
 849   6                                                              }
 850   5                                                              break;
 851   5                                                }
 852   4                                                
 853   4                                                TransferBuf[9]=0x0A;   // второй байт состояния канала
 854   4      
 855   4                                        }
 856   3                                        break;
 857   3      
 858   3                                case CHNL_DOL:         //ДОЛ
 859   3                                {
 860   4                                        switch(channels[channel].settings.set.modific)
 861   4                                    {   
 862   5                                                        case CHNL_DOL_ENC:
 863   5                                                        {
 864   6                                                                      TransferBuf[6]=((unsigned char*)(&channels[channel].channel_data))[2];
 865   6                                                                      TransferBuf[7]=((unsigned char*)(&channels[channel].channel_data))[3];
 866   6      //                                                                      TransferBuf[channel]=((unsigned char*)(&channels[channel].channel_data))[0];
 867   6      //                                                                              TransferBuf[channel]=((unsigned char*)(&channels[channel].channel_data))[1];
 868   6      
 869   6                                                                      
 870   6      
 871   6                                                                      switch(channels[channel].settings.set.state_byte_1&0x7)
 872   6                                                                      {
 873   7                                                                                      case PROTO_ADC_AMP_1:
 874   7                                                                                      {
 875   8                                                                                              TransferBuf[8]=(0x40|(OLD_PROTO_ADC_AMP_1<<1))&0xFE;     // первый байт состояния канала
 876   8                                                                                      }
 877   7                                                                                      break;
 878   7                              
 879   7                                                                                      case PROTO_ADC_AMP_2:
 880   7                                                                                      {
 881   8                                                                                              TransferBuf[8]=(0x40|(OLD_PROTO_ADC_AMP_2<<1))&0xFE;     // первый байт состояния канала        
 882   8                                                                                      }
 883   7                                                                                      break;
 884   7                              
 885   7                                                                                      case PROTO_ADC_AMP_32:
 886   7                                                                                      {
 887   8                                                                                              TransferBuf[8]=(0x40|(OLD_PROTO_ADC_AMP_32<<1))&0xFE;    // первый байт состояния канала        
 888   8                                                                                      }
 889   7                                                                                      break;
 890   7                              
 891   7                                                                                      case PROTO_ADC_AMP_128:
 892   7                                                                                      {
 893   8                                                                                              TransferBuf[8]=(0x40|(OLD_PROTO_ADC_AMP_128<<1))&0xFE;   // первый байт состояния канала
 894   8                                                                                      }
 895   7                                                                                      break;
 896   7                              
 897   7                                                                                      default :
 898   7                                                                                      {
 899   8                                                                                              TransferBuf[8]=(0x40|(OLD_PROTO_ADC_AMP_1<<1))&0xFE;
 900   8                                                                                      }
 901   7                                                                                      break;                  
 902   7                                                                      }
 903   6                                                                      TransferBuf[9]=0x00;     // второй байт состояния канала
 904   6                                                        }
 905   5                                                        break; 
C51 COMPILER V9.00   PROTO_USO                                                             06/23/2014 10:13:56 PAGE 16  

 906   5                                                 }
 907   4                                      }
 908   3                                      break;
 909   3      
 910   3                                       case CHNL_FREQ: //частотный
 911   3                                       { 
 912   4                                                switch(channels[channel].settings.set.modific)
 913   4                                            {   
 914   5                                                                
 915   5                                                                case CHNL_FREQ_COUNT_T:
 916   5                                                                {
 917   6                                                                                      TransferBuf[6]=((unsigned char*)(&channels[channel].channel_data))[2];
 918   6                                                                                      TransferBuf[7]=((unsigned char*)(&channels[channel].channel_data))[3];
 919   6      
 920   6                                                                }
 921   5                                                                break;
 922   5      
 923   5                                                                case CHNL_FREQ_256:
 924   5                                                                {
 925   6                                                                                      TransferBuf[6]=((unsigned char*)(&channels[channel].channel_data))[2];
 926   6                                                                                      TransferBuf[7]=((unsigned char*)(&channels[channel].channel_data))[3];
 927   6                                                                }
 928   5                                                                break; 
 929   5                                                 }
 930   4                                                 
 931   4                                              TransferBuf[8]=0x40;     // первый байт состояния канала
 932   4                                      TransferBuf[9]=0x00;     // второй байт состояния канала
 933   4                                        }
 934   3                                        break;                 
 935   3                        }
 936   2      
 937   2                 TransferBuf[10]=0xFF;
 938   2      
 939   2                 len=Old_Proto_Paste_Null(TransferBuf,11);
 940   2      
 941   2                 TransferBuf[len]=Old_CRC_Check(TransferBuf,len);
 942   2                 return len+1;
 943   2         }
 944   1         return 0;
 945   1      
 946   1      }
 947          //-----------------------------------------------------------------------------
 948          unsigned char Old_Channel_Get_State(void)
 949          {
 950   1        unsigned char channel=0;
 951   1        unsigned char len=0;
 952   1        channel=((RecieveBuf[4]>>3)&0x1F);
 953   1        if(channel<CHANNEL_NUMBER)
 954   1        {
 955   2        
 956   2                 TransferBuf[0]=0x00;TransferBuf[1]=0xD7;TransferBuf[2]=0x28;
 957   2                 TransferBuf[3]=0x0;  // 
 958   2                 TransferBuf[4]=RecieveBuf[4];
 959   2                 TransferBuf[5]=((OLD_CHANNEL_GET_STATE<<5)&0x1F)|0x3;//0x43;// код операции  
 960   2      
 961   2                              switch(channels[channel].settings.set.type)
 962   2                          {
 963   3                                       case CHNL_ADC:  //аналоговый канал
 964   3                                       {                
 965   4                                                switch(channels[channel].settings.set.state_byte_1&0x7)
 966   4                                                {
 967   5                                                              case PROTO_ADC_AMP_1:
C51 COMPILER V9.00   PROTO_USO                                                             06/23/2014 10:13:56 PAGE 17  

 968   5                                                              {
 969   6                                                                      TransferBuf[6]=0x00|(OLD_PROTO_ADC_AMP_1<<1);    // первый байт состояния канала
 970   6                                                              }
 971   5                                                              break;
 972   5      
 973   5                                                              case PROTO_ADC_AMP_2:
 974   5                                                              {
 975   6                                                                      TransferBuf[6]=0x00|(OLD_PROTO_ADC_AMP_2<<1);    // первый байт состояния канала        
 976   6                                                              }
 977   5                                                              break;
 978   5      
 979   5                                                              case PROTO_ADC_AMP_32:
 980   5                                                              {
 981   6                                                                      TransferBuf[6]=0x00|(OLD_PROTO_ADC_AMP_32<<1);   // первый байт состояния канала        
 982   6                                                              }
 983   5                                                              break;
 984   5      
 985   5                                                              case PROTO_ADC_AMP_128:
 986   5                                                              {
 987   6                                                                      TransferBuf[6]=0x00|(OLD_PROTO_ADC_AMP_128<<1);  // первый байт состояния канала
 988   6                                                              }
 989   5                                                              break;
 990   5      
 991   5                                                              default :
 992   5                                                              {
 993   6                                                                      TransferBuf[6]=0x00|(OLD_PROTO_ADC_AMP_1<<1);    // первый байт состояния канала
 994   6                                                              }
 995   5                                                              break;
 996   5                                                }
 997   4                                                
 998   4                                                TransferBuf[7]=0x0A;   // второй байт состояния канала
 999   4                                        }
1000   3                                        break;
1001   3      
1002   3                                      case CHNL_DOL:   //ДОЛ
1003   3                                      {
1004   4      
1005   4                                                      switch(channels[channel].settings.set.state_byte_1&0x7)
1006   4                                                      {
1007   5                                                                      case PROTO_ADC_AMP_1:
1008   5                                                                      {
1009   6                                                                              TransferBuf[6]=0x40|(OLD_PROTO_ADC_AMP_1<<1);    // первый байт состояния канала
1010   6                                                                      }
1011   5                                                                      break;
1012   5              
1013   5                                                                      case PROTO_ADC_AMP_2:
1014   5                                                                      {
1015   6                                                                              TransferBuf[6]=0x40|(OLD_PROTO_ADC_AMP_2<<1);    // первый байт состояния канала        
1016   6                                                                      }
1017   5                                                                      break;
1018   5              
1019   5                                                                      case PROTO_ADC_AMP_32:
1020   5                                                                      {
1021   6                                                                              TransferBuf[6]=0x40|(OLD_PROTO_ADC_AMP_32<<1);   // первый байт состояния канала        
1022   6                                                                      }
1023   5                                                                      break;
1024   5              
1025   5                                                                      case PROTO_ADC_AMP_128:
1026   5                                                                      {
1027   6                                                                              TransferBuf[6]=0x40|(OLD_PROTO_ADC_AMP_128<<1);  // первый байт состояния канала
1028   6                                                                      }
1029   5                                                                      break;
C51 COMPILER V9.00   PROTO_USO                                                             06/23/2014 10:13:56 PAGE 18  

1030   5              
1031   5                                                                      default :
1032   5                                                                      {
1033   6                                                                              TransferBuf[6]=0x40;     // первый байт состояния канала
1034   6                                                                      }
1035   5                                                                      break;
1036   5              
1037   5                                                      }
1038   4                                                      TransferBuf[7]=0x00;     // второй байт состояния канала
1039   4                                      }
1040   3                                      break;
1041   3      
1042   3                                       case CHNL_FREQ: //частотный
1043   3                                       { 
1044   4                                                 
1045   4                                              TransferBuf[6]=0x40;     // первый байт состояния канала
1046   4                                      TransferBuf[7]=0x00;     // второй байт состояния канала
1047   4                                       }
1048   3                                       break;          
1049   3                        }
1050   2                 
1051   2                 len=Old_Proto_Paste_Null(TransferBuf,8);
1052   2      
1053   2                 TransferBuf[len]=Old_CRC_Check(TransferBuf,len);
1054   2                 return len+1;
1055   2         }
1056   1         return 0;    
1057   1      }
1058          //-----------------------------------------------------------------------------
1059          unsigned char Old_Reinit_Block(void)
1060          {
1061   1              return 0;       
1062   1      }
1063          //-----------------------------------------------------------------------------
1064          unsigned char Old_Channel_Set_ADC_Range(void)
1065          {
1066   1        unsigned char channel=0;
1067   1        channel=((RecieveBuf[4]>>3)&0x1F);
1068   1        if(channel<CHANNEL_NUMBER)
1069   1        {     
1070   2              switch((RecieveBuf[6]>>1)&0x3)
1071   2              {
1072   3                              case OLD_PROTO_ADC_AMP_1:
1073   3                              {
1074   4                                   channels[channel].settings.set.state_byte_1&=0xF0;
1075   4                                       channels[channel].settings.set.state_byte_1|=PROTO_ADC_AMP_1;
1076   4                              }
1077   3                              break;
1078   3      
1079   3                              case OLD_PROTO_ADC_AMP_2:
1080   3                              {
1081   4                                       channels[channel].settings.set.state_byte_1&=0xF0;
1082   4                                       channels[channel].settings.set.state_byte_1|=PROTO_ADC_AMP_2;
1083   4                              }
1084   3                              break;
1085   3      
1086   3                              case OLD_PROTO_ADC_AMP_32:
1087   3                              {
1088   4                                       channels[channel].settings.set.state_byte_1&=0xF0;
1089   4                                       channels[channel].settings.set.state_byte_1|=PROTO_ADC_AMP_32;
1090   4                              }
1091   3                              break;
C51 COMPILER V9.00   PROTO_USO                                                             06/23/2014 10:13:56 PAGE 19  

1092   3      
1093   3                              case OLD_PROTO_ADC_AMP_128:
1094   3                              {
1095   4                                   channels[channel].settings.set.state_byte_1&=0xF0;
1096   4                                       channels[channel].settings.set.state_byte_1|=PROTO_ADC_AMP_128;
1097   4                              }
1098   3                              break;
1099   3      
1100   3                              default :
1101   3                              {
1102   4                                   channels[channel].settings.set.state_byte_1&=0xF0;
1103   4                                       channels[channel].settings.set.state_byte_1|=PROTO_ADC_AMP_1;
1104   4                              }
1105   3                              break;
1106   3              }
1107   2        }
1108   1        return 0;
1109   1      }
1110          //-----------------------------------------------------------------------------
1111          unsigned char Old_Proto_Paste_Null(unsigned char *buf,unsigned char len)//т.к. старый протокол прибавляет 
             -к длине количество 0 после D7 то обрабатываем вне прерывания
1112          {
1113   1              volatile unsigned char xdata i=0,j=0;
1114   1      
1115   1              for(i=3;i<len;i++) //пропустим заголовок 0x00 0xD7 0x28
1116   1              {
1117   2                       if(buf[i]==0xD7)
1118   2                       {
1119   3                               for(j=(len-1);j>i;j--)
1120   3                               {
1121   4                                      buf[j+1]=buf[j];//сдвигаем элементы буфера вправо на одну позицию до D7
1122   4                               }
1123   3                               buf[i+1]=0x0;//вставляем 0x00 после 0xD7
1124   3                               buf[5]++;//длина кадра увеличилась на 1
1125   3                               len++;
1126   3                               i++;//не проверяем 0 спереди
1127   3                       }
1128   2              }
1129   1              return len;
1130   1      }
1131          //-----------------------------------------------------------------------------
1132          void ProtoBufHandling(void) //using 0 //процесс обработки принятого запроса
1133          {
1134   1              switch(protocol_type)
1135   1              {
1136   2                      case PROTO_TYPE_NEW:
1137   2                      {
1138   3                                channels[11].settings.set.state_byte_1=0x40; //восстановим байты статуса дола
1139   3                                channels[11].settings.set.state_byte_2=0x0A;
1140   3                                switch(RecieveBuf[4])
1141   3                                {
1142   4                              //---------------------------------------
1143   4                                      case GET_DEV_INFO_REQ:
1144   4                                      {
1145   5                                              buf_len=Send_Info();    
1146   5                                      }
1147   4                                      break;
1148   4                              //---------------------------------------
1149   4                                      case NODE_FULL_INIT_REQ:
1150   4                                      {
1151   5                                              buf_len=Node_Full_Init();
1152   5                                      }
C51 COMPILER V9.00   PROTO_USO                                                             06/23/2014 10:13:56 PAGE 20  

1153   4                                      break;
1154   4                              //---------------------------------------
1155   4                                      case CHANNEL_LIST_INIT_REQ:
1156   4                                      {       
1157   5                                              buf_len=Channel_List_Init();    
1158   5                                      }
1159   4                                      break;
1160   4                              //---------------------------------------
1161   4                                      case CHANNEL_GET_DATA_REQ:
1162   4                                      {
1163   5                                              buf_len=Channel_Get_Data();     
1164   5                                      }
1165   4                                      break;
1166   4                                      //-----------------------------------
1167   4                                      case CHANNEL_SET_PARAMETERS_REQ:
1168   4                                      {
1169   5                                              buf_len=Channel_Set_Parameters();
1170   5                                      }
1171   4                                      break;
1172   4                                      //-----------------------------------
1173   4                                      case CHANNEL_SET_ORDER_QUERY_REQ:
1174   4                                      {
1175   5                                              buf_len=Channel_Set_Order_Query();
1176   5                                      }
1177   4                                      break;
1178   4                              //----------------------------------------
1179   4                                      case CHANNEL_GET_DATA_ORDER_REQ:
1180   4                                      {
1181   5                                               buf_len=Channel_Get_Data_Order();
1182   5                                      }
1183   4                                      break;
1184   4                              //----------------------------------------
1185   4                                      case CHANNEL_SET_STATE_REQ:
1186   4                                      {
1187   5                                               buf_len=Channel_Set_State();
1188   5                                      }
1189   4                                      break;
1190   4                              //----------------------------------------
1191   4                                      case CHANNEL_GET_DATA_ORDER_M2_REQ:
1192   4                                      {
1193   5                                               buf_len=Channel_Get_Data_Order_M2();
1194   5                                      }
1195   4                                      break;
1196   4                              //------------------------------------------
1197   4                                      case CHANNEL_SET_RESET_STATE_FLAGS_REQ:
1198   4                                      {
1199   5                                              buf_len=Channel_Set_Reset_State_Flags();
1200   5                                      }
1201   4                                      break;
1202   4                              //------------------------------------------
1203   4                                      case CHANNEL_ALL_GET_DATA_REQ:
1204   4                                      {
1205   5                                               buf_len=Channel_All_Get_Data();
1206   5                                      }
1207   4                                      break;
1208   4                              //------------------------------------------
1209   4                                      case CHANNEL_SET_ADDRESS_DESC:
1210   4                                      {
1211   5                                               buf_len=Channel_Set_Address_Desc();
1212   5                                      }
1213   4                                      break;
1214   4                              //------------------------------------------
C51 COMPILER V9.00   PROTO_USO                                                             06/23/2014 10:13:56 PAGE 21  

1215   4                                      case CHANNEL_SET_CALIBRATE:
1216   4                                      {
1217   5                                               buf_len=Channel_Set_Calibrate();
1218   5                                      }
1219   4                                      break;
1220   4                              //------------------------------------------
1221   4                                      case CHANNEL_SET_ALL_DEFAULT:
1222   4                                      {
1223   5                                               buf_len=Channel_Set_All_Default();
1224   5                                      }
1225   4                                      break;
1226   4                              //------------------------------------------
1227   4                                      case CHANNEL_GET_CALIBRATE_REQ:
1228   4                                      {
1229   5                                               buf_len=Channel_Get_Calibrate_Value();
1230   5                                      }
1231   4                                      break;
1232   4                              //------------------------------------------
1233   4                                  default:
1234   4                                      {
1235   5                                         buf_len=Request_Error(FR_COMMAND_NOT_EXIST);
1236   5                                  }                                                              
1237   4                                }
1238   3                      }
1239   2                      break;
1240   2      
1241   2                      case PROTO_TYPE_OLD: //старый протокол
1242   2                      {
1243   3                                switch((RecieveBuf[5]>>5)&0x7)
1244   3                                {
1245   4                              //---------------------------------------
1246   4                                      case OLD_CHANNEL_REINIT_BLOCK:
1247   4                                      {
1248   5                                              buf_len=Old_Reinit_Block();     
1249   5                                      }
1250   4                                      break;
1251   4                              //---------------------------------------
1252   4                                      case OLD_CHANNEL_SET_ADC_RANGE:
1253   4                                      {
1254   5                                              buf_len=Old_Channel_Set_ADC_Range();
1255   5                                      }
1256   4                                      break;
1257   4                              //---------------------------------------
1258   4                                      case OLD_CHANNEL_GET_STATE:
1259   4                                      {       
1260   5                                              buf_len=Old_Channel_Get_State();        
1261   5                                      }
1262   4                                      break;
1263   4                              //---------------------------------------
1264   4                                      case OLD_CHANNEL_GET_DATA:
1265   4                                      {
1266   5                                              buf_len=Old_Channel_Get_Data(); 
1267   5                                      }
1268   4                                      break;
1269   4                                      //-----------------------------------
1270   4                                      case OLD_CHANNEL_GET_DATA_STATE:
1271   4                                      {
1272   5                                              buf_len=Old_Channel_Get_Data_State();
1273   5                                      }
1274   4                                      break;
1275   4                                      //-----------------------------------
1276   4                                  default:
C51 COMPILER V9.00   PROTO_USO                                                             06/23/2014 10:13:56 PAGE 22  

1277   4                                      {
1278   5                                         
1279   5                                  }                                                              
1280   4                                }     
1281   3                       }
1282   2                       break;
1283   2                       
1284   2                       case PROTO_TYPE_MODBUS_ASCII:
1285   2                       {
1286   3                                switch(MBCHAR2BIN(RecieveBuf[3])<<4| MBCHAR2BIN(RecieveBuf[4]))
1287   3                                {
1288   4                                      //---------------------------------------
1289   4                                              case MB_FUNC_READ_HOLDING_REGISTER:
1290   4                                              {
1291   5                                                      buf_len=ReadHoldingReg();       
1292   5                                              }
1293   4                                              break;
1294   4                                      //------------------------------------------
1295   4                                          default:
1296   4                                              {
1297   5                                                 buf_len=0x0;
1298   5                                          }                                                              
1299   4                                }
1300   3                       }
1301   2                       break; 
1302   2              }
1303   1      
1304   1        return;
1305   1      }
1306          //-----------------------------------------------------------------------------------
1307          //#pragma OT(0,Speed) 
1308          PT_THREAD(ProtoProcess(struct pt *pt))
1309           {
1310   1       static unsigned char  CRC=0x0, LRC=0x0;
1311   1        PT_BEGIN(pt);
1312   3      
1313   3        while(1) 
1314   3        {
1315   4        //----------restart------------
1316   4                      recieve_count=0x0;//??
1317   4                      REN=1;//recieve enqble
1318   4                      DE_RE=0;//линия на прием
1319   4                      ES=1;
1320   4        //-----------------------------
1321   4                // PT_WAIT_UNTIL(pt,RECIEVED); //ждем команды на старт
1322   4                 wdt_count[Proto_Proc].process_state=IDLE;
1323   4      
1324   4                 PT_YIELD_UNTIL(pt,RECIEVED); //ждем команды на старт 
1325   4                 wdt_count[Proto_Proc].count++;
1326   4                // WDT_Clear();//если посылка не приходит-сбрасываем
1327   4      
1328   4                
1329   4                  RECIEVED=0;
1330   4                      
1331   4      
1332   4                      switch(protocol_type)
1333   4                      {
1334   5                              case PROTO_TYPE_NEW:
1335   5                              {
1336   6                                      if(RecieveBuf[3]!=ADRESS_DEV)//если адрес совпал          
1337   6                                      {
1338   7                                              PT_RESTART(pt);//если адрес не сошелся-перезапустим протокол                    
C51 COMPILER V9.00   PROTO_USO                                                             06/23/2014 10:13:56 PAGE 23  

1339   7                                      }
1340   6      
1341   6                                      CRC=RecieveBuf[recieve_count-1];
1342   6      
1343   6                                  if(CRC_Check(&RecieveBuf,(recieve_count-CRC_LEN))!=CRC)
1344   6                                      {
1345   7                                              PT_RESTART(pt);//если CRC не сошлось-перезапустим протокол       
1346   7                                      }
1347   6                              }
1348   5                              break;
1349   5              
1350   5                              case PROTO_TYPE_OLD:
1351   5                              {
1352   6                                      CRC=RecieveBuf[recieve_count-1];
1353   6      
1354   6                                      if(Old_CRC_Check(&RecieveBuf,(recieve_count-CRC_LEN))!=CRC)
1355   6                                      {
1356   7                                              PT_RESTART(pt);//если CRC не сошлось-перезапустим протокол       
1357   7                                      }
1358   6                              }
1359   5                              break;
1360   5              
1361   5                              case PROTO_TYPE_MODBUS_ASCII:
1362   5                              {
1363   6                                      if((unsigned char)(MBCHAR2BIN(RecieveBuf[1])<<4| MBCHAR2BIN(RecieveBuf[2]))!=ADRESS_DEV)
1364   6                                      {
1365   7                                              PT_RESTART(pt); 
1366   7                                      }       
1367   6                                      
1368   6                      
1369   6                                      LRC=((MBCHAR2BIN(RecieveBuf[recieve_count-LRC_LEN])<<4)|(MBCHAR2BIN(RecieveBuf[recieve_count-LRC_LEN+1
             -])));
1370   6                                              
1371   6                                      if(LRC_Check(&RecieveBuf,(recieve_count-LRC_LEN))!=LRC)
1372   6                                      {
1373   7                                              PT_RESTART(pt);//если LRC не сошлось-перезапустим протокол                       
1374   7                                      }
1375   6                              }
1376   5                              break;
1377   5                      }
1378   4      
1379   4              //      PT_YIELD(pt);//дадим другим процессам время
1380   4        //-----------------------------
1381   4                      ProtoBufHandling();//процедура обработки сообщения      
1382   4                      if(buf_len==0)//если в буфере пусто
1383   4                      {
1384   5                              PT_RESTART(pt);//перезапустим протокол  
1385   5                      }
1386   4                      else
1387   4                      {
1388   5                              DE_RE=1; //переключаем RS485 в режим передачи
1389   5                                                              
1390   5                              REN=0;  //запрет приема-только передача
1391   5                              transf_count=0;
1392   5                              CUT_OUT_NULL=0;
1393   5                              SBUF=TransferBuf[transf_count];//передача байта, остальным займется автомат
1394   5                              transf_count++;//инкрементируем счетчик переданных
1395   5                              ES=1; //включим прерывание уарт 
1396   5      
1397   5                          if(protocol_type==PROTO_TYPE_NEW)
1398   5                              {
1399   6                                      PT_DELAY(pt,10);
C51 COMPILER V9.00   PROTO_USO                                                             06/23/2014 10:13:56 PAGE 24  

1400   6                              }
1401   5                              else
1402   5                              {
1403   6                                      PT_DELAY(pt,3);
1404   6                              }                       
1405   5                      }               
1406   4        //-----------------------------
1407   4        }
1408   3      
1409   3       PT_END(pt);
1410   1      }
1411          //-----------------------------------------------------------------------------------------------
1412          void Store_Dev_Address_Desc(unsigned char addr,void* name,void* ver,void* desc,unsigned char desc_len)//со
             -хранить в ППЗУ новый адрес устройства, имя, версию, описание
1413          {
1414   1      //небезопасная
1415   1              
1416   1              unsigned int blocks=0;//здесь будет количество блоков, нужных дя сохранения комментария
1417   1              
1418   1              EEPROM_Write(&addr,1,DEVICE_ADDR_EEPROM);        //1 блок
1419   1              EEPROM_Write(name,DEVICE_NAME_LENGTH,DEVICE_NAME_EEPROM); //5 блоков
1420   1              memcpy(DEV_NAME,name,DEVICE_NAME_LENGTH_SYM);//копируем полученное имя в буфер
1421   1      
1422   1              EEPROM_Write(ver,DEVICE_VER_LENGTH,DEVICE_VER_EEPROM);          //2 блока
1423   1              memcpy(VERSION,ver,DEVICE_VER_LENGTH_SYM);//копируем версию в буфер
1424   1      
1425   1              blocks=desc_len>>2;//в блоке 4 байта, делим на 4
1426   1              if(desc_len&0xFC)//если есть остаток, то берем еще один блок
1427   1                      blocks++;
1428   1              
1429   1              if(blocks>DEVICE_DESC_MAX_LENGTH) //ограничение на количество блоков для комментария
1430   1                      blocks=DEVICE_DESC_MAX_LENGTH;
1431   1      
1432   1              EEPROM_Write(desc,(unsigned int)blocks,DEVICE_DESC_EEPROM);
1433   1              dev_desc_len=desc_len;
1434   1              EEPROM_Write(&desc_len,1,DEVICE_DESC_LEN_EEPROM);//сохраним длину комментария
1435   1              
1436   1              memcpy(NOTICE,desc,desc_len);//копируем описание в буфер
1437   1              
1438   1              return;
1439   1      }
1440          //-----------------------------------------------------------------------------------------------
1441          void Restore_Dev_Address_Desc(void)//восстановить из ппзу адрес и информацию об устройстве
1442          {
1443   1              unsigned int blocks=0;//здесь будет количество блоков, нужных дя сохранения комментария
1444   1              
1445   1              EEPROM_Read(&ADRESS_DEV,1,DEVICE_ADDR_EEPROM);   //1 блок восстанавливаем адрес из ППЗУ
1446   1      
1447   1              if(ADRESS_DEV<1 || ADRESS_DEV>15)
1448   1                      ADRESS_DEV=1; 
1449   1      
1450   1              EEPROM_Read(DEV_NAME,DEVICE_NAME_LENGTH,DEVICE_NAME_EEPROM); //5 блоков
1451   1          EEPROM_Read(VERSION,DEVICE_VER_LENGTH,DEVICE_VER_EEPROM);
1452   1      
1453   1              EEPROM_Read(&dev_desc_len,1,DEVICE_DESC_LEN_EEPROM);//длина описания устройства в байтах
1454   1      
1455   1              if(dev_desc_len>DEVICE_DESC_MAX_LENGTH_SYM)
1456   1                      dev_desc_len=DEVICE_DESC_MAX_LENGTH_SYM;
1457   1      
1458   1              blocks=dev_desc_len>>2;//в блоке 4 байта, делим на 4
1459   1              if(dev_desc_len&0xFC)//если есть остаток, то берем еще один блок
1460   1                      blocks++;
C51 COMPILER V9.00   PROTO_USO                                                             06/23/2014 10:13:56 PAGE 25  

1461   1      
1462   1              if(blocks>DEVICE_DESC_MAX_LENGTH) //ограничение на количество блоков для комментария     ???
1463   1                      blocks=DEVICE_DESC_MAX_LENGTH;
1464   1      
1465   1              EEPROM_Read(NOTICE,(unsigned int)blocks,DEVICE_DESC_EEPROM);
1466   1              return;
1467   1      }
1468          //-----------------------------------------------------------------------------------------------
1469          
1470          
1471           PT_THREAD(RingBufHandling(struct pt *pt))//обработка кольцевого буфера
1472           {
1473   1              static unsigned char temp_count=0;//временные копии конца  и счетчика буфера
1474   1              static unsigned char temp_tail=0;
1475   1      //      static unsigned char frame_count=0;//счетчик формируемого кадра  протокола
1476   1      
1477   1              static unsigned char i=0;
1478   1      
1479   1        PT_BEGIN(pt);
1480   3      
1481   3        while(1) 
1482   3        {
1483   4                      PT_YIELD_UNTIL(pt,(rngbuf.count>0x0));//в буфере есть данные
1484   4      
1485   4                      ES=0;
1486   4                      temp_count=rngbuf.count;
1487   4                      rngbuf.count=0x0;
1488   4                      temp_tail =rngbuf.tail;
1489   4                      ES=1;
1490   4      
1491   4                      for(i=(temp_tail-temp_count);i<temp_tail;i++)//поиск стартовой последовательности
1492   4                      {
1493   5                              switch(rngbuf.buf[i])
1494   5                              {
1495   6                                              case (char)(0xD7):
1496   6                                              {
1497   7                                                      RecieveBuf[recieve_count]=rngbuf.buf[i];
1498   7                                                      recieve_count++;
1499   7                                                      CUT_OUT_NULL=1;          
1500   7                                              }
1501   6                                              break;
1502   6                      
1503   6                                              case (char)(0x29):
1504   6                                              {
1505   7                                                      if(CUT_OUT_NULL==1)
1506   7                                                      {
1507   8                                                              RecieveBuf[0]=0x0;
1508   8                                                              RecieveBuf[1]=0xD7;
1509   8                                                              RecieveBuf[2]=0x29;
1510   8                                                              recieve_count=0x3;
1511   8                                                              protocol_type=PROTO_TYPE_NEW;                   
1512   8                                                      }
1513   7                                                      else
1514   7                                                      {
1515   8                                                              RecieveBuf[recieve_count]=rngbuf.buf[i];
1516   8                                                              recieve_count++;        
1517   8                                                      }
1518   7                                                      CUT_OUT_NULL=0;
1519   7                                              }
1520   6                                              break;
1521   6                      
1522   6                                              case (char)(0x28):
C51 COMPILER V9.00   PROTO_USO                                                             06/23/2014 10:13:56 PAGE 26  

1523   6                                              {
1524   7                                                      if(CUT_OUT_NULL==1)
1525   7                                                      {
1526   8                                                              RecieveBuf[0]=0x0;
1527   8                                                              RecieveBuf[1]=0xD7;
1528   8                                                              RecieveBuf[2]=0x28;
1529   8                                                              recieve_count=0x3;
1530   8                                                              protocol_type=PROTO_TYPE_OLD;                   
1531   8                                                      }
1532   7                                                      else
1533   7                                                      {
1534   8                                                              RecieveBuf[recieve_count]=rngbuf.buf[i];
1535   8                                                              recieve_count++;        
1536   8                                                      }
1537   7                                                      CUT_OUT_NULL=0;
1538   7                                              }
1539   6                                              break;
1540   6                      
1541   6                                              case (char)(0x0):
1542   6                                              {
1543   7                                                      if(CUT_OUT_NULL==1)       //если после 0xD7-пропускаем
1544   7                                                      {
1545   8                                                              CUT_OUT_NULL=0;         
1546   8                                                      }
1547   7                                                      else
1548   7                                                      {
1549   8                                                              RecieveBuf[recieve_count]=rngbuf.buf[i];
1550   8                                                              recieve_count++;        
1551   8                                                      }
1552   7                                              }
1553   6                                              break;
1554   6                      
1555   6                                              //---------MD ASCII------
1556   6      //                                      case  0x3A:      //":"
1557   6      //                                      {
1558   6      //                                              RecieveBuf[recieve_count]=symbol;
1559   6      //                                              recieve_count++;
1560   6      //                                              protocol_type=PROTO_TYPE_MODBUS_ASCII;                                                           
1561   6      //                                      }
1562   6      //                                      break;
1563   6      //              
1564   6      //                                      case 0xA:        //"LF"
1565   6      //                                      {
1566   6      //                                              ES=0;
1567   6      //                                              REN=0;  //recieve disable 
1568   6      //                                      }
1569   6      //                                      break;
1570   6      //              
1571   6      //                                      case 0xD:        //"CR"
1572   6      //                                      {
1573   6      //                                              //
1574   6      //                                      }
1575   6      //                                      break;
1576   6                                              //-----------------------
1577   6                      
1578   6                                              default :
1579   6                                              {
1580   7                                                      RecieveBuf[recieve_count]=rngbuf.buf[i];
1581   7                                                      recieve_count++;
1582   7                                                      CUT_OUT_NULL=0;         
1583   7                                              }
1584   6                                      }
C51 COMPILER V9.00   PROTO_USO                                                             06/23/2014 10:13:56 PAGE 27  

1585   5                      
1586   5                                 if(recieve_count>6)
1587   5                                 {
1588   6                                                if(recieve_count==6+frame_len)          // принимаем указанное в frame_len число байт данные, 6 значит 
             -что обмен идет с компом, надо ставаить 5 чтобы обмениваться с устройствами
1589   6                                                {
1590   7                                                              RECIEVED=1;//буфер принят
1591   7                                                              ES=0;
1592   7                                                              rngbuf.tail=0;
1593   7                                                              REN=0;  //recieve disable -запрещаем принимать в буфер  
1594   7                                                              CUT_OUT_NULL=0;                                                 
1595   7                                                }       
1596   6                                 }
1597   5                                 else
1598   5                                 {
1599   6                                                 if(recieve_count==6)
1600   6                                                 {     
1601   7                                                      
1602   7                                                              frame_len=RecieveBuf[recieve_count-1];  // получаем длину данных после заголовка
1603   7                                                              if(protocol_type==PROTO_TYPE_OLD)
1604   7                                                              {
1605   8                                                                      frame_len&=0x1F;//в старом протоколе только 5 младших бит -длина оставшейся части       
1606   8                                                              }                                        
1607   7                                                 }                    
1608   6                                 }                                                                                                            
1609   5                      }
1610   4      
1611   4      //              if(frame_count==0x0)//кадр пуст
1612   4      //              {
1613   4      //              }
1614   4      //              else
1615   4      //              {
1616   4      //              }               
1617   4        }
1618   3      
1619   3        PT_END(pt);
1620   1       }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   8055    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    943       1
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      1       2
   IDATA SIZE       =      3    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
