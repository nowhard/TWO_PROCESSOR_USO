C51 COMPILER V9.00   PROTO_USO                                                             06/24/2014 12:53:23 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE PROTO_USO
OBJECT MODULE PLACED IN proto_uso.obj
COMPILER INVOKED BY: C:\Program Files\Keil\C51\BIN\C51.EXE proto_uso\proto_uso.c LARGE OPTIMIZE(6,SPEED) BROWSE ORDER NO
                    -AREGS DEBUG OBJECTEXTEND PRINT(.\proto_uso.lst) OBJECT(proto_uso.obj)

line level    source

   1          #include "proto_uso.h"
   2          #include "calibrate\calibrate.h"
   3          #include "i2c.h"
   4          #include <intrins.h>
   5          #include "crc_table.h"
   6          #include "channels.h"
   7          #include "watchdog.h"
   8          #include "modbus\modbus_ascii.h"
   9          //-----------------------------------------------------------------------------------
  10          
  11          sbit DE_RE=P3^5;
  12          
  13          //-----------------------------------------------------------------------------------
  14          unsigned char xdata DEV_NAME[DEVICE_NAME_LENGTH_SYM] ="<<uUSO_2>>"; //имя устройства
  15          unsigned char xdata NOTICE[DEVICE_DESC_MAX_LENGTH_SYM]="<-- GEOSPHERA_2012 -->";//примечание    
  16          unsigned char xdata VERSION[DEVICE_VER_LENGTH_SYM] ="\x30\x30\x30\x30\x31";     // версия программы ПЗУ не бол
             -ьше 5 байт
  17          
  18          unsigned char xdata ADRESS_DEV=0x1;
  19          
  20          unsigned char xdata dev_desc_len=20;//длина описания устройства
  21          //--------------------------------global variable------------------------------------
  22          unsigned char xdata     RECIEVED=0;//принято
  23          unsigned int  xdata recieve_count;//счетчик приемного буфера
  24          unsigned char xdata     transf_count;//счетчик передаваемых байтов         
  25          unsigned char xdata     buf_len;//длина передаваемого буфера
  26          
  27          //------------------------флаги ошибок--------------------------------
  28          
  29          unsigned char xdata frame_len=0;//длина кадра, которую вытаскиваем из шестого байта кадра
  30          //--------------------------------------------------------------------
  31          unsigned char xdata  RecieveBuf[MAX_LENGTH_REC_BUF]={0} ; //буфер принимаемых данных
  32          //volatile unsigned char xdata                  *TransferBuf;
  33          unsigned char xdata  TransferBuf[MAX_LENGTH_TR_BUF]={0} ; //буфер передаваемых данных
  34          //--------------------------------------------------------------------
  35          volatile unsigned char xdata  STATE_BYTE=0xC0;//байт состояния устройства
  36          unsigned char xdata protocol_type=PROTO_TYPE_NEW;//тип протокола
  37          
  38          volatile struct pt pt_proto, pt_buf_handle;
  39          
  40          volatile struct RingBuf rngbuf;
  41          //-----------------------------------------------------------------------------------
  42          union //объединение для конвертирования char->long
  43          {
  44                  float result_float;
  45                  unsigned char result_char[4];
  46          }
  47          sym_8_to_float;
  48          
  49          extern unsigned char idata i2c_buffer[6];
  50          extern unsigned char channel_number;//количество каналов
  51          
  52          
  53          //-----------------------------------------------------------------------------------
C51 COMPILER V9.00   PROTO_USO                                                             06/24/2014 12:53:23 PAGE 2   

  54          //#pragma OT(0,Speed)
  55          void UART_ISR(void) interrupt 4 //using 1
  56          {       
  57   1              EA=0;   //запрет прерывания
  58   1              
  59   1              if(RI)
  60   1              {
  61   2                      RI=0; 
  62   2                      rngbuf.buf[rngbuf.tail]=SBUF;
  63   2                      rngbuf.tail++;
  64   2                      rngbuf.count++;                                                                         
  65   2              }
  66   1      //----------------------------передача-----------------------------------------------
  67   1              if(TI)
  68   1              {
  69   2                      TI=0;
  70   2                       
  71   2                      if(transf_count<buf_len)
  72   2                      {
  73   3      
  74   3                                      SBUF=TransferBuf[transf_count];                 
  75   3                                      transf_count++;
  76   3                      }
  77   2                      else
  78   2                      {
  79   3                              transf_count=0;         //обнуляем счетчик
  80   3                              PT_RESTART_OUT(pt_proto);  //внепроцессный рестарт                      
  81   3                      }                                          
  82   2              }                       
  83   1              EA=1;
  84   1              return;
  85   1      }
  86          //------------------------------------------------------------------------------
  87          //#pragma OT(6,Speed)
  88          void Protocol_Init(void) //using 0
  89          {
  90   1              TI=0;
  91   1              RI=0;
  92   1              
  93   1      
  94   1              Restore_Dev_Address_Desc();
  95   1      
  96   1              rngbuf.tail=0;
  97   1              rngbuf.head=0;
  98   1              rngbuf.count=0;
  99   1      
 100   1              recieve_count=0x0;//счетчик буфера приема
 101   1              transf_count=0x0;//счетчик передаваемых байтов
 102   1              buf_len=0x0;//длина передаваемого буфера
 103   1              DE_RE=0;//линия на прием
 104   1              //CUT_OUT_NULL=0;
 105   1              STATE_BYTE=0xC0;
 106   1              PT_INIT(&pt_proto);
 107   1              PT_INIT(&pt_buf_handle);
 108   1              return;
 109   1      }
 110          //-----------------------------------------------------------------------------
 111          unsigned char Send_Info(void) //using 0    //посылка информации об устройстве
 112          {
 113   1                  unsigned char    i=0;
 114   1                                                                                      
 115   1                 //заголовок кадра---
C51 COMPILER V9.00   PROTO_USO                                                             06/24/2014 12:53:23 PAGE 3   

 116   1                 TransferBuf[0]=0x00;
 117   1                 TransferBuf[1]=0xD7;
 118   1                 TransferBuf[2]=0x29;
 119   1                 //------------------
 120   1                 TransferBuf[3]=ADRESS_DEV;  // адрес узла
 121   1                 TransferBuf[4]=GET_DEV_INFO_RESP;  // код операции
 122   1                 TransferBuf[6]=STATE_BYTE;
 123   1      
 124   1                 for(i=0;i<20;i++)
 125   1                 {                              // записываем наименование изделия
 126   2                                 if(i<DEVICE_NAME_LENGTH_SYM)
 127   2                                 {
 128   3                                      TransferBuf[i+7]=DEV_NAME[i];
 129   3                                 }
 130   2                                 else
 131   2                                 {
 132   3                                              TransferBuf[i+7]=0x00;
 133   3                                 }
 134   2                      }
 135   1              
 136   1                 for(i=0;i<5;i++)                   // записываем версию ПЗУ
 137   1                 {
 138   2                     if(i<DEVICE_VER_LENGTH_SYM)
 139   2                         {
 140   3                               TransferBuf[i+27]=VERSION[i];
 141   3                         }
 142   2                 }
 143   1      
 144   1                 TransferBuf[32]=channel_number;                 // количество каналов
 145   1      
 146   1                 for(i=0;i<channel_number;i++)                                   // данные по каналу
 147   1             {
 148   2                              TransferBuf[i*2+33]=((channels[i].settings.set.type)<<4)|channels[i].settings.set.modific; // байт да
             -нных
 149   2                              TransferBuf[i*2+33+1]=0x00;                                                     // резерв байт
 150   2                 }    
 151   1                 for(i=0;i<dev_desc_len;i++)                                  // записываем примечание
 152   1                 {
 153   2                               TransferBuf[i+33+channel_number*2]=NOTICE[i];
 154   2                 }
 155   1                              
 156   1                 TransferBuf[5]=28+channel_number*2+dev_desc_len;                     // подсчет длины данных 
 157   1                 TransferBuf[33+channel_number*2+dev_desc_len]=CRC_Check(&TransferBuf[1],32+channel_number*2+dev_desc_l
             -en); // подсчет контрольной суммы
 158   1      
 159   1              return (34+channel_number*2+dev_desc_len);
 160   1      }
 161          //-----------------------------------------------------------------------------
 162          unsigned char Node_Full_Init(void) //using 0 //полная инициализация узла
 163          {
 164   1              return 0;
 165   1      }
 166          //-----------------------------------------------------------------------------
 167          unsigned char Channel_List_Init(void) //using 0 //Инициализация списка каналов узла (без потери данных);
 168          {
 169   1              return 0;
 170   1      }
 171          //-----------------------------------------------------------------------------
 172          unsigned char Channel_Get_Data(void) //using 0 //Выдать данные по каналам, согласно абсолютной нумерации;
 173          {
 174   1              return 0;
 175   1      }
C51 COMPILER V9.00   PROTO_USO                                                             06/24/2014 12:53:23 PAGE 4   

 176          //-----------------------------------------------------------------------------
 177          unsigned char  Channel_Set_Parameters(void) //using 0 //Установить параметры по каналам, согласно абсолютн
             -ой нумерации;
 178          {
 179   1             unsigned char  index=0, store_data=0;//i=0;
 180   1               
 181   1                 while(index<RecieveBuf[5]-1)                            // данные по каналам
 182   1                    {
 183   2                                      if(RecieveBuf[6+index]<channel_number)
 184   2                                  {
 185   3                                              switch((RecieveBuf[6+index+1]>>4)&0xF)
 186   3                                              {
 187   4                                                              case CHNL_ADC://АЦП
 188   4                                                              {
 189   5                                                                      if((channels[RecieveBuf[6+index]].settings.set.modific!=RecieveBuf[6+index+1])||(channels[RecieveB
             -uf[6+index]].settings.set.state_byte_1!=RecieveBuf[6+index+2]) || (channels[RecieveBuf[6+index]].settings.set.state_byte
             -_2!=RecieveBuf[6+index+3]))
 190   5                                                                      {  
 191   6                                                                              channels[RecieveBuf[6+index]].settings.set.state_byte_1=RecieveBuf[6+index+2];
 192   6                                                                              channels[RecieveBuf[6+index]].settings.set.state_byte_2=RecieveBuf[6+index+3];
 193   6                                                                              channels[RecieveBuf[6+index]].settings.set.modific         =RecieveBuf[6+index+1]&0xF;
 194   6                                                                              store_data=1;
 195   6                                                                              
 196   6                                                                      }
 197   5                                                                      index++;
 198   5                                                              }
 199   4                                                              break;
 200   4      
 201   4      
 202   4                                                              default :
 203   4                                                              {
 204   5                                                                      _nop_();
 205   5                                                              }                       
 206   4                                              }
 207   3                                              index=index+3;
 208   3                                      }
 209   2                                      else
 210   2                                      {
 211   3                                              return Request_Error(FR_UNATTENDED_CHANNEL);
 212   3                                      }
 213   2                        }
 214   1                 if(store_data)
 215   1                 {
 216   2                              Store_Channels_Data();  //сохраним настройки каналов в ППЗУ
 217   2                 }
 218   1      
 219   1                 return Request_Error(FR_SUCCESFUL);
 220   1      }
 221          //-----------------------------------------------------------------------------
 222          unsigned char Channel_Set_Order_Query(void) //using 0 //Задать последовательность опроса;
 223          {
 224   1              return 0;
 225   1      }
 226          //-----------------------------------------------------------------------------
 227          unsigned char Channel_Get_Data_Order(void) //using 0 //Выдать данные по каналам, согласно последовательнос
             -ти опроса;
 228          {
 229   1              return 0;
 230   1      }
 231          //-----------------------------------------------------------------------------
 232          unsigned char Channel_Set_State(void) //using 0 //Установить состояния по каналам, согласно абсолютной нум
             -ерации;
C51 COMPILER V9.00   PROTO_USO                                                             06/24/2014 12:53:23 PAGE 5   

 233          {
 234   1              return 0;
 235   1      }
 236          //-----------------------------------------------------------------------------
 237          unsigned char  Channel_Get_Data_Order_M2(void) //using 0 //Выдать данные по каналам, согласно последовател
             -ьности опроса;
 238          {
 239   1              return 0;
 240   1      }
 241          //-----------------------------------------------------------------------------
 242          unsigned char Channel_Set_Reset_State_Flags(void) //using 0 //  Установка/Сброс флагов состояния 
 243          {
 244   1              STATE_BYTE=0x40;
 245   1              i2c_buffer[0]=SLAVE_STATE_BYTE_RESET;//сбросим флаг инициализации ведомого
 246   1              ChannelsInit();
 247   1              return  Request_Error(FR_SUCCESFUL);//ошибки нет, подтверждение
 248   1      }
 249          //-----------------------------------------------------------------------------
 250          #pragma OT(9,Speed)
 251          unsigned char Channel_All_Get_Data(void) //using 0 //Выдать информацию по всем каналам узла (расширенный р
             -ежим);
 252          {
 253   1         unsigned char data index=0,i=0;
 254   1      
 255   1      
 256   1         TransferBuf[0]=0x00;TransferBuf[1]=0xD7;TransferBuf[2]=0x29;
 257   1         TransferBuf[3]=ADRESS_DEV;  // адрес узла
 258   1         TransferBuf[4]=CHANNEL_ALL_GET_DATA_RESP;  // код операции
 259   1         TransferBuf[6]=STATE_BYTE;
 260   1      
 261   1         index=7;//длина заголовка
 262   1       
 263   1          for(i=0;i<channel_number;i++)                                  // данные по каналам
 264   1          {
 265   2                        TransferBuf[index++]=i;
 266   2                        TransferBuf[index++]=((channels[i].settings.set.type)<<4)|channels[i].settings.set.modific; // тип и м
             -одификация канала
 267   2                        switch(channels[i].settings.set.type)
 268   2                          {
 269   3                                       case CHNL_ADC:  //аналоговый канал
 270   3                                       {
 271   4                                               switch(channels[i].settings.set.modific)
 272   4                               {
 273   5                                                        case CHNL_ADC_FIX_16:
 274   5                                                        {
 275   6                                                                      if(channels[i].calibrate.cal.calibrate==1)//калиброванный
 276   6                                                                      {                                                
 277   7                                                                                      TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data_calibrate))[2];
 278   7                                                                              TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data_calibrate))[1];
 279   7                                                                      }
 280   6                                                                      else
 281   6                                                                      {
 282   7                                                                                      TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data))[2];
 283   7                                                                              TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data))[1];  
 284   7                                                                      } 
 285   6      
 286   6                                                                        
 287   6                                                                       TransferBuf[index++]=channels[i].settings.set.state_byte_1;     // первый байт состояния канала
 288   6                                               TransferBuf[index++]=channels[i].settings.set.state_byte_2;     // второй байт сос
             -тояния канала
 289   6                                                        }
 290   5                                                        break; 
C51 COMPILER V9.00   PROTO_USO                                                             06/24/2014 12:53:23 PAGE 6   

 291   5      
 292   5                                                        case CHNL_ADC_FIX_24:
 293   5                                                        {
 294   6                                                              if(channels[i].calibrate.cal.calibrate==1)//калиброванный
 295   6                                                                      {                                                                                                 
 296   7                                                                                      TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data_calibrate))[3];
 297   7                                                                                      TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data_calibrate))[2];
 298   7                                                                              TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data_calibrate))[1];
 299   7                                                                      }
 300   6                                                                      else
 301   6                                                                      {                                                                        
 302   7                                                                                      TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data))[3];
 303   7                                                                                      TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data))[2];
 304   7                                                                              TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data))[1];  
 305   7                                                                      } 
 306   6                        
 307   6                                                                        TransferBuf[index++]=channels[i].settings.set.state_byte_1;    // первый байт состояния канала
 308   6                                                TransferBuf[index++]=channels[i].settings.set.state_byte_2;    // второй байт со
             -стояния канала
 309   6                                                        }
 310   5                                                        break;
 311   5                                                }
 312   4                                        }
 313   3                                        break;
 314   3      
 315   3                                      case CHNL_DOL:   //ДОЛ
 316   3                                      {
 317   4                                                switch(channels[i].settings.set.modific)
 318   4                                            {   
 319   5                                                                case CHNL_DOL_ENC:
 320   5                                                                {
 321   6                                                                                      TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data))[3];
 322   6                                                                                      TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data))[2];
 323   6                                                                              TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data))[1];
 324   6                                                                                      TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data))[0];
 325   6                                                                                  TransferBuf[index++]=channels[i].settings.set.state_byte_1;  // первый байт состояния канала
 326   6                                                                }
 327   5                                                                break; 
 328   5                                                 }
 329   4                                      }
 330   3                                      break;
 331   3      
 332   3                                       case CHNL_FREQ: //частотный
 333   3                                       { 
 334   4                                                switch(channels[i].settings.set.modific)
 335   4                                            {   
 336   5                                                                
 337   5                                                                case CHNL_FREQ_COUNT_T:
 338   5                                                                {
 339   6                                                                                      TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data))[3];
 340   6                                                                                      TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data))[2];
 341   6                                                                                TransferBuf[index++]=channels[i].settings.set.state_byte_1;    // первый байт состояния канала
 342   6                                                                }
 343   5                                                                break;
 344   5      
 345   5                                                                case CHNL_FREQ_256:
 346   5                                                                {
 347   6                                                                                      TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data))[3];
 348   6                                                                                      TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data))[2];
 349   6                                                                                  TransferBuf[index++]=channels[i].settings.set.state_byte_1;  // первый байт состояния канала
 350   6                                                                }
 351   5                                                                break; 
C51 COMPILER V9.00   PROTO_USO                                                             06/24/2014 12:53:23 PAGE 7   

 352   5                                                 }
 353   4                                        }
 354   3                                        break;                 
 355   3                        }
 356   2                 }
 357   1      
 358   1                TransferBuf[5]=index+2-7;                                              // подсчет длины данных двойка это 1(байт статуса)+1(контрольная сумма
             -)
 359   1                TransferBuf[index]=CRC_Check(&TransferBuf[1],(unsigned int)(index)-1); // подсчет кс
 360   1                return (unsigned char)(index+1);
 361   1      }
 362          //-----------------------------------------------------------------------------
 363          #pragma OT(0,Speed)
 364          unsigned char Channel_Set_Calibrate(void)//установить верхнюю или нижнюю точку калибровки
 365          {
 366   1      
 367   1              float K,C;      
 368   1      
 369   1              sym_8_to_float.result_char[0]=RecieveBuf[11];
 370   1              sym_8_to_float.result_char[1]=RecieveBuf[10];
 371   1              sym_8_to_float.result_char[2]=RecieveBuf[9];
 372   1              sym_8_to_float.result_char[3]=RecieveBuf[8];
 373   1      
 374   1              K=sym_8_to_float.result_float;
 375   1      
 376   1              sym_8_to_float.result_char[0]=RecieveBuf[15];
 377   1              sym_8_to_float.result_char[1]=RecieveBuf[14];
 378   1              sym_8_to_float.result_char[2]=RecieveBuf[13];
 379   1              sym_8_to_float.result_char[3]=RecieveBuf[12];
 380   1      
 381   1              C=sym_8_to_float.result_float;
 382   1      
 383   1              switch(RecieveBuf[7])
 384   1              {
 385   2                      case 0:
 386   2                      {
 387   3                              Calibrate(RecieveBuf[6],K,C);   
 388   3                      }
 389   2                      break;
 390   2      
 391   2                      case 1:
 392   2                      {
 393   3                              Calibrate_Set_Flag(RecieveBuf[6],RESET);
 394   3                      }
 395   2                      break;
 396   2      
 397   2                      case 2:
 398   2                      {
 399   3                              Calibrate_Set_Flag(RecieveBuf[6],SET);  
 400   3                      }
 401   2                      break;
 402   2      
 403   2                      default :
 404   2                      {
 405   3                              _nop_();
 406   3                      }
 407   2                      break;
 408   2              }
 409   1      
 410   1      
 411   1              return  Request_Error(FR_SUCCESFUL);//ошибки нет, подтверждение 
 412   1      }
C51 COMPILER V9.00   PROTO_USO                                                             06/24/2014 12:53:23 PAGE 8   

 413          //------------------------------------------------------------------------------
 414          unsigned char Channel_Get_Calibrate_Value(void)//получить коэфициенты калибровки заданного канала
 415          {
 416   1         unsigned char data channel=0;
 417   1      
 418   1      
 419   1         TransferBuf[0]=0x00;TransferBuf[1]=0xD7;TransferBuf[2]=0x29;
 420   1         TransferBuf[3]=ADRESS_DEV;  // адрес узла
 421   1         TransferBuf[4]=CHANNEL_GET_CALIBRATE_RESP;  // код операции
 422   1         TransferBuf[5]=0xB;//длина оставшейся части кадра
 423   1      
 424   1      
 425   1         channel=RecieveBuf[6];
 426   1      
 427   1         if(channel>=channel_number)
 428   1         {
 429   2                      return Request_Error(FR_COMMAND_STRUCT_ERROR);//непрвильный номер канала        
 430   2         }
 431   1      
 432   1         TransferBuf[6]=channel;
 433   1      
 434   1         TransferBuf[7]=channels[channel].calibrate.cal.calibrate;
 435   1      
 436   1         sym_8_to_float.result_float=channels[channel].calibrate.cal.K;
 437   1      
 438   1              TransferBuf[11]=sym_8_to_float.result_char[0];
 439   1              TransferBuf[10]=sym_8_to_float.result_char[1];
 440   1              TransferBuf[9]=sym_8_to_float.result_char[2];
 441   1              TransferBuf[8]=sym_8_to_float.result_char[3];
 442   1      
 443   1         sym_8_to_float.result_float=channels[channel].calibrate.cal.C;
 444   1      
 445   1              TransferBuf[15]=sym_8_to_float.result_char[0];
 446   1              TransferBuf[14]=sym_8_to_float.result_char[1];
 447   1              TransferBuf[13]=sym_8_to_float.result_char[2];
 448   1              TransferBuf[12]=sym_8_to_float.result_char[3];
 449   1      
 450   1              TransferBuf[16]=CRC_Check(&TransferBuf[1],15); // подсчет кс
 451   1              return 0x11;//17        
 452   1      }
 453          //------------------------------------------------------------------------------
 454          unsigned char Channel_Set_Address_Desc(void)//установить новый адрес устройства, имя, описание, версию про
             -шивки и комментарий
 455          {
 456   1              unsigned char  desc_len=0;
 457   1              desc_len=RecieveBuf[5]-27;
 458   1      
 459   1              if(desc_len)
 460   1              {       
 461   2                      Store_Dev_Address_Desc(RecieveBuf[6],&RecieveBuf[7],&RecieveBuf[27],&RecieveBuf[32],desc_len);
 462   2                      return    Request_Error(FR_SUCCESFUL);//ошибки нет, подтверждение
 463   2              }
 464   1              else
 465   1              {
 466   2                      return Request_Error(FR_COMMAND_STRUCT_ERROR);
 467   2              }
 468   1              return 0;
 469   1      }
 470          //-----------------------------------------------------------------------------
 471          unsigned char Channel_Set_All_Default(void)//установить настройки и калибровки каналов по умолчанию
 472          {
 473   1              Channels_Set_Default();
C51 COMPILER V9.00   PROTO_USO                                                             06/24/2014 12:53:23 PAGE 9   

 474   1              Calibrate_Set_Default();
 475   1              return  Request_Error(FR_SUCCESFUL);//ошибки нет, подтверждение         
 476   1      }
 477          //-----------------------------------------------------------------------------
 478          unsigned char Request_Error(unsigned char error_code) //using 0 //      Ошибочный запрос/ответ;
 479          {
 480   1              TransferBuf[0]=0x00;TransferBuf[1]=0xD7;TransferBuf[2]=0x29;
 481   1          TransferBuf[3]=ADRESS_DEV;  // адрес узла
 482   1          TransferBuf[7]=RecieveBuf[4]; // код сбойной команды
 483   1          TransferBuf[4]=0xFF;  // код операции
 484   1      
 485   1              TransferBuf[6]=STATE_BYTE; // байт статуса узла
 486   1          TransferBuf[8]=error_code;   
 487   1          TransferBuf[5]=0x04;          // длина данных
 488   1          TransferBuf[9]=CRC_Check(TransferBuf,9);
 489   1              return 10;
 490   1      }
 491          
 492          //-----------------------------------------------------------------------------
 493          unsigned char Old_CRC_Check(unsigned char xdata *Spool_pr,unsigned char Count_pr)
 494          {
 495   1           unsigned char crc = 0x0;
 496   1               unsigned char i=0;
 497   1      
 498   1               for(i=0;i<Count_pr;i++)
 499   1               {
 500   2                      CY=0;
 501   2                      crc+=Spool_pr[i];
 502   2                      if(CY)
 503   2                      {
 504   3                              crc++;
 505   3                      }
 506   2               }
 507   1               crc=0xFF-crc;
 508   1      
 509   1           return crc;        
 510   1      }
 511          //-----------------------------------------------------------------------------
 512          unsigned char Old_Channel_Get_Data(void)
 513          {
 514   1        unsigned char channel=0;
 515   1        unsigned char len=0;
 516   1        channel=((RecieveBuf[4]>>3)&0x1F);
 517   1        if(channel<CHANNEL_NUMBER)
 518   1        {  
 519   2                 TransferBuf[0]=0x00;TransferBuf[1]=0xD7;TransferBuf[2]=0x28;
 520   2                 TransferBuf[3]=0x0;  // 
 521   2                 TransferBuf[4]=RecieveBuf[4];
 522   2                 TransferBuf[5]=((OLD_CHANNEL_GET_DATA<<5)&0x1F)|0x3;//0x63;// код операции   
 523   2      
 524   2                              switch(channels[channel].settings.set.type)
 525   2                          {
 526   3                                       case CHNL_ADC:  //аналоговый канал
 527   3                                       {
 528   4                                               switch(channels[channel].settings.set.modific)
 529   4                               {
 530   5                                                        case CHNL_ADC_FIX_16:
 531   5                                                        {
 532   6                                                                      if(channels[channel].calibrate.cal.calibrate==1)//калиброванный
 533   6                                                                      {                                                
 534   7                                                                                      TransferBuf[6]=((unsigned char*)(&channels[channel].channel_data_calibrate))[1];
 535   7                                                                              TransferBuf[7]=((unsigned char*)(&channels[channel].channel_data_calibrate))[2];
C51 COMPILER V9.00   PROTO_USO                                                             06/24/2014 12:53:23 PAGE 10  

 536   7                                                                      }
 537   6                                                                      else
 538   6                                                                      {
 539   7                                                                                      TransferBuf[6]=((unsigned char*)(&channels[channel].channel_data))[1];
 540   7                                                                              TransferBuf[7]=((unsigned char*)(&channels[channel].channel_data))[2];  
 541   7                                                                      }                                       
 542   6                                                        }
 543   5                                                        break; 
 544   5      
 545   5                                                        case CHNL_ADC_FIX_24:
 546   5                                                        {
 547   6                                                              if(channels[channel].calibrate.cal.calibrate==1)//калиброванный
 548   6                                                                      {                                                                                                 
 549   7                                                                                      TransferBuf[channel]=((unsigned char*)(&channels[channel].channel_data_calibrate))[1];
 550   7                                                                              TransferBuf[channel]=((unsigned char*)(&channels[channel].channel_data_calibrate))[2];
 551   7                                                                      }
 552   6                                                                      else
 553   6                                                                      {                                                                        
 554   7                                                                                      TransferBuf[6]=((unsigned char*)(&channels[channel].channel_data))[1];
 555   7                                                                              TransferBuf[7]=((unsigned char*)(&channels[channel].channel_data))[2];  
 556   7                                                                      }
 557   6      
 558   6                                                        }
 559   5                                                        break;
 560   5                                                }                                       
 561   4                                        }
 562   3                                        break;
 563   3      
 564   3                                      case CHNL_DOL:   //ДОЛ
 565   3                                      {
 566   4                                                switch(channels[channel].settings.set.modific)
 567   4                                            {   
 568   5                                                                case CHNL_DOL_ENC:
 569   5                                                                {
 570   6                                                                                      TransferBuf[6]=((unsigned char*)(&channels[channel].channel_data))[2];
 571   6                                                                                      TransferBuf[7]=((unsigned char*)(&channels[channel].channel_data))[3];
 572   6      //                                                                      TransferBuf[channel]=((unsigned char*)(&channels[channel].channel_data))[0];
 573   6      //                                                                              TransferBuf[channel]=((unsigned char*)(&channels[channel].channel_data))[1];
 574   6                                                                }
 575   5                                                                break; 
 576   5                                                 }
 577   4                                      }
 578   3                                      break;
 579   3      
 580   3                                       case CHNL_FREQ: //частотный
 581   3                                       { 
 582   4                                                switch(channels[channel].settings.set.modific)
 583   4                                            {   
 584   5                                                                
 585   5                                                                case CHNL_FREQ_COUNT_T:
 586   5                                                                {
 587   6                                                                                      TransferBuf[6]=((unsigned char*)(&channels[channel].channel_data))[2];
 588   6                                                                                      TransferBuf[7]=((unsigned char*)(&channels[channel].channel_data))[3];
 589   6      
 590   6                                                                }
 591   5                                                                break;
 592   5      
 593   5                                                                case CHNL_FREQ_256:
 594   5                                                                {
 595   6                                                                                      TransferBuf[6]=((unsigned char*)(&channels[channel].channel_data))[2];
 596   6                                                                                      TransferBuf[7]=((unsigned char*)(&channels[channel].channel_data))[3];
 597   6                                                                }
C51 COMPILER V9.00   PROTO_USO                                                             06/24/2014 12:53:23 PAGE 11  

 598   5                                                                break; 
 599   5                                                 }                                       
 600   4                                        }
 601   3                                        break;                 
 602   3                        }
 603   2                 
 604   2                 len=Proto_Paste_Null(TransferBuf,8);
 605   2      
 606   2                 TransferBuf[len]=Old_CRC_Check(TransferBuf,len);
 607   2                 return len+1;
 608   2         }
 609   1         return 0;    
 610   1      }
 611          //-----------------------------------------------------------------------------
 612          unsigned char Old_Channel_Get_Data_State(void)
 613          {
 614   1        unsigned char channel=0;
 615   1        unsigned char len=0;
 616   1        channel=((RecieveBuf[4]>>3)&0x1F);
 617   1        if(channel<CHANNEL_NUMBER)
 618   1        {
 619   2                 TransferBuf[0]=0x00;TransferBuf[1]=0xD7;TransferBuf[2]=0x28;
 620   2                 TransferBuf[3]=0x0;  // 
 621   2                 TransferBuf[4]=RecieveBuf[4];
 622   2                 TransferBuf[5]=((OLD_CHANNEL_GET_DATA_STATE<<5)&0x1F)|0x6;//0x66;// код операции     
 623   2      
 624   2                              switch(channels[channel].settings.set.type)
 625   2                          {
 626   3                                       case CHNL_ADC:  //аналоговый канал
 627   3                                       {
 628   4                                               switch(channels[channel].settings.set.modific)
 629   4                               {
 630   5                                                        case CHNL_ADC_FIX_16:
 631   5                                                        {
 632   6                                                                      if(channels[channel].calibrate.cal.calibrate==1)//калиброванный
 633   6                                                                      {                                                
 634   7                                                                                      TransferBuf[6]=((unsigned char*)(&channels[channel].channel_data_calibrate))[1];
 635   7                                                                              TransferBuf[7]=((unsigned char*)(&channels[channel].channel_data_calibrate))[2];
 636   7                                                                      }
 637   6                                                                      else
 638   6                                                                      {
 639   7                                                                                      TransferBuf[6]=((unsigned char*)(&channels[channel].channel_data))[1];
 640   7                                                                              TransferBuf[7]=((unsigned char*)(&channels[channel].channel_data))[2];  
 641   7                                                                      }                                       
 642   6                                                        }
 643   5                                                        break; 
 644   5      
 645   5                                                        case CHNL_ADC_FIX_24:
 646   5                                                        {
 647   6                                                              if(channels[channel].calibrate.cal.calibrate==1)//калиброванный
 648   6                                                                      {                                                                                                 
 649   7                                                                                      TransferBuf[channel]=((unsigned char*)(&channels[channel].channel_data_calibrate))[1];
 650   7                                                                              TransferBuf[channel]=((unsigned char*)(&channels[channel].channel_data_calibrate))[2];
 651   7                                                                      }
 652   6                                                                      else
 653   6                                                                      {                                                                        
 654   7                                                                                      TransferBuf[6]=((unsigned char*)(&channels[channel].channel_data))[1];
 655   7                                                                              TransferBuf[7]=((unsigned char*)(&channels[channel].channel_data))[2];  
 656   7                                                                      }
 657   6      
 658   6                                                        }
 659   5                                                        break;
C51 COMPILER V9.00   PROTO_USO                                                             06/24/2014 12:53:23 PAGE 12  

 660   5                                                }
 661   4                                                
 662   4                                                switch(channels[channel].settings.set.state_byte_1&0x7)
 663   4                                                {
 664   5                                                              case PROTO_ADC_AMP_1:
 665   5                                                              {
 666   6                                                                      TransferBuf[8]=(0x00|(OLD_PROTO_ADC_AMP_1<<1))&0xFE;     // первый байт состояния канала
 667   6                                                              }
 668   5                                                              break;
 669   5      
 670   5                                                              case PROTO_ADC_AMP_2:
 671   5                                                              {
 672   6                                                                      TransferBuf[8]=(0x00|(OLD_PROTO_ADC_AMP_2<<1))&0xFE;     // первый байт состояния канала        
 673   6                                                              }
 674   5                                                              break;
 675   5      
 676   5                                                              case PROTO_ADC_AMP_32:
 677   5                                                              {
 678   6                                                                      TransferBuf[8]=(0x00|(OLD_PROTO_ADC_AMP_32<<1))&0xFE;    // первый байт состояния канала        
 679   6                                                              }
 680   5                                                              break;
 681   5      
 682   5                                                              case PROTO_ADC_AMP_128:
 683   5                                                              {
 684   6                                                                      TransferBuf[8]=(0x00|(OLD_PROTO_ADC_AMP_128<<1))&0xFE;   // первый байт состояния канала
 685   6                                                              }
 686   5                                                              break;
 687   5      
 688   5                                                              default :
 689   5                                                              {
 690   6                                                                      TransferBuf[8]=(0x00|(OLD_PROTO_ADC_AMP_1<<1))&0xFE;     // первый байт состояния канала
 691   6                                                              }
 692   5                                                              break;
 693   5                                                }
 694   4                                                
 695   4                                                TransferBuf[9]=0x0A;   // второй байт состояния канала
 696   4      
 697   4                                        }
 698   3                                        break;
 699   3      
 700   3                                case CHNL_DOL:         //ДОЛ
 701   3                                {
 702   4                                        switch(channels[channel].settings.set.modific)
 703   4                                    {   
 704   5                                                        case CHNL_DOL_ENC:
 705   5                                                        {
 706   6                                                                      TransferBuf[6]=((unsigned char*)(&channels[channel].channel_data))[2];
 707   6                                                                      TransferBuf[7]=((unsigned char*)(&channels[channel].channel_data))[3];
 708   6      //                                                                      TransferBuf[channel]=((unsigned char*)(&channels[channel].channel_data))[0];
 709   6      //                                                                              TransferBuf[channel]=((unsigned char*)(&channels[channel].channel_data))[1];
 710   6      
 711   6                                                                      
 712   6      
 713   6                                                                      switch(channels[channel].settings.set.state_byte_1&0x7)
 714   6                                                                      {
 715   7                                                                                      case PROTO_ADC_AMP_1:
 716   7                                                                                      {
 717   8                                                                                              TransferBuf[8]=(0x40|(OLD_PROTO_ADC_AMP_1<<1))&0xFE;     // первый байт состояния канала
 718   8                                                                                      }
 719   7                                                                                      break;
 720   7                              
 721   7                                                                                      case PROTO_ADC_AMP_2:
C51 COMPILER V9.00   PROTO_USO                                                             06/24/2014 12:53:23 PAGE 13  

 722   7                                                                                      {
 723   8                                                                                              TransferBuf[8]=(0x40|(OLD_PROTO_ADC_AMP_2<<1))&0xFE;     // первый байт состояния канала        
 724   8                                                                                      }
 725   7                                                                                      break;
 726   7                              
 727   7                                                                                      case PROTO_ADC_AMP_32:
 728   7                                                                                      {
 729   8                                                                                              TransferBuf[8]=(0x40|(OLD_PROTO_ADC_AMP_32<<1))&0xFE;    // первый байт состояния канала        
 730   8                                                                                      }
 731   7                                                                                      break;
 732   7                              
 733   7                                                                                      case PROTO_ADC_AMP_128:
 734   7                                                                                      {
 735   8                                                                                              TransferBuf[8]=(0x40|(OLD_PROTO_ADC_AMP_128<<1))&0xFE;   // первый байт состояния канала
 736   8                                                                                      }
 737   7                                                                                      break;
 738   7                              
 739   7                                                                                      default :
 740   7                                                                                      {
 741   8                                                                                              TransferBuf[8]=(0x40|(OLD_PROTO_ADC_AMP_1<<1))&0xFE;
 742   8                                                                                      }
 743   7                                                                                      break;                  
 744   7                                                                      }
 745   6                                                                      TransferBuf[9]=0x00;     // второй байт состояния канала
 746   6                                                        }
 747   5                                                        break; 
 748   5                                                 }
 749   4                                      }
 750   3                                      break;
 751   3      
 752   3                                       case CHNL_FREQ: //частотный
 753   3                                       { 
 754   4                                                switch(channels[channel].settings.set.modific)
 755   4                                            {   
 756   5                                                                
 757   5                                                                case CHNL_FREQ_COUNT_T:
 758   5                                                                {
 759   6                                                                                      TransferBuf[6]=((unsigned char*)(&channels[channel].channel_data))[2];
 760   6                                                                                      TransferBuf[7]=((unsigned char*)(&channels[channel].channel_data))[3];
 761   6      
 762   6                                                                }
 763   5                                                                break;
 764   5      
 765   5                                                                case CHNL_FREQ_256:
 766   5                                                                {
 767   6                                                                                      TransferBuf[6]=((unsigned char*)(&channels[channel].channel_data))[2];
 768   6                                                                                      TransferBuf[7]=((unsigned char*)(&channels[channel].channel_data))[3];
 769   6                                                                }
 770   5                                                                break; 
 771   5                                                 }
 772   4                                                 
 773   4                                              TransferBuf[8]=0x40;     // первый байт состояния канала
 774   4                                      TransferBuf[9]=0x00;     // второй байт состояния канала
 775   4                                        }
 776   3                                        break;                 
 777   3                        }
 778   2      
 779   2                 TransferBuf[10]=0xFF;
 780   2      
 781   2                 len=Proto_Paste_Null(TransferBuf,11);
 782   2      
 783   2                 TransferBuf[len]=Old_CRC_Check(TransferBuf,len);
C51 COMPILER V9.00   PROTO_USO                                                             06/24/2014 12:53:23 PAGE 14  

 784   2                 return len+1;
 785   2         }
 786   1         return 0;
 787   1      
 788   1      }
 789          //-----------------------------------------------------------------------------
 790          unsigned char Old_Channel_Get_State(void)
 791          {
 792   1        unsigned char channel=0;
 793   1        unsigned char len=0;
 794   1        channel=((RecieveBuf[4]>>3)&0x1F);
 795   1        if(channel<CHANNEL_NUMBER)
 796   1        {
 797   2        
 798   2                 TransferBuf[0]=0x00;TransferBuf[1]=0xD7;TransferBuf[2]=0x28;
 799   2                 TransferBuf[3]=0x0;  // 
 800   2                 TransferBuf[4]=RecieveBuf[4];
 801   2                 TransferBuf[5]=((OLD_CHANNEL_GET_STATE<<5)&0x1F)|0x3;//0x43;// код операции  
 802   2      
 803   2                              switch(channels[channel].settings.set.type)
 804   2                          {
 805   3                                       case CHNL_ADC:  //аналоговый канал
 806   3                                       {                
 807   4                                                switch(channels[channel].settings.set.state_byte_1&0x7)
 808   4                                                {
 809   5                                                              case PROTO_ADC_AMP_1:
 810   5                                                              {
 811   6                                                                      TransferBuf[6]=0x00|(OLD_PROTO_ADC_AMP_1<<1);    // первый байт состояния канала
 812   6                                                              }
 813   5                                                              break;
 814   5      
 815   5                                                              case PROTO_ADC_AMP_2:
 816   5                                                              {
 817   6                                                                      TransferBuf[6]=0x00|(OLD_PROTO_ADC_AMP_2<<1);    // первый байт состояния канала        
 818   6                                                              }
 819   5                                                              break;
 820   5      
 821   5                                                              case PROTO_ADC_AMP_32:
 822   5                                                              {
 823   6                                                                      TransferBuf[6]=0x00|(OLD_PROTO_ADC_AMP_32<<1);   // первый байт состояния канала        
 824   6                                                              }
 825   5                                                              break;
 826   5      
 827   5                                                              case PROTO_ADC_AMP_128:
 828   5                                                              {
 829   6                                                                      TransferBuf[6]=0x00|(OLD_PROTO_ADC_AMP_128<<1);  // первый байт состояния канала
 830   6                                                              }
 831   5                                                              break;
 832   5      
 833   5                                                              default :
 834   5                                                              {
 835   6                                                                      TransferBuf[6]=0x00|(OLD_PROTO_ADC_AMP_1<<1);    // первый байт состояния канала
 836   6                                                              }
 837   5                                                              break;
 838   5                                                }
 839   4                                                
 840   4                                                TransferBuf[7]=0x0A;   // второй байт состояния канала
 841   4                                        }
 842   3                                        break;
 843   3      
 844   3                                      case CHNL_DOL:   //ДОЛ
 845   3                                      {
C51 COMPILER V9.00   PROTO_USO                                                             06/24/2014 12:53:23 PAGE 15  

 846   4      
 847   4                                                      switch(channels[channel].settings.set.state_byte_1&0x7)
 848   4                                                      {
 849   5                                                                      case PROTO_ADC_AMP_1:
 850   5                                                                      {
 851   6                                                                              TransferBuf[6]=0x40|(OLD_PROTO_ADC_AMP_1<<1);    // первый байт состояния канала
 852   6                                                                      }
 853   5                                                                      break;
 854   5              
 855   5                                                                      case PROTO_ADC_AMP_2:
 856   5                                                                      {
 857   6                                                                              TransferBuf[6]=0x40|(OLD_PROTO_ADC_AMP_2<<1);    // первый байт состояния канала        
 858   6                                                                      }
 859   5                                                                      break;
 860   5              
 861   5                                                                      case PROTO_ADC_AMP_32:
 862   5                                                                      {
 863   6                                                                              TransferBuf[6]=0x40|(OLD_PROTO_ADC_AMP_32<<1);   // первый байт состояния канала        
 864   6                                                                      }
 865   5                                                                      break;
 866   5              
 867   5                                                                      case PROTO_ADC_AMP_128:
 868   5                                                                      {
 869   6                                                                              TransferBuf[6]=0x40|(OLD_PROTO_ADC_AMP_128<<1);  // первый байт состояния канала
 870   6                                                                      }
 871   5                                                                      break;
 872   5              
 873   5                                                                      default :
 874   5                                                                      {
 875   6                                                                              TransferBuf[6]=0x40;     // первый байт состояния канала
 876   6                                                                      }
 877   5                                                                      break;
 878   5              
 879   5                                                      }
 880   4                                                      TransferBuf[7]=0x00;     // второй байт состояния канала
 881   4                                      }
 882   3                                      break;
 883   3      
 884   3                                       case CHNL_FREQ: //частотный
 885   3                                       { 
 886   4                                                 
 887   4                                              TransferBuf[6]=0x40;     // первый байт состояния канала
 888   4                                      TransferBuf[7]=0x00;     // второй байт состояния канала
 889   4                                       }
 890   3                                       break;          
 891   3                        }
 892   2                 
 893   2                 len=Proto_Paste_Null(TransferBuf,8);
 894   2      
 895   2                 TransferBuf[len]=Old_CRC_Check(TransferBuf,len);
 896   2                 return len+1;
 897   2         }
 898   1         return 0;    
 899   1      }
 900          //-----------------------------------------------------------------------------
 901          unsigned char Old_Reinit_Block(void)
 902          {
 903   1              return 0;       
 904   1      }
 905          //-----------------------------------------------------------------------------
 906          unsigned char Old_Channel_Set_ADC_Range(void)
 907          {
C51 COMPILER V9.00   PROTO_USO                                                             06/24/2014 12:53:23 PAGE 16  

 908   1        unsigned char channel=0;
 909   1        channel=((RecieveBuf[4]>>3)&0x1F);
 910   1        if(channel<CHANNEL_NUMBER)
 911   1        {     
 912   2              switch((RecieveBuf[6]>>1)&0x3)
 913   2              {
 914   3                              case OLD_PROTO_ADC_AMP_1:
 915   3                              {
 916   4                                   channels[channel].settings.set.state_byte_1&=0xF0;
 917   4                                       channels[channel].settings.set.state_byte_1|=PROTO_ADC_AMP_1;
 918   4                              }
 919   3                              break;
 920   3      
 921   3                              case OLD_PROTO_ADC_AMP_2:
 922   3                              {
 923   4                                       channels[channel].settings.set.state_byte_1&=0xF0;
 924   4                                       channels[channel].settings.set.state_byte_1|=PROTO_ADC_AMP_2;
 925   4                              }
 926   3                              break;
 927   3      
 928   3                              case OLD_PROTO_ADC_AMP_32:
 929   3                              {
 930   4                                       channels[channel].settings.set.state_byte_1&=0xF0;
 931   4                                       channels[channel].settings.set.state_byte_1|=PROTO_ADC_AMP_32;
 932   4                              }
 933   3                              break;
 934   3      
 935   3                              case OLD_PROTO_ADC_AMP_128:
 936   3                              {
 937   4                                   channels[channel].settings.set.state_byte_1&=0xF0;
 938   4                                       channels[channel].settings.set.state_byte_1|=PROTO_ADC_AMP_128;
 939   4                              }
 940   3                              break;
 941   3      
 942   3                              default :
 943   3                              {
 944   4                                   channels[channel].settings.set.state_byte_1&=0xF0;
 945   4                                       channels[channel].settings.set.state_byte_1|=PROTO_ADC_AMP_1;
 946   4                              }
 947   3                              break;
 948   3              }
 949   2        }
 950   1        return 0;
 951   1      }
 952          //-----------------------------------------------------------------------------
 953          unsigned char Proto_Paste_Null(unsigned char *buf,unsigned char len)//т.к. старый протокол прибавляет к дл
             -ине количество 0 после D7 то обрабатываем вне прерывания
 954          {
 955   1              volatile unsigned char xdata i=0,j=0;
 956   1      
 957   1              for(i=3;i<len;i++) //пропустим заголовок 0x00 0xD7 0x28
 958   1              {
 959   2                       if(buf[i]==0xD7)
 960   2                       {
 961   3                               for(j=(len-1);j>i;j--)
 962   3                               {
 963   4                                      buf[j+1]=buf[j];//сдвигаем элементы буфера вправо на одну позицию до D7
 964   4                               }
 965   3                               buf[i+1]=0x0;//вставляем 0x00 после 0xD7
 966   3      
 967   3                               if(protocol_type==PROTO_TYPE_OLD)
 968   3                               {
C51 COMPILER V9.00   PROTO_USO                                                             06/24/2014 12:53:23 PAGE 17  

 969   4                                      buf[5]++;//длина кадра увеличилась на 1
 970   4                               }
 971   3      
 972   3                               len++;
 973   3                               i++;//не проверяем 0 спереди
 974   3                       }
 975   2              }
 976   1              return len;
 977   1      }
 978          //-----------------------------------------------------------------------------
 979          void ProtoBufHandling(void) //using 0 //процесс обработки принятого запроса
 980          {
 981   1              switch(protocol_type)
 982   1              {
 983   2                      case PROTO_TYPE_NEW:
 984   2                      {
 985   3                                channels[11].settings.set.state_byte_1=0x40; //восстановим байты статуса дола
 986   3                                channels[11].settings.set.state_byte_2=0x0A;
 987   3                                switch(RecieveBuf[4])
 988   3                                {
 989   4                              //---------------------------------------
 990   4                                      case GET_DEV_INFO_REQ:
 991   4                                      {
 992   5                                              buf_len=Send_Info();    
 993   5                                      }
 994   4                                      break;
 995   4                              //---------------------------------------
 996   4                                      case NODE_FULL_INIT_REQ:
 997   4                                      {
 998   5                                              buf_len=Node_Full_Init();
 999   5                                      }
1000   4                                      break;
1001   4                              //---------------------------------------
1002   4                                      case CHANNEL_LIST_INIT_REQ:
1003   4                                      {       
1004   5                                              buf_len=Channel_List_Init();    
1005   5                                      }
1006   4                                      break;
1007   4                              //---------------------------------------
1008   4                                      case CHANNEL_GET_DATA_REQ:
1009   4                                      {
1010   5                                              buf_len=Channel_Get_Data();     
1011   5                                      }
1012   4                                      break;
1013   4                                      //-----------------------------------
1014   4                                      case CHANNEL_SET_PARAMETERS_REQ:
1015   4                                      {
1016   5                                              buf_len=Channel_Set_Parameters();
1017   5                                      }
1018   4                                      break;
1019   4                                      //-----------------------------------
1020   4                                      case CHANNEL_SET_ORDER_QUERY_REQ:
1021   4                                      {
1022   5                                              buf_len=Channel_Set_Order_Query();
1023   5                                      }
1024   4                                      break;
1025   4                              //----------------------------------------
1026   4                                      case CHANNEL_GET_DATA_ORDER_REQ:
1027   4                                      {
1028   5                                               buf_len=Channel_Get_Data_Order();
1029   5                                      }
1030   4                                      break;
C51 COMPILER V9.00   PROTO_USO                                                             06/24/2014 12:53:23 PAGE 18  

1031   4                              //----------------------------------------
1032   4                                      case CHANNEL_SET_STATE_REQ:
1033   4                                      {
1034   5                                               buf_len=Channel_Set_State();
1035   5                                      }
1036   4                                      break;
1037   4                              //----------------------------------------
1038   4                                      case CHANNEL_GET_DATA_ORDER_M2_REQ:
1039   4                                      {
1040   5                                               buf_len=Channel_Get_Data_Order_M2();
1041   5                                      }
1042   4                                      break;
1043   4                              //------------------------------------------
1044   4                                      case CHANNEL_SET_RESET_STATE_FLAGS_REQ:
1045   4                                      {
1046   5                                              buf_len=Channel_Set_Reset_State_Flags();
1047   5                                      }
1048   4                                      break;
1049   4                              //------------------------------------------
1050   4                                      case CHANNEL_ALL_GET_DATA_REQ:
1051   4                                      {
1052   5                                               buf_len=Channel_All_Get_Data();
1053   5                                      }
1054   4                                      break;
1055   4                              //------------------------------------------
1056   4                                      case CHANNEL_SET_ADDRESS_DESC:
1057   4                                      {
1058   5                                               buf_len=Channel_Set_Address_Desc();
1059   5                                      }
1060   4                                      break;
1061   4                              //------------------------------------------
1062   4                                      case CHANNEL_SET_CALIBRATE:
1063   4                                      {
1064   5                                               buf_len=Channel_Set_Calibrate();
1065   5                                      }
1066   4                                      break;
1067   4                              //------------------------------------------
1068   4                                      case CHANNEL_SET_ALL_DEFAULT:
1069   4                                      {
1070   5                                               buf_len=Channel_Set_All_Default();
1071   5                                      }
1072   4                                      break;
1073   4                              //------------------------------------------
1074   4                                      case CHANNEL_GET_CALIBRATE_REQ:
1075   4                                      {
1076   5                                               buf_len=Channel_Get_Calibrate_Value();
1077   5                                      }
1078   4                                      break;
1079   4                              //------------------------------------------
1080   4                                  default:
1081   4                                      {
1082   5                                         buf_len=Request_Error(FR_COMMAND_NOT_EXIST);
1083   5                                  }                                                              
1084   4                                }
1085   3                      }
1086   2                      break;
1087   2      
1088   2                      case PROTO_TYPE_OLD: //старый протокол
1089   2                      {
1090   3                                switch((RecieveBuf[5]>>5)&0x7)
1091   3                                {
1092   4                              //---------------------------------------
C51 COMPILER V9.00   PROTO_USO                                                             06/24/2014 12:53:23 PAGE 19  

1093   4                                      case OLD_CHANNEL_REINIT_BLOCK:
1094   4                                      {
1095   5                                              buf_len=Old_Reinit_Block();     
1096   5                                      }
1097   4                                      break;
1098   4                              //---------------------------------------
1099   4                                      case OLD_CHANNEL_SET_ADC_RANGE:
1100   4                                      {
1101   5                                              buf_len=Old_Channel_Set_ADC_Range();
1102   5                                      }
1103   4                                      break;
1104   4                              //---------------------------------------
1105   4                                      case OLD_CHANNEL_GET_STATE:
1106   4                                      {       
1107   5                                              buf_len=Old_Channel_Get_State();        
1108   5                                      }
1109   4                                      break;
1110   4                              //---------------------------------------
1111   4                                      case OLD_CHANNEL_GET_DATA:
1112   4                                      {
1113   5                                              buf_len=Old_Channel_Get_Data(); 
1114   5                                      }
1115   4                                      break;
1116   4                                      //-----------------------------------
1117   4                                      case OLD_CHANNEL_GET_DATA_STATE:
1118   4                                      {
1119   5                                              buf_len=Old_Channel_Get_Data_State();
1120   5                                      }
1121   4                                      break;
1122   4                                      //-----------------------------------
1123   4                                  default:
1124   4                                      {
1125   5                                         
1126   5                                  }                                                              
1127   4                                }     
1128   3                       }
1129   2                       break;
1130   2                       
1131   2                       case PROTO_TYPE_MODBUS_ASCII:
1132   2                       {
1133   3                                switch(Sym_2_To_Char(&RecieveBuf[3]))//(MBCHAR2BIN(RecieveBuf[3])<<4| MBCHAR2BIN(RecieveBuf[4]))
1134   3                                {
1135   4                                      //---------------------------------------
1136   4                                              case MB_FUNC_READ_HOLDING_REGISTER:
1137   4                                              {
1138   5                                                      buf_len=ReadHoldingReg();       
1139   5                                              }
1140   4                                              break;
1141   4                                      //------------------------------------------
1142   4                                          default:
1143   4                                              {
1144   5                                                 buf_len=0x0;
1145   5                                          }                                                              
1146   4                                }
1147   3                       }
1148   2                       break; 
1149   2              }
1150   1      
1151   1        return;
1152   1      }
1153          //-----------------------------------------------------------------------------------
1154          PT_THREAD(ProtoProcess(struct pt *pt))
C51 COMPILER V9.00   PROTO_USO                                                             06/24/2014 12:53:23 PAGE 20  

1155           {
1156   1       static unsigned char  CRC=0x0, LRC=0x0;
1157   1        PT_BEGIN(pt);
1158   3      
1159   3        while(1) 
1160   3        {
1161   4        //----------restart------------
1162   4                      recieve_count=0x0;//??
1163   4                      REN=1;//recieve enqble
1164   4                      DE_RE=0;//линия на прием
1165   4                      ES=1;
1166   4        //-----------------------------
1167   4                // PT_WAIT_UNTIL(pt,RECIEVED); //ждем команды на старт
1168   4                 wdt_count[Proto_Proc].process_state=IDLE;
1169   4      
1170   4                 PT_YIELD_UNTIL(pt,RECIEVED); //ждем команды на старт 
1171   4                 wdt_count[Proto_Proc].process_state=RUN;
1172   4                 
1173   4      
1174   4                  RECIEVED=0;
1175   4                      
1176   4      
1177   4                      switch(protocol_type)
1178   4                      {
1179   5                              case PROTO_TYPE_NEW:
1180   5                              {
1181   6                                      if(RecieveBuf[3]!=ADRESS_DEV)//если адрес совпал          
1182   6                                      {
1183   7                                              PT_RESTART(pt);//если адрес не сошелся-перезапустим протокол                    
1184   7                                      }
1185   6      
1186   6                                      CRC=RecieveBuf[recieve_count-1];
1187   6      
1188   6                                  if(CRC_Check(&RecieveBuf,(recieve_count-CRC_LEN))!=CRC)
1189   6                                      {
1190   7                                              PT_RESTART(pt);//если CRC не сошлось-перезапустим протокол       
1191   7                                      }
1192   6                              }
1193   5                              break;
1194   5              
1195   5                              case PROTO_TYPE_OLD:
1196   5                              {
1197   6                                      CRC=RecieveBuf[recieve_count-1];
1198   6      
1199   6                                      if(Old_CRC_Check(&RecieveBuf,(recieve_count-CRC_LEN))!=CRC)
1200   6                                      {
1201   7                                              PT_RESTART(pt);//если CRC не сошлось-перезапустим протокол       
1202   7                                      }
1203   6                              }
1204   5                              break;
1205   5              
1206   5                              case PROTO_TYPE_MODBUS_ASCII:
1207   5                              {
1208   6                                      if(Sym_2_To_Char(&RecieveBuf[1])!=ADRESS_DEV)//((unsigned char)(MBCHAR2BIN(RecieveBuf[1])<<4| MBCHAR2B
             -IN(RecieveBuf[2]))!=ADRESS_DEV)
1209   6                                      {
1210   7                                              PT_RESTART(pt); 
1211   7                                      }       
1212   6                                      
1213   6                      
1214   6                                      LRC=Sym_2_To_Char(&RecieveBuf[recieve_count-LRC_LEN]);//((MBCHAR2BIN(RecieveBuf[recieve_count-LRC_LEN]
             -)<<4)|(MBCHAR2BIN(RecieveBuf[recieve_count-LRC_LEN+1])));
C51 COMPILER V9.00   PROTO_USO                                                             06/24/2014 12:53:23 PAGE 21  

1215   6                                              
1216   6                                      if(LRC_Check(&RecieveBuf[1],(recieve_count-LRC_LEN-1))!=LRC)
1217   6                                      {
1218   7                                              PT_RESTART(pt);//если LRC не сошлось-перезапустим протокол                       
1219   7                                      }
1220   6                              }
1221   5                              break;
1222   5                      }
1223   4      
1224   4              //      PT_YIELD(pt);//дадим другим процессам время
1225   4        //-----------------------------
1226   4                      ProtoBufHandling();//процедура обработки сообщения      
1227   4                      if(buf_len==0)//если в буфере пусто
1228   4                      {
1229   5                              PT_RESTART(pt);//перезапустим протокол  
1230   5                      }
1231   4                      else
1232   4                      {
1233   5                              if(protocol_type==PROTO_TYPE_NEW)
1234   5                              {
1235   6                                      buf_len=Proto_Paste_Null(TransferBuf,buf_len);
1236   6                              }
1237   5      
1238   5                              DE_RE=1; //переключаем RS485 в режим передачи
1239   5                                                              
1240   5                              REN=0;  //запрет приема-только передача
1241   5                              transf_count=0;
1242   5                              SBUF=TransferBuf[transf_count];//передача байта, остальным займется автомат
1243   5                              transf_count++;//инкрементируем счетчик переданных
1244   5                              ES=1; //включим прерывание уарт 
1245   5      
1246   5                              wdt_count[Proto_Proc].count++;
1247   5      
1248   5                          if(protocol_type==PROTO_TYPE_NEW)
1249   5                              {
1250   6                                      PT_DELAY(pt,10);
1251   6                              }
1252   5                              else
1253   5                              {
1254   6                                      PT_DELAY(pt,3);
1255   6                              }                       
1256   5                      }               
1257   4        //-----------------------------
1258   4        
1259   4        }
1260   3      
1261   3       PT_END(pt);
1262   1      }
1263          //-----------------------------------------------------------------------------------------------
1264          void Store_Dev_Address_Desc(unsigned char addr,void* name,void* ver,void* desc,unsigned char desc_len)//со
             -хранить в ППЗУ новый адрес устройства, имя, версию, описание
1265          {
1266   1      //небезопасная
1267   1              
1268   1              unsigned int blocks=0;//здесь будет количество блоков, нужных дя сохранения комментария
1269   1              
1270   1              EEPROM_Write(&addr,1,DEVICE_ADDR_EEPROM);        //1 блок
1271   1              EEPROM_Write(name,DEVICE_NAME_LENGTH,DEVICE_NAME_EEPROM); //5 блоков
1272   1              memcpy(DEV_NAME,name,DEVICE_NAME_LENGTH_SYM);//копируем полученное имя в буфер
1273   1      
1274   1              EEPROM_Write(ver,DEVICE_VER_LENGTH,DEVICE_VER_EEPROM);          //2 блока
1275   1              memcpy(VERSION,ver,DEVICE_VER_LENGTH_SYM);//копируем версию в буфер
C51 COMPILER V9.00   PROTO_USO                                                             06/24/2014 12:53:23 PAGE 22  

1276   1      
1277   1              blocks=desc_len>>2;//в блоке 4 байта, делим на 4
1278   1              if(desc_len&0xFC)//если есть остаток, то берем еще один блок
1279   1                      blocks++;
1280   1              
1281   1              if(blocks>DEVICE_DESC_MAX_LENGTH) //ограничение на количество блоков для комментария
1282   1                      blocks=DEVICE_DESC_MAX_LENGTH;
1283   1      
1284   1              EEPROM_Write(desc,(unsigned int)blocks,DEVICE_DESC_EEPROM);
1285   1              dev_desc_len=desc_len;
1286   1              EEPROM_Write(&desc_len,1,DEVICE_DESC_LEN_EEPROM);//сохраним длину комментария
1287   1              
1288   1              memcpy(NOTICE,desc,desc_len);//копируем описание в буфер
1289   1              
1290   1              return;
1291   1      }
1292          //-----------------------------------------------------------------------------------------------
1293          void Restore_Dev_Address_Desc(void)//восстановить из ппзу адрес и информацию об устройстве
1294          {
1295   1              unsigned int blocks=0;//здесь будет количество блоков, нужных дя сохранения комментария
1296   1              
1297   1              EEPROM_Read(&ADRESS_DEV,1,DEVICE_ADDR_EEPROM);   //1 блок восстанавливаем адрес из ППЗУ
1298   1      
1299   1              if(ADRESS_DEV<1 || ADRESS_DEV>15)
1300   1                      ADRESS_DEV=1; 
1301   1      
1302   1              EEPROM_Read(DEV_NAME,DEVICE_NAME_LENGTH,DEVICE_NAME_EEPROM); //5 блоков
1303   1          EEPROM_Read(VERSION,DEVICE_VER_LENGTH,DEVICE_VER_EEPROM);
1304   1      
1305   1              EEPROM_Read(&dev_desc_len,1,DEVICE_DESC_LEN_EEPROM);//длина описания устройства в байтах
1306   1      
1307   1              if(dev_desc_len>DEVICE_DESC_MAX_LENGTH_SYM)
1308   1                      dev_desc_len=DEVICE_DESC_MAX_LENGTH_SYM;
1309   1      
1310   1              blocks=dev_desc_len>>2;//в блоке 4 байта, делим на 4
1311   1              if(dev_desc_len&0xFC)//если есть остаток, то берем еще один блок
1312   1                      blocks++;
1313   1      
1314   1              if(blocks>DEVICE_DESC_MAX_LENGTH) //ограничение на количество блоков для комментария     ???
1315   1                      blocks=DEVICE_DESC_MAX_LENGTH;
1316   1      
1317   1              EEPROM_Read(NOTICE,(unsigned int)blocks,DEVICE_DESC_EEPROM);
1318   1              return;
1319   1      }
1320          //-----------------------------------------------------------------------------------------------
1321           PT_THREAD(RingBufHandling(struct pt *pt))//обработка кольцевого буфера
1322           {
1323   1              static unsigned char temp_count=0;//временные копии конца  и счетчика буфера
1324   1              static unsigned char temp_tail=0;
1325   1      
1326   1              static unsigned char i=0;
1327   1              static unsigned char CUT_OUT_NULL=0;//флаг-вырезаем 0 после 0xD7
1328   1      
1329   1        PT_BEGIN(pt);
1330   3      
1331   3        CUT_OUT_NULL=0;
1332   3      
1333   3        while(1) 
1334   3        {
1335   4                      wdt_count[RingBufHandling_Proc].process_state=IDLE;
1336   4                      PT_YIELD_UNTIL(pt,(rngbuf.count>0x0));//в буфере есть данные
1337   4                      wdt_count[RingBufHandling_Proc].process_state=RUN;
C51 COMPILER V9.00   PROTO_USO                                                             06/24/2014 12:53:23 PAGE 23  

1338   4              
1339   4      
1340   4                      ES=0;
1341   4                      temp_count=rngbuf.count;
1342   4                      rngbuf.count=0x0;
1343   4                      temp_tail =rngbuf.tail;
1344   4                      ES=1;
1345   4      
1346   4                      for(i=(temp_tail-temp_count);i!=temp_tail;i++)//поиск стартовой последовательности
1347   4                      {
1348   5                              if(MB_ASCII_ON)
1349   5                              {
1350   6                                      switch(rngbuf.buf[i])
1351   6                                      {
1352   7                                              //---------MB ASCII------
1353   7                                              case  0x3A:      //":"
1354   7                                              {               
1355   8                                                      recieve_count=0x0;
1356   8                                                      RecieveBuf[recieve_count]=rngbuf.buf[i];
1357   8                                                      protocol_type=PROTO_TYPE_MODBUS_ASCII;
1358   8                                                      recieve_count++;                                                                 
1359   8                                              }
1360   7                                              break;
1361   7                      
1362   7                                              case 0xA:        //"LF"
1363   7                                              {
1364   8                                                      RECIEVED=1;//буфер принят
1365   8                                                      ES=0;
1366   8                                                      REN=0;  //recieve disable 
1367   8                                              }
1368   7                                              break;
1369   7                      
1370   7                                              case 0xD:        //"CR"
1371   7                                              {
1372   8                                                      //
1373   8                                              }
1374   7                                              break;  
1375   7                                              
1376   7                                              default:
1377   7                                              {
1378   8                                                      if(((rngbuf.buf[i]>='0' && rngbuf.buf[i]<='9') || (rngbuf.buf[i]>='A' && rngbuf.buf[i]<='F')))
1379   8                                                      {
1380   9                                                              RecieveBuf[recieve_count]=rngbuf.buf[i];
1381   9                                                              recieve_count++;        
1382   9                                                      }
1383   8                                              }
1384   7                                              break;                          
1385   7                                      }                               
1386   6                              }
1387   5                              else
1388   5                              {
1389   6                                      switch(rngbuf.buf[i])
1390   6                                      {
1391   7                                                      case (char)(0xD7):
1392   7                                                      {
1393   8                                                              RecieveBuf[recieve_count]=rngbuf.buf[i];
1394   8                                                              recieve_count++;
1395   8                                                              CUT_OUT_NULL=1;          
1396   8                                                      }
1397   7                                                      break;
1398   7                              
1399   7                                                      case (char)(0x29):
C51 COMPILER V9.00   PROTO_USO                                                             06/24/2014 12:53:23 PAGE 24  

1400   7                                                      {
1401   8                                                              if(CUT_OUT_NULL==1)
1402   8                                                              {
1403   9                                                                      RecieveBuf[0]=0x0;
1404   9                                                                      RecieveBuf[1]=0xD7;
1405   9                                                                      RecieveBuf[2]=0x29;
1406   9                                                                      recieve_count=0x3;
1407   9                                                                      protocol_type=PROTO_TYPE_NEW;                   
1408   9                                                              }
1409   8                                                              else
1410   8                                                              {
1411   9                                                                      RecieveBuf[recieve_count]=rngbuf.buf[i];
1412   9                                                                      recieve_count++;        
1413   9                                                              }
1414   8                                                              CUT_OUT_NULL=0;
1415   8                                                      }
1416   7                                                      break;
1417   7                              
1418   7                                                      case (char)(0x28):
1419   7                                                      {
1420   8                                                              if(CUT_OUT_NULL==1)
1421   8                                                              {
1422   9                                                                      RecieveBuf[0]=0x0;
1423   9                                                                      RecieveBuf[1]=0xD7;
1424   9                                                                      RecieveBuf[2]=0x28;
1425   9                                                                      recieve_count=0x3;
1426   9                                                                      protocol_type=PROTO_TYPE_OLD;                   
1427   9                                                              }
1428   8                                                              else
1429   8                                                              {
1430   9                                                                      RecieveBuf[recieve_count]=rngbuf.buf[i];
1431   9                                                                      recieve_count++;        
1432   9                                                              }
1433   8                                                              CUT_OUT_NULL=0;
1434   8                                                      }
1435   7                                                      break;
1436   7                              
1437   7                                                      case (char)(0x0):
1438   7                                                      {
1439   8                                                              if(CUT_OUT_NULL==1)       //если после 0xD7-пропускаем
1440   8                                                              {
1441   9                                                                      CUT_OUT_NULL=0;         
1442   9                                                              }
1443   8                                                              else
1444   8                                                              {
1445   9                                                                      RecieveBuf[recieve_count]=rngbuf.buf[i];
1446   9                                                                      recieve_count++;        
1447   9                                                              }
1448   8                                                      }
1449   7                                                      break;          
1450   7                                                      //-----------------------
1451   7                              
1452   7                                                      default :
1453   7                                                      {
1454   8                                                              RecieveBuf[recieve_count]=rngbuf.buf[i];
1455   8                                                              recieve_count++;
1456   8                                                              CUT_OUT_NULL=0;         
1457   8                                                      }
1458   7                                              }
1459   6                              
1460   6                                         if(recieve_count>6)
1461   6                                         {
C51 COMPILER V9.00   PROTO_USO                                                             06/24/2014 12:53:23 PAGE 25  

1462   7                                                        if(recieve_count==6+frame_len)          // принимаем указанное в frame_len число байт данные, 6 значит
             - что обмен идет с компом, надо ставаить 5 чтобы обмениваться с устройствами
1463   7                                                        {
1464   8                                                                      RECIEVED=1;//буфер принят
1465   8                                                                      ES=0;
1466   8                                                                      REN=0;  //recieve disable -запрещаем принимать в буфер  
1467   8                                                                      CUT_OUT_NULL=0;                                                 
1468   8                                                        }      
1469   7                                                        
1470   7                                                        //----------------------обрабатываем возможные ошибки длины кадра-------------
1471   7                                                    if(recieve_count>MAX_LENGTH_REC_BUF)      //если посылка слишком длинная
1472   7                                                        {
1473   8                                                                      PT_RESTART(&pt_proto);  //внепроцессный рестарт
1474   8                                                        }  
1475   7                                         }
1476   6                                         else
1477   6                                         {
1478   7                                                         if(recieve_count==6)
1479   7                                                         {     
1480   8                                                              
1481   8                                                                      frame_len=RecieveBuf[recieve_count-1];  // получаем длину данных после заголовка
1482   8                                                                      if(protocol_type==PROTO_TYPE_OLD)
1483   8                                                                      {
1484   9                                                                              frame_len&=0x1F;//в старом протоколе только 5 младших бит -длина оставшейся части       
1485   9                                                                      }                                        
1486   8                                                         }                    
1487   7                                         }
1488   6                                      }
1489   5                                                                                                                                      
1490   5                      }
1491   4                      wdt_count[RingBufHandling_Proc].count++;
1492   4                      PT_YIELD(pt);//дадим другим процессам время     
1493   4        }
1494   3      
1495   3        PT_END(pt);
1496   1       }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   8369    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    946       1
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      1       2
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
