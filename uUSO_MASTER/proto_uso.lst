C51 COMPILER V9.00   PROTO_USO                                                             06/20/2014 14:22:33 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE PROTO_USO
OBJECT MODULE PLACED IN proto_uso.obj
COMPILER INVOKED BY: C:\Program Files\Keil\C51\BIN\C51.EXE proto_uso\proto_uso.c LARGE OPTIMIZE(6,SPEED) BROWSE ORDER NO
                    -AREGS DEBUG OBJECTEXTEND PRINT(.\proto_uso.lst) OBJECT(proto_uso.obj)

line level    source

   1          #include "proto_uso.h"
   2          #include "calibrate\calibrate.h"
   3          #include "i2c.h"
   4          #include <intrins.h>
   5          #include "crc_table.h"
   6          #include "channels.h"
   7          #include "watchdog.h"
   8          #include "modbus\modbus_ascii.h"
   9          //-----------------------------------------------------------------------------------
  10          
  11          sbit DE_RE=P3^5;
  12          
  13          //-----------------------------------------------------------------------------------
  14          volatile unsigned char xdata DEV_NAME[DEVICE_NAME_LENGTH_SYM] ="<<uUSO_2>>"; //имя устройства
  15          volatile unsigned char xdata NOTICE[DEVICE_DESC_MAX_LENGTH_SYM]="<-- GEOSPHERA_2012 -->";//примечание   
  16          volatile unsigned char xdata VERSION[DEVICE_VER_LENGTH_SYM] ="\x30\x30\x30\x30\x31";    // версия программы П
             -ЗУ        не больше 5 байт
  17          
  18          volatile unsigned char xdata ADRESS_DEV=0x1;
  19          
  20          volatile unsigned char xdata dev_desc_len=20;//длина описания устройства
  21          //--------------------------------global variable------------------------------------
  22          volatile unsigned char idata    RECIEVED=0;//принято
  23          volatile unsigned char xdata    recieve_count;//счетчик приемного буфера
  24          volatile unsigned char xdata    transf_count;//счетчик передаваемых байтов         
  25          volatile unsigned char xdata    buf_len;//длина передаваемого буфера
  26          
  27          //------------------------флаги ошибок--------------------------------
  28          volatile unsigned char idata  CUT_OUT_NULL;//флаг-вырезаем 0 после 0xD7
  29          volatile unsigned char xdata frame_len=0;//длина кадра, которую вытаскиваем из шестого байта кадра
  30          //--------------------------------------------------------------------
  31          volatile unsigned char xdata  RecieveBuf[MAX_LENGTH_REC_BUF]={0} ; //буфер принимаемых данных
  32          //volatile unsigned char xdata                  *TransferBuf;
  33          volatile unsigned char xdata  TransferBuf[MAX_LENGTH_TR_BUF]={0} ; //буфер передаваемых данных
  34          //--------------------------------------------------------------------
  35          volatile unsigned char xdata  STATE_BYTE=0xC0;//байт состояния устройства
  36          volatile unsigned char idata symbol=0xFF;//принятый символ
  37          
  38          volatile unsigned char xdata protocol_type=PROTO_TYPE_NEW;//тип протокола
  39          
  40          volatile struct pt pt_proto;
  41          //-----------------------------------------------------------------------------------
  42          union //объединение для конвертирования char->long
  43          {
  44                  float result_float;
  45                  unsigned char result_char[4];
  46          }
  47          sym_8_to_float;
  48          
  49          extern unsigned char idata i2c_buffer[6];
  50          extern unsigned char channel_number;//количество каналов
  51          
  52          //-----------------------------------------------------------------------------------
  53          //#pragma OT(0,Speed)
C51 COMPILER V9.00   PROTO_USO                                                             06/20/2014 14:22:33 PAGE 2   

  54          void UART_ISR(void) interrupt 4 //using 1
  55          {       
  56   1              EA=0;   //запрет прерывания
  57   1              
  58   1              if(RI)
  59   1              {
  60   2                      RI=0; 
  61   2      //----------------------обрабатываем возможные ошибки длины кадра-------------
  62   2                      if(recieve_count>MAX_LENGTH_REC_BUF)    //если посылка слишком длинная
  63   2                      {
  64   3                              PT_RESTART_OUT(pt_proto);  //внепроцессный рестарт
  65   3                              return;
  66   3                      } 
  67   2      
  68   2      
  69   2                      symbol=SBUF;
  70   2                      wdt_count[Proto_Proc].process_state=RUN;
  71   2                      switch(symbol)
  72   2                      {
  73   3                              case (char)(0xD7):
  74   3                              {
  75   4                                      RecieveBuf[recieve_count]=symbol;
  76   4                                      recieve_count++;
  77   4                                      CUT_OUT_NULL=1;          
  78   4                              }
  79   3                              break;
  80   3      
  81   3                              case (char)(0x29):
  82   3                              {
  83   4                                      if(CUT_OUT_NULL==1)
  84   4                                      {
  85   5                                              RecieveBuf[0]=0x0;
  86   5                                              RecieveBuf[1]=0xD7;
  87   5                                              RecieveBuf[2]=0x29;
  88   5                                              recieve_count=0x3;
  89   5                                              protocol_type=PROTO_TYPE_NEW;                   
  90   5                                      }
  91   4                                      else
  92   4                                      {
  93   5                                              RecieveBuf[recieve_count]=symbol;
  94   5                                              recieve_count++;        
  95   5                                      }
  96   4                                      CUT_OUT_NULL=0;
  97   4                              }
  98   3                              break;
  99   3      
 100   3                              case (char)(0x28):
 101   3                              {
 102   4                                      if(CUT_OUT_NULL==1)
 103   4                                      {
 104   5                                              RecieveBuf[0]=0x0;
 105   5                                              RecieveBuf[1]=0xD7;
 106   5                                              RecieveBuf[2]=0x28;
 107   5                                              recieve_count=0x3;
 108   5                                              protocol_type=PROTO_TYPE_OLD;                   
 109   5                                      }
 110   4                                      else
 111   4                                      {
 112   5                                              RecieveBuf[recieve_count]=symbol;
 113   5                                              recieve_count++;        
 114   5                                      }
 115   4                                      CUT_OUT_NULL=0;
C51 COMPILER V9.00   PROTO_USO                                                             06/20/2014 14:22:33 PAGE 3   

 116   4                              }
 117   3                              break;
 118   3      
 119   3                              case (char)(0x0):
 120   3                              {
 121   4                                      if(CUT_OUT_NULL==1)       //если после 0xD7-пропускаем
 122   4                                      {
 123   5                                              CUT_OUT_NULL=0;         
 124   5                                      }
 125   4                                      else
 126   4                                      {
 127   5                                              RecieveBuf[recieve_count]=symbol;
 128   5                                              recieve_count++;        
 129   5                                      }
 130   4                              }
 131   3                              break;
 132   3      
 133   3                              default :
 134   3                              {
 135   4                                      RecieveBuf[recieve_count]=symbol;
 136   4                                      recieve_count++;
 137   4                                      CUT_OUT_NULL=0;
 138   4                                      
 139   4                              }
 140   3                      }
 141   2      
 142   2                 if(recieve_count>6)
 143   2                 {
 144   3                                if(recieve_count==6+frame_len)          // принимаем указанное в frame_len число байт данные, 6 значит чт
             -о обмен идет с компом, надо ставаить 5 чтобы обмениваться с устройствами
 145   3                                {
 146   4                                              RECIEVED=1;//буфер принят
 147   4                                              ES=0;
 148   4                                              REN=0;  //recieve disable -запрещаем принимать в буфер  
 149   4                                              CUT_OUT_NULL=0;                                                 
 150   4                                }       
 151   3                 }
 152   2                 else
 153   2                 {
 154   3                                 if(recieve_count==6)
 155   3                                 {     
 156   4                                      
 157   4                                              frame_len=RecieveBuf[recieve_count-1];  // получаем длину данных после заголовка
 158   4                                              if(protocol_type==PROTO_TYPE_OLD)
 159   4                                              {
 160   5                                                      frame_len&=0x1F;//в старом протоколе только 5 младших бит -длина оставшейся части       
 161   5                                              }                                        
 162   4                                 }                    
 163   3                 }                                                                            
 164   2              }
 165   1      //----------------------------передача----------------------------------------------------------------
 166   1              if(TI)
 167   1              {
 168   2                      TI=0;
 169   2                       
 170   2                      if(transf_count<buf_len)
 171   2                      {
 172   3                              if((transf_count<3)||(protocol_type==PROTO_TYPE_OLD))//передаем заголовок или все подряд, если старый п
             -ротокол
 173   3                              {
 174   4                                      SBUF=TransferBuf[transf_count];                 
 175   4                                      transf_count++;
C51 COMPILER V9.00   PROTO_USO                                                             06/20/2014 14:22:33 PAGE 4   

 176   4                              }
 177   3                              else   //тело...   подставляем 0 после 0xD7
 178   3                              {
 179   4                                              if(CUT_OUT_NULL==0)
 180   4                                              {
 181   5                                                      if(TransferBuf[transf_count]==(unsigned char)0xD7)//проверим, это  ,0xD7 или другое
 182   5                                                      {                       
 183   6                                                              CUT_OUT_NULL=0x1;       
 184   6                                                      }
 185   5                                                      SBUF=TransferBuf[transf_count];                 
 186   5                                                      transf_count++;
 187   5                                              }
 188   4                                              else
 189   4                                              {
 190   5                                                      SBUF=(unsigned char)0x0;
 191   5                                                      CUT_OUT_NULL=0;         
 192   5                                              }       
 193   4                              }       
 194   3                      }
 195   2                      else
 196   2                      {
 197   3                              transf_count=0;         //обнуляем счетчик
 198   3                              CUT_OUT_NULL=0;
 199   3                              PT_RESTART_OUT(pt_proto);  //внепроцессный рестарт                      
 200   3                      }                                          
 201   2              }                       
 202   1              EA=1;
 203   1              return;
 204   1      }
 205          //------------------------------------------------------------------------------
 206          //#pragma OT(6,Speed)
 207          void Protocol_Init(void) //using 0
 208          {
 209   1              TI=0;
 210   1              RI=0;
 211   1              
 212   1      //      TransferBuf=&RecieveBuf[0];      //буфер ответа =буфер запроса
 213   1      
 214   1              Restore_Dev_Address_Desc();
 215   1      
 216   1      
 217   1              recieve_count=0x0;//счетчик буфера приема
 218   1              transf_count=0x0;//счетчик передаваемых байтов
 219   1              buf_len=0x0;//длина передаваемого буфера
 220   1              DE_RE=0;//линия на прием
 221   1              CUT_OUT_NULL=0;
 222   1              STATE_BYTE=0xC0;
 223   1              PT_INIT(&pt_proto);
 224   1              return;
 225   1      }
 226          //-----------------------------------------------------------------------------
 227          unsigned char Send_Info(void) //using 0    //посылка информации об устройстве
 228          {
 229   1                  unsigned char    i=0;
 230   1                                                                                      
 231   1                 //заголовок кадра---
 232   1                 TransferBuf[0]=0x00;
 233   1                 TransferBuf[1]=0xD7;
 234   1                 TransferBuf[2]=0x29;
 235   1                 //------------------
 236   1                 TransferBuf[3]=ADRESS_DEV;  // адрес узла
 237   1                 TransferBuf[4]=GET_DEV_INFO_RESP;  // код операции
C51 COMPILER V9.00   PROTO_USO                                                             06/20/2014 14:22:33 PAGE 5   

 238   1                 TransferBuf[6]=STATE_BYTE;
 239   1      
 240   1                 for(i=0;i<20;i++)
 241   1                 {                              // записываем наименование изделия
 242   2                                 if(i<DEVICE_NAME_LENGTH_SYM)
 243   2                                 {
 244   3                                      TransferBuf[i+7]=DEV_NAME[i];
 245   3                                 }
 246   2                                 else
 247   2                                 {
 248   3                                              TransferBuf[i+7]=0x00;
 249   3                                 }
 250   2                      }
 251   1              
 252   1                 for(i=0;i<5;i++)                   // записываем версию ПЗУ
 253   1                 {
 254   2                     if(i<DEVICE_VER_LENGTH_SYM)
 255   2                         {
 256   3                               TransferBuf[i+27]=VERSION[i];
 257   3                         }
 258   2                 }
 259   1      
 260   1                 TransferBuf[32]=channel_number;                 // количество каналов
 261   1      
 262   1                 for(i=0;i<channel_number;i++)                                   // данные по каналу
 263   1             {
 264   2                              TransferBuf[i*2+33]=((channels[i].settings.set.type)<<4)|channels[i].settings.set.modific; // байт да
             -нных
 265   2                              TransferBuf[i*2+33+1]=0x00;                                                     // резерв байт
 266   2                 }    
 267   1                 for(i=0;i<dev_desc_len;i++)                                  // записываем примечание
 268   1                 {
 269   2                               TransferBuf[i+33+channel_number*2]=NOTICE[i];
 270   2                 }
 271   1                              
 272   1                 TransferBuf[5]=28+channel_number*2+dev_desc_len;                     // подсчет длины данных 
 273   1                 TransferBuf[33+channel_number*2+dev_desc_len]=CRC_Check(&TransferBuf[1],32+channel_number*2+dev_desc_l
             -en); // подсчет контрольной суммы
 274   1      
 275   1              return (34+channel_number*2+dev_desc_len);
 276   1      }
 277          //-----------------------------------------------------------------------------
 278          unsigned char Node_Full_Init(void) //using 0 //полная инициализация узла
 279          {
 280   1              return 0;
 281   1      }
 282          //-----------------------------------------------------------------------------
 283          unsigned char Channel_List_Init(void) //using 0 //Инициализация списка каналов узла (без потери данных);
 284          {
 285   1              return 0;
 286   1      }
 287          //-----------------------------------------------------------------------------
 288          unsigned char Channel_Get_Data(void) //using 0 //Выдать данные по каналам, согласно абсолютной нумерации;
 289          {
 290   1              return 0;
 291   1      }
 292          //-----------------------------------------------------------------------------
 293          unsigned char  Channel_Set_Parameters(void) //using 0 //Установить параметры по каналам, согласно абсолютн
             -ой нумерации;
 294          {
 295   1             unsigned char  index=0, store_data=0;//i=0;
 296   1               
C51 COMPILER V9.00   PROTO_USO                                                             06/20/2014 14:22:33 PAGE 6   

 297   1                 while(index<RecieveBuf[5]-1)                            // данные по каналам
 298   1                    {
 299   2                                      if(RecieveBuf[6+index]<channel_number)
 300   2                                  {
 301   3                                              switch((RecieveBuf[6+index+1]>>4)&0xF)
 302   3                                              {
 303   4                                                              case CHNL_ADC://АЦП
 304   4                                                              {
 305   5                                                                      if((channels[RecieveBuf[6+index]].settings.set.modific!=RecieveBuf[6+index+1])||(channels[RecieveB
             -uf[6+index]].settings.set.state_byte_1!=RecieveBuf[6+index+2]) || (channels[RecieveBuf[6+index]].settings.set.state_byte
             -_2!=RecieveBuf[6+index+3]))
 306   5                                                                      {  
 307   6                                                                              channels[RecieveBuf[6+index]].settings.set.state_byte_1=RecieveBuf[6+index+2];
 308   6                                                                              channels[RecieveBuf[6+index]].settings.set.state_byte_2=RecieveBuf[6+index+3];
 309   6                                                                              channels[RecieveBuf[6+index]].settings.set.modific         =RecieveBuf[6+index+1]&0xF;
 310   6                                                                              store_data=1;
 311   6                                                                              
 312   6                                                                      }
 313   5                                                                      index++;
 314   5                                                              }
 315   4                                                              break;
 316   4      
 317   4      
 318   4                                                              default :
 319   4                                                              {
 320   5                                                                      _nop_();
 321   5                                                              }                       
 322   4                                              }
 323   3                                              index=index+3;
 324   3                                      }
 325   2                                      else
 326   2                                      {
 327   3                                              return Request_Error(FR_UNATTENDED_CHANNEL);
 328   3                                      }
 329   2                        }
 330   1                 if(store_data)
 331   1                 {
 332   2                              Store_Channels_Data();  //сохраним настройки каналов в ППЗУ
 333   2                 }
 334   1      
 335   1                 return Request_Error(FR_SUCCESFUL);
 336   1      }
 337          //-----------------------------------------------------------------------------
 338          unsigned char Channel_Set_Order_Query(void) //using 0 //Задать последовательность опроса;
 339          {
 340   1              return 0;
 341   1      }
 342          //-----------------------------------------------------------------------------
 343          unsigned char Channel_Get_Data_Order(void) //using 0 //Выдать данные по каналам, согласно последовательнос
             -ти опроса;
 344          {
 345   1              return 0;
 346   1      }
 347          //-----------------------------------------------------------------------------
 348          unsigned char Channel_Set_State(void) //using 0 //Установить состояния по каналам, согласно абсолютной нум
             -ерации;
 349          {
 350   1              return 0;
 351   1      }
 352          //-----------------------------------------------------------------------------
 353          unsigned char  Channel_Get_Data_Order_M2(void) //using 0 //Выдать данные по каналам, согласно последовател
             -ьности опроса;
C51 COMPILER V9.00   PROTO_USO                                                             06/20/2014 14:22:33 PAGE 7   

 354          {
 355   1              return 0;
 356   1      }
 357          //-----------------------------------------------------------------------------
 358          unsigned char Channel_Set_Reset_State_Flags(void) //using 0 //  Установка/Сброс флагов состояния 
 359          {
 360   1              STATE_BYTE=0x40;
 361   1              i2c_buffer[0]=0x12;//сбросим флаг инициализации ведомого
 362   1              ChannelsInit();
 363   1              return  Request_Error(FR_SUCCESFUL);//ошибки нет, подтверждение
 364   1      }
 365          //-----------------------------------------------------------------------------
 366          #pragma OT(9,Speed)
 367          unsigned char Channel_All_Get_Data(void) //using 0 //Выдать информацию по всем каналам узла (расширенный р
             -ежим);
 368          {
 369   1         unsigned char data index=0,i=0;
 370   1      
 371   1      
 372   1         TransferBuf[0]=0x00;TransferBuf[1]=0xD7;TransferBuf[2]=0x29;
 373   1         TransferBuf[3]=ADRESS_DEV;  // адрес узла
 374   1         TransferBuf[4]=CHANNEL_ALL_GET_DATA_RESP;  // код операции
 375   1         TransferBuf[6]=STATE_BYTE;
 376   1      
 377   1         index=7;//длина заголовка
 378   1       
 379   1          for(i=0;i<channel_number;i++)                                  // данные по каналам
 380   1          {
 381   2                        TransferBuf[index++]=i;
 382   2                        TransferBuf[index++]=((channels[i].settings.set.type)<<4)|channels[i].settings.set.modific; // тип и м
             -одификация канала
 383   2                        switch(channels[i].settings.set.type)
 384   2                          {
 385   3                                       case CHNL_ADC:  //аналоговый канал
 386   3                                       {
 387   4                                               switch(channels[i].settings.set.modific)
 388   4                               {
 389   5                                                        case CHNL_ADC_FIX_16:
 390   5                                                        {
 391   6                                                                      if(channels[i].calibrate.cal.calibrate==1)//калиброванный
 392   6                                                                      {                                                
 393   7                                                                                      TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data_calibrate))[2];
 394   7                                                                              TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data_calibrate))[1];
 395   7                                                                      }
 396   6                                                                      else
 397   6                                                                      {
 398   7                                                                                      TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data))[2];
 399   7                                                                              TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data))[1];  
 400   7                                                                      } 
 401   6      
 402   6                                                                        
 403   6                                                                       TransferBuf[index++]=channels[i].settings.set.state_byte_1;     // первый байт состояния канала
 404   6                                               TransferBuf[index++]=channels[i].settings.set.state_byte_2;     // второй байт сос
             -тояния канала
 405   6                                                        }
 406   5                                                        break; 
 407   5      
 408   5                                                        case CHNL_ADC_FIX_24:
 409   5                                                        {
 410   6                                                              if(channels[i].calibrate.cal.calibrate==1)//калиброванный
 411   6                                                                      {                                                                                                 
 412   7                                                                                      TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data_calibrate))[3];
C51 COMPILER V9.00   PROTO_USO                                                             06/20/2014 14:22:33 PAGE 8   

 413   7                                                                                      TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data_calibrate))[2];
 414   7                                                                              TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data_calibrate))[1];
 415   7                                                                      }
 416   6                                                                      else
 417   6                                                                      {                                                                        
 418   7                                                                                      TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data))[3];
 419   7                                                                                      TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data))[2];
 420   7                                                                              TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data))[1];  
 421   7                                                                      } 
 422   6                        
 423   6                                                                        TransferBuf[index++]=channels[i].settings.set.state_byte_1;    // первый байт состояния канала
 424   6                                                TransferBuf[index++]=channels[i].settings.set.state_byte_2;    // второй байт со
             -стояния канала
 425   6                                                        }
 426   5                                                        break;
 427   5                                                }
 428   4                                        }
 429   3                                        break;
 430   3      
 431   3                                      case CHNL_DOL:   //ДОЛ
 432   3                                      {
 433   4                                                switch(channels[i].settings.set.modific)
 434   4                                            {   
 435   5                                                                case CHNL_DOL_ENC:
 436   5                                                                {
 437   6                                                                                      TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data))[3];
 438   6                                                                                      TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data))[2];
 439   6                                                                              TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data))[1];
 440   6                                                                                      TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data))[0];
 441   6                                                                                  TransferBuf[index++]=channels[i].settings.set.state_byte_1;  // первый байт состояния канала
 442   6                                                                }
 443   5                                                                break; 
 444   5                                                 }
 445   4                                      }
 446   3                                      break;
 447   3      
 448   3                                       case CHNL_FREQ: //частотный
 449   3                                       { 
 450   4                                                switch(channels[i].settings.set.modific)
 451   4                                            {   
 452   5                                                                
 453   5                                                                case CHNL_FREQ_COUNT_T:
 454   5                                                                {
 455   6                                                                                      TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data))[3];
 456   6                                                                                      TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data))[2];
 457   6                                                                                TransferBuf[index++]=channels[i].settings.set.state_byte_1;    // первый байт состояния канала
 458   6                                                                }
 459   5                                                                break;
 460   5      
 461   5                                                                case CHNL_FREQ_256:
 462   5                                                                {
 463   6                                                                                      TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data))[3];
 464   6                                                                                      TransferBuf[index++]=((unsigned char*)(&channels[i].channel_data))[2];
 465   6                                                                                  TransferBuf[index++]=channels[i].settings.set.state_byte_1;  // первый байт состояния канала
 466   6                                                                }
 467   5                                                                break; 
 468   5                                                 }
 469   4                                        }
 470   3                                        break;                 
 471   3                        }
 472   2                 }
 473   1      
C51 COMPILER V9.00   PROTO_USO                                                             06/20/2014 14:22:33 PAGE 9   

 474   1                TransferBuf[5]=index+2-7;                                              // подсчет длины данных двойка это 1(байт статуса)+1(контрольная сумма
             -)
 475   1                TransferBuf[index]=CRC_Check(&TransferBuf[1],(unsigned int)(index)-1); // подсчет кс
 476   1                return (unsigned char)(index+1);
 477   1      }
 478          //-----------------------------------------------------------------------------
 479          #pragma OT(0,Speed)
 480          unsigned char Channel_Set_Calibrate(void)//установить верхнюю или нижнюю точку калибровки
 481          {
 482   1      
 483   1              float K,C;      
 484   1      
 485   1              sym_8_to_float.result_char[0]=RecieveBuf[11];
 486   1              sym_8_to_float.result_char[1]=RecieveBuf[10];
 487   1              sym_8_to_float.result_char[2]=RecieveBuf[9];
 488   1              sym_8_to_float.result_char[3]=RecieveBuf[8];
 489   1      
 490   1              K=sym_8_to_float.result_float;
 491   1      
 492   1              sym_8_to_float.result_char[0]=RecieveBuf[15];
 493   1              sym_8_to_float.result_char[1]=RecieveBuf[14];
 494   1              sym_8_to_float.result_char[2]=RecieveBuf[13];
 495   1              sym_8_to_float.result_char[3]=RecieveBuf[12];
 496   1      
 497   1              C=sym_8_to_float.result_float;
 498   1      
 499   1              switch(RecieveBuf[7])
 500   1              {
 501   2                      case 0:
 502   2                      {
 503   3                              Calibrate(RecieveBuf[6],K,C);   
 504   3                      }
 505   2                      break;
 506   2      
 507   2                      case 1:
 508   2                      {
 509   3                              Calibrate_Set_Flag(RecieveBuf[6],RESET);
 510   3                      }
 511   2                      break;
 512   2      
 513   2                      case 2:
 514   2                      {
 515   3                              Calibrate_Set_Flag(RecieveBuf[6],SET);  
 516   3                      }
 517   2                      break;
 518   2      
 519   2                      default :
 520   2                      {
 521   3                              _nop_();
 522   3                      }
 523   2                      break;
 524   2              }
 525   1      
 526   1      
 527   1              return  Request_Error(FR_SUCCESFUL);//ошибки нет, подтверждение 
 528   1      }
 529          //------------------------------------------------------------------------------
 530          unsigned char Channel_Get_Calibrate_Value(void)//получить коэфициенты калибровки заданного канала
 531          {
 532   1         unsigned char data channel=0;
 533   1      
 534   1      
C51 COMPILER V9.00   PROTO_USO                                                             06/20/2014 14:22:33 PAGE 10  

 535   1         TransferBuf[0]=0x00;TransferBuf[1]=0xD7;TransferBuf[2]=0x29;
 536   1         TransferBuf[3]=ADRESS_DEV;  // адрес узла
 537   1         TransferBuf[4]=CHANNEL_GET_CALIBRATE_RESP;  // код операции
 538   1         TransferBuf[5]=0xB;//длина оставшейся части кадра
 539   1      
 540   1      
 541   1         channel=RecieveBuf[6];
 542   1      
 543   1         if(channel>=channel_number)
 544   1         {
 545   2                      return Request_Error(FR_COMMAND_STRUCT_ERROR);//непрвильный номер канала        
 546   2         }
 547   1      
 548   1         TransferBuf[6]=channel;
 549   1      
 550   1         TransferBuf[7]=channels[channel].calibrate.cal.calibrate;
 551   1      
 552   1         sym_8_to_float.result_float=channels[channel].calibrate.cal.K;
 553   1      
 554   1              TransferBuf[11]=sym_8_to_float.result_char[0];
 555   1              TransferBuf[10]=sym_8_to_float.result_char[1];
 556   1              TransferBuf[9]=sym_8_to_float.result_char[2];
 557   1              TransferBuf[8]=sym_8_to_float.result_char[3];
 558   1      
 559   1         sym_8_to_float.result_float=channels[channel].calibrate.cal.C;
 560   1      
 561   1              TransferBuf[15]=sym_8_to_float.result_char[0];
 562   1              TransferBuf[14]=sym_8_to_float.result_char[1];
 563   1              TransferBuf[13]=sym_8_to_float.result_char[2];
 564   1              TransferBuf[12]=sym_8_to_float.result_char[3];
 565   1      
 566   1              TransferBuf[16]=CRC_Check(&TransferBuf[1],15); // подсчет кс
 567   1              return 0x11;//17        
 568   1      }
 569          //------------------------------------------------------------------------------
 570          unsigned char Channel_Set_Address_Desc(void)//установить новый адрес устройства, имя, описание, версию про
             -шивки и комментарий
 571          {
 572   1              unsigned char  desc_len=0;
 573   1              desc_len=RecieveBuf[5]-27;
 574   1      
 575   1              if(desc_len)
 576   1              {       
 577   2                      Store_Dev_Address_Desc(RecieveBuf[6],&RecieveBuf[7],&RecieveBuf[27],&RecieveBuf[32],desc_len);
 578   2                      return    Request_Error(FR_SUCCESFUL);//ошибки нет, подтверждение
 579   2              }
 580   1              else
 581   1              {
 582   2                      return Request_Error(FR_COMMAND_STRUCT_ERROR);
 583   2              }
 584   1              return 0;
 585   1      }
 586          //-----------------------------------------------------------------------------
 587          unsigned char Channel_Set_All_Default(void)//установить настройки и калибровки каналов по умолчанию
 588          {
 589   1              Channels_Set_Default();
 590   1              Calibrate_Set_Default();
 591   1              return  Request_Error(FR_SUCCESFUL);//ошибки нет, подтверждение         
 592   1      }
 593          //-----------------------------------------------------------------------------
 594          unsigned char Request_Error(unsigned char error_code) //using 0 //      Ошибочный запрос/ответ;
 595          {
C51 COMPILER V9.00   PROTO_USO                                                             06/20/2014 14:22:33 PAGE 11  

 596   1              TransferBuf[0]=0x00;TransferBuf[1]=0xD7;TransferBuf[2]=0x29;
 597   1          TransferBuf[3]=ADRESS_DEV;  // адрес узла
 598   1          TransferBuf[7]=RecieveBuf[4]; // код сбойной команды
 599   1          TransferBuf[4]=0xFF;  // код операции
 600   1      
 601   1              TransferBuf[6]=STATE_BYTE; // байт статуса узла
 602   1          TransferBuf[8]=error_code;   
 603   1          TransferBuf[5]=0x04;          // длина данных
 604   1          TransferBuf[9]=CRC_Check(TransferBuf,9);
 605   1              return 10;
 606   1      }
 607          
 608          //-----------------------------------------------------------------------------
 609          unsigned char Old_CRC_Check(unsigned char xdata *Spool_pr,unsigned char Count_pr)
 610          {
 611   1           unsigned char crc = 0x0;
 612   1               unsigned char i=0;
 613   1      
 614   1               for(i=0;i<Count_pr;i++)
 615   1               {
 616   2                      CY=0;
 617   2                      crc+=Spool_pr[i];
 618   2                      if(CY)
 619   2                      {
 620   3                              crc++;
 621   3                      }
 622   2               }
 623   1               crc=0xFF-crc;
 624   1      
 625   1           return crc;        
 626   1      }
 627          //-----------------------------------------------------------------------------
 628          unsigned char Old_Channel_Get_Data(void)
 629          {
 630   1        unsigned char channel=0;
 631   1        unsigned char len=0;
 632   1        channel=((RecieveBuf[4]>>3)&0x1F);
 633   1        if(channel<CHANNEL_NUMBER)
 634   1        {  
 635   2                 TransferBuf[0]=0x00;TransferBuf[1]=0xD7;TransferBuf[2]=0x28;
 636   2                 TransferBuf[3]=0x0;  // 
 637   2                 TransferBuf[4]=RecieveBuf[4];
 638   2                 TransferBuf[5]=((OLD_CHANNEL_GET_DATA<<5)&0x1F)|0x3;//0x63;// код операции   
 639   2      
 640   2                              switch(channels[channel].settings.set.type)
 641   2                          {
 642   3                                       case CHNL_ADC:  //аналоговый канал
 643   3                                       {
 644   4                                               switch(channels[channel].settings.set.modific)
 645   4                               {
 646   5                                                        case CHNL_ADC_FIX_16:
 647   5                                                        {
 648   6                                                                      if(channels[channel].calibrate.cal.calibrate==1)//калиброванный
 649   6                                                                      {                                                
 650   7                                                                                      TransferBuf[6]=((unsigned char*)(&channels[channel].channel_data_calibrate))[1];
 651   7                                                                              TransferBuf[7]=((unsigned char*)(&channels[channel].channel_data_calibrate))[2];
 652   7                                                                      }
 653   6                                                                      else
 654   6                                                                      {
 655   7                                                                                      TransferBuf[6]=((unsigned char*)(&channels[channel].channel_data))[1];
 656   7                                                                              TransferBuf[7]=((unsigned char*)(&channels[channel].channel_data))[2];  
 657   7                                                                      }                                       
C51 COMPILER V9.00   PROTO_USO                                                             06/20/2014 14:22:33 PAGE 12  

 658   6                                                        }
 659   5                                                        break; 
 660   5      
 661   5                                                        case CHNL_ADC_FIX_24:
 662   5                                                        {
 663   6                                                              if(channels[channel].calibrate.cal.calibrate==1)//калиброванный
 664   6                                                                      {                                                                                                 
 665   7                                                                                      TransferBuf[channel]=((unsigned char*)(&channels[channel].channel_data_calibrate))[1];
 666   7                                                                              TransferBuf[channel]=((unsigned char*)(&channels[channel].channel_data_calibrate))[2];
 667   7                                                                      }
 668   6                                                                      else
 669   6                                                                      {                                                                        
 670   7                                                                                      TransferBuf[6]=((unsigned char*)(&channels[channel].channel_data))[1];
 671   7                                                                              TransferBuf[7]=((unsigned char*)(&channels[channel].channel_data))[2];  
 672   7                                                                      }
 673   6      
 674   6                                                        }
 675   5                                                        break;
 676   5                                                }                                       
 677   4                                        }
 678   3                                        break;
 679   3      
 680   3                                      case CHNL_DOL:   //ДОЛ
 681   3                                      {
 682   4                                                switch(channels[channel].settings.set.modific)
 683   4                                            {   
 684   5                                                                case CHNL_DOL_ENC:
 685   5                                                                {
 686   6                                                                                      TransferBuf[6]=((unsigned char*)(&channels[channel].channel_data))[2];
 687   6                                                                                      TransferBuf[7]=((unsigned char*)(&channels[channel].channel_data))[3];
 688   6      //                                                                      TransferBuf[channel]=((unsigned char*)(&channels[channel].channel_data))[0];
 689   6      //                                                                              TransferBuf[channel]=((unsigned char*)(&channels[channel].channel_data))[1];
 690   6                                                                }
 691   5                                                                break; 
 692   5                                                 }
 693   4                                      }
 694   3                                      break;
 695   3      
 696   3                                       case CHNL_FREQ: //частотный
 697   3                                       { 
 698   4                                                switch(channels[channel].settings.set.modific)
 699   4                                            {   
 700   5                                                                
 701   5                                                                case CHNL_FREQ_COUNT_T:
 702   5                                                                {
 703   6                                                                                      TransferBuf[6]=((unsigned char*)(&channels[channel].channel_data))[2];
 704   6                                                                                      TransferBuf[7]=((unsigned char*)(&channels[channel].channel_data))[3];
 705   6      
 706   6                                                                }
 707   5                                                                break;
 708   5      
 709   5                                                                case CHNL_FREQ_256:
 710   5                                                                {
 711   6                                                                                      TransferBuf[6]=((unsigned char*)(&channels[channel].channel_data))[2];
 712   6                                                                                      TransferBuf[7]=((unsigned char*)(&channels[channel].channel_data))[3];
 713   6                                                                }
 714   5                                                                break; 
 715   5                                                 }                                       
 716   4                                        }
 717   3                                        break;                 
 718   3                        }
 719   2                 
C51 COMPILER V9.00   PROTO_USO                                                             06/20/2014 14:22:33 PAGE 13  

 720   2                 len=Old_Proto_Paste_Null(TransferBuf,8);
 721   2      
 722   2                 TransferBuf[len]=Old_CRC_Check(TransferBuf,len);
 723   2                 return len+1;
 724   2         }
 725   1         return 0;    
 726   1      }
 727          //-----------------------------------------------------------------------------
 728          unsigned char Old_Channel_Get_Data_State(void)
 729          {
 730   1        unsigned char channel=0;
 731   1        unsigned char len=0;
 732   1        channel=((RecieveBuf[4]>>3)&0x1F);
 733   1        if(channel<CHANNEL_NUMBER)
 734   1        {
 735   2                 TransferBuf[0]=0x00;TransferBuf[1]=0xD7;TransferBuf[2]=0x28;
 736   2                 TransferBuf[3]=0x0;  // 
 737   2                 TransferBuf[4]=RecieveBuf[4];
 738   2                 TransferBuf[5]=((OLD_CHANNEL_GET_DATA_STATE<<5)&0x1F)|0x6;//0x66;// код операции     
 739   2      
 740   2                              switch(channels[channel].settings.set.type)
 741   2                          {
 742   3                                       case CHNL_ADC:  //аналоговый канал
 743   3                                       {
 744   4                                               switch(channels[channel].settings.set.modific)
 745   4                               {
 746   5                                                        case CHNL_ADC_FIX_16:
 747   5                                                        {
 748   6                                                                      if(channels[channel].calibrate.cal.calibrate==1)//калиброванный
 749   6                                                                      {                                                
 750   7                                                                                      TransferBuf[6]=((unsigned char*)(&channels[channel].channel_data_calibrate))[1];
 751   7                                                                              TransferBuf[7]=((unsigned char*)(&channels[channel].channel_data_calibrate))[2];
 752   7                                                                      }
 753   6                                                                      else
 754   6                                                                      {
 755   7                                                                                      TransferBuf[6]=((unsigned char*)(&channels[channel].channel_data))[1];
 756   7                                                                              TransferBuf[7]=((unsigned char*)(&channels[channel].channel_data))[2];  
 757   7                                                                      }                                       
 758   6                                                        }
 759   5                                                        break; 
 760   5      
 761   5                                                        case CHNL_ADC_FIX_24:
 762   5                                                        {
 763   6                                                              if(channels[channel].calibrate.cal.calibrate==1)//калиброванный
 764   6                                                                      {                                                                                                 
 765   7                                                                                      TransferBuf[channel]=((unsigned char*)(&channels[channel].channel_data_calibrate))[1];
 766   7                                                                              TransferBuf[channel]=((unsigned char*)(&channels[channel].channel_data_calibrate))[2];
 767   7                                                                      }
 768   6                                                                      else
 769   6                                                                      {                                                                        
 770   7                                                                                      TransferBuf[6]=((unsigned char*)(&channels[channel].channel_data))[1];
 771   7                                                                              TransferBuf[7]=((unsigned char*)(&channels[channel].channel_data))[2];  
 772   7                                                                      }
 773   6      
 774   6                                                        }
 775   5                                                        break;
 776   5                                                }
 777   4                                                
 778   4                                                switch(channels[channel].settings.set.state_byte_1&0x7)
 779   4                                                {
 780   5                                                              case PROTO_ADC_AMP_1:
 781   5                                                              {
C51 COMPILER V9.00   PROTO_USO                                                             06/20/2014 14:22:33 PAGE 14  

 782   6                                                                      TransferBuf[8]=(0x00|(OLD_PROTO_ADC_AMP_1<<1))&0xFE;     // первый байт состояния канала
 783   6                                                              }
 784   5                                                              break;
 785   5      
 786   5                                                              case PROTO_ADC_AMP_2:
 787   5                                                              {
 788   6                                                                      TransferBuf[8]=(0x00|(OLD_PROTO_ADC_AMP_2<<1))&0xFE;     // первый байт состояния канала        
 789   6                                                              }
 790   5                                                              break;
 791   5      
 792   5                                                              case PROTO_ADC_AMP_32:
 793   5                                                              {
 794   6                                                                      TransferBuf[8]=(0x00|(OLD_PROTO_ADC_AMP_32<<1))&0xFE;    // первый байт состояния канала        
 795   6                                                              }
 796   5                                                              break;
 797   5      
 798   5                                                              case PROTO_ADC_AMP_128:
 799   5                                                              {
 800   6                                                                      TransferBuf[8]=(0x00|(OLD_PROTO_ADC_AMP_128<<1))&0xFE;   // первый байт состояния канала
 801   6                                                              }
 802   5                                                              break;
 803   5      
 804   5                                                              default :
 805   5                                                              {
 806   6                                                                      TransferBuf[8]=(0x00|(OLD_PROTO_ADC_AMP_1<<1))&0xFE;     // первый байт состояния канала
 807   6                                                              }
 808   5                                                              break;
 809   5                                                }
 810   4                                                
 811   4                                                TransferBuf[9]=0x0A;   // второй байт состояния канала
 812   4      
 813   4                                        }
 814   3                                        break;
 815   3      
 816   3                                case CHNL_DOL:         //ДОЛ
 817   3                                {
 818   4                                        switch(channels[channel].settings.set.modific)
 819   4                                    {   
 820   5                                                        case CHNL_DOL_ENC:
 821   5                                                        {
 822   6                                                                      TransferBuf[6]=((unsigned char*)(&channels[channel].channel_data))[2];
 823   6                                                                      TransferBuf[7]=((unsigned char*)(&channels[channel].channel_data))[3];
 824   6      //                                                                      TransferBuf[channel]=((unsigned char*)(&channels[channel].channel_data))[0];
 825   6      //                                                                              TransferBuf[channel]=((unsigned char*)(&channels[channel].channel_data))[1];
 826   6      
 827   6                                                                      
 828   6      
 829   6                                                                      switch(channels[channel].settings.set.state_byte_1&0x7)
 830   6                                                                      {
 831   7                                                                                      case PROTO_ADC_AMP_1:
 832   7                                                                                      {
 833   8                                                                                              TransferBuf[8]=(0x40|(OLD_PROTO_ADC_AMP_1<<1))&0xFE;     // первый байт состояния канала
 834   8                                                                                      }
 835   7                                                                                      break;
 836   7                              
 837   7                                                                                      case PROTO_ADC_AMP_2:
 838   7                                                                                      {
 839   8                                                                                              TransferBuf[8]=(0x40|(OLD_PROTO_ADC_AMP_2<<1))&0xFE;     // первый байт состояния канала        
 840   8                                                                                      }
 841   7                                                                                      break;
 842   7                              
 843   7                                                                                      case PROTO_ADC_AMP_32:
C51 COMPILER V9.00   PROTO_USO                                                             06/20/2014 14:22:33 PAGE 15  

 844   7                                                                                      {
 845   8                                                                                              TransferBuf[8]=(0x40|(OLD_PROTO_ADC_AMP_32<<1))&0xFE;    // первый байт состояния канала        
 846   8                                                                                      }
 847   7                                                                                      break;
 848   7                              
 849   7                                                                                      case PROTO_ADC_AMP_128:
 850   7                                                                                      {
 851   8                                                                                              TransferBuf[8]=(0x40|(OLD_PROTO_ADC_AMP_128<<1))&0xFE;   // первый байт состояния канала
 852   8                                                                                      }
 853   7                                                                                      break;
 854   7                              
 855   7                                                                                      default :
 856   7                                                                                      {
 857   8                                                                                              TransferBuf[8]=(0x40|(OLD_PROTO_ADC_AMP_1<<1))&0xFE;
 858   8                                                                                      }
 859   7                                                                                      break;                  
 860   7                                                                      }
 861   6                                                                      TransferBuf[9]=0x00;     // второй байт состояния канала
 862   6                                                        }
 863   5                                                        break; 
 864   5                                                 }
 865   4                                      }
 866   3                                      break;
 867   3      
 868   3                                       case CHNL_FREQ: //частотный
 869   3                                       { 
 870   4                                                switch(channels[channel].settings.set.modific)
 871   4                                            {   
 872   5                                                                
 873   5                                                                case CHNL_FREQ_COUNT_T:
 874   5                                                                {
 875   6                                                                                      TransferBuf[6]=((unsigned char*)(&channels[channel].channel_data))[2];
 876   6                                                                                      TransferBuf[7]=((unsigned char*)(&channels[channel].channel_data))[3];
 877   6      
 878   6                                                                }
 879   5                                                                break;
 880   5      
 881   5                                                                case CHNL_FREQ_256:
 882   5                                                                {
 883   6                                                                                      TransferBuf[6]=((unsigned char*)(&channels[channel].channel_data))[2];
 884   6                                                                                      TransferBuf[7]=((unsigned char*)(&channels[channel].channel_data))[3];
 885   6                                                                }
 886   5                                                                break; 
 887   5                                                 }
 888   4                                                 
 889   4                                              TransferBuf[8]=0x40;     // первый байт состояния канала
 890   4                                      TransferBuf[9]=0x00;     // второй байт состояния канала
 891   4                                        }
 892   3                                        break;                 
 893   3                        }
 894   2      
 895   2                 TransferBuf[10]=0xFF;
 896   2      
 897   2                 len=Old_Proto_Paste_Null(TransferBuf,11);
 898   2      
 899   2                 TransferBuf[len]=Old_CRC_Check(TransferBuf,len);
 900   2                 return len+1;
 901   2         }
 902   1         return 0;
 903   1      
 904   1      }
 905          //-----------------------------------------------------------------------------
C51 COMPILER V9.00   PROTO_USO                                                             06/20/2014 14:22:33 PAGE 16  

 906          unsigned char Old_Channel_Get_State(void)
 907          {
 908   1        unsigned char channel=0;
 909   1        unsigned char len=0;
 910   1        channel=((RecieveBuf[4]>>3)&0x1F);
 911   1        if(channel<CHANNEL_NUMBER)
 912   1        {
 913   2        
 914   2                 TransferBuf[0]=0x00;TransferBuf[1]=0xD7;TransferBuf[2]=0x28;
 915   2                 TransferBuf[3]=0x0;  // 
 916   2                 TransferBuf[4]=RecieveBuf[4];
 917   2                 TransferBuf[5]=((OLD_CHANNEL_GET_STATE<<5)&0x1F)|0x3;//0x43;// код операции  
 918   2      
 919   2                              switch(channels[channel].settings.set.type)
 920   2                          {
 921   3                                       case CHNL_ADC:  //аналоговый канал
 922   3                                       {                
 923   4                                                switch(channels[channel].settings.set.state_byte_1&0x7)
 924   4                                                {
 925   5                                                              case PROTO_ADC_AMP_1:
 926   5                                                              {
 927   6                                                                      TransferBuf[6]=0x00|(OLD_PROTO_ADC_AMP_1<<1);    // первый байт состояния канала
 928   6                                                              }
 929   5                                                              break;
 930   5      
 931   5                                                              case PROTO_ADC_AMP_2:
 932   5                                                              {
 933   6                                                                      TransferBuf[6]=0x00|(OLD_PROTO_ADC_AMP_2<<1);    // первый байт состояния канала        
 934   6                                                              }
 935   5                                                              break;
 936   5      
 937   5                                                              case PROTO_ADC_AMP_32:
 938   5                                                              {
 939   6                                                                      TransferBuf[6]=0x00|(OLD_PROTO_ADC_AMP_32<<1);   // первый байт состояния канала        
 940   6                                                              }
 941   5                                                              break;
 942   5      
 943   5                                                              case PROTO_ADC_AMP_128:
 944   5                                                              {
 945   6                                                                      TransferBuf[6]=0x00|(OLD_PROTO_ADC_AMP_128<<1);  // первый байт состояния канала
 946   6                                                              }
 947   5                                                              break;
 948   5      
 949   5                                                              default :
 950   5                                                              {
 951   6                                                                      TransferBuf[6]=0x00|(OLD_PROTO_ADC_AMP_1<<1);    // первый байт состояния канала
 952   6                                                              }
 953   5                                                              break;
 954   5                                                }
 955   4                                                
 956   4                                                TransferBuf[7]=0x0A;   // второй байт состояния канала
 957   4                                        }
 958   3                                        break;
 959   3      
 960   3                                      case CHNL_DOL:   //ДОЛ
 961   3                                      {
 962   4      
 963   4                                                      switch(channels[channel].settings.set.state_byte_1&0x7)
 964   4                                                      {
 965   5                                                                      case PROTO_ADC_AMP_1:
 966   5                                                                      {
 967   6                                                                              TransferBuf[6]=0x40|(OLD_PROTO_ADC_AMP_1<<1);    // первый байт состояния канала
C51 COMPILER V9.00   PROTO_USO                                                             06/20/2014 14:22:33 PAGE 17  

 968   6                                                                      }
 969   5                                                                      break;
 970   5              
 971   5                                                                      case PROTO_ADC_AMP_2:
 972   5                                                                      {
 973   6                                                                              TransferBuf[6]=0x40|(OLD_PROTO_ADC_AMP_2<<1);    // первый байт состояния канала        
 974   6                                                                      }
 975   5                                                                      break;
 976   5              
 977   5                                                                      case PROTO_ADC_AMP_32:
 978   5                                                                      {
 979   6                                                                              TransferBuf[6]=0x40|(OLD_PROTO_ADC_AMP_32<<1);   // первый байт состояния канала        
 980   6                                                                      }
 981   5                                                                      break;
 982   5              
 983   5                                                                      case PROTO_ADC_AMP_128:
 984   5                                                                      {
 985   6                                                                              TransferBuf[6]=0x40|(OLD_PROTO_ADC_AMP_128<<1);  // первый байт состояния канала
 986   6                                                                      }
 987   5                                                                      break;
 988   5              
 989   5                                                                      default :
 990   5                                                                      {
 991   6                                                                              TransferBuf[6]=0x40;     // первый байт состояния канала
 992   6                                                                      }
 993   5                                                                      break;
 994   5              
 995   5                                                      }
 996   4                                                      TransferBuf[7]=0x00;     // второй байт состояния канала
 997   4                                      }
 998   3                                      break;
 999   3      
1000   3                                       case CHNL_FREQ: //частотный
1001   3                                       { 
1002   4                                                 
1003   4                                              TransferBuf[6]=0x40;     // первый байт состояния канала
1004   4                                      TransferBuf[7]=0x00;     // второй байт состояния канала
1005   4                                       }
1006   3                                       break;          
1007   3                        }
1008   2                 
1009   2                 len=Old_Proto_Paste_Null(TransferBuf,8);
1010   2      
1011   2                 TransferBuf[len]=Old_CRC_Check(TransferBuf,len);
1012   2                 return len+1;
1013   2         }
1014   1         return 0;    
1015   1      }
1016          //-----------------------------------------------------------------------------
1017          unsigned char Old_Reinit_Block(void)
1018          {
1019   1              return 0;       
1020   1      }
1021          //-----------------------------------------------------------------------------
1022          unsigned char Old_Channel_Set_ADC_Range(void)
1023          {
1024   1        unsigned char channel=0;
1025   1        channel=((RecieveBuf[4]>>3)&0x1F);
1026   1        if(channel<CHANNEL_NUMBER)
1027   1        {     
1028   2              switch((RecieveBuf[6]>>1)&0x3)
1029   2              {
C51 COMPILER V9.00   PROTO_USO                                                             06/20/2014 14:22:33 PAGE 18  

1030   3                              case OLD_PROTO_ADC_AMP_1:
1031   3                              {
1032   4                                   channels[channel].settings.set.state_byte_1&=0xF0;
1033   4                                       channels[channel].settings.set.state_byte_1|=PROTO_ADC_AMP_1;
1034   4                              }
1035   3                              break;
1036   3      
1037   3                              case OLD_PROTO_ADC_AMP_2:
1038   3                              {
1039   4                                       channels[channel].settings.set.state_byte_1&=0xF0;
1040   4                                       channels[channel].settings.set.state_byte_1|=PROTO_ADC_AMP_2;
1041   4                              }
1042   3                              break;
1043   3      
1044   3                              case OLD_PROTO_ADC_AMP_32:
1045   3                              {
1046   4                                       channels[channel].settings.set.state_byte_1&=0xF0;
1047   4                                       channels[channel].settings.set.state_byte_1|=PROTO_ADC_AMP_32;
1048   4                              }
1049   3                              break;
1050   3      
1051   3                              case OLD_PROTO_ADC_AMP_128:
1052   3                              {
1053   4                                   channels[channel].settings.set.state_byte_1&=0xF0;
1054   4                                       channels[channel].settings.set.state_byte_1|=PROTO_ADC_AMP_128;
1055   4                              }
1056   3                              break;
1057   3      
1058   3                              default :
1059   3                              {
1060   4                                   channels[channel].settings.set.state_byte_1&=0xF0;
1061   4                                       channels[channel].settings.set.state_byte_1|=PROTO_ADC_AMP_1;
1062   4                              }
1063   3                              break;
1064   3              }
1065   2        }
1066   1        return 0;
1067   1      }
1068          //-----------------------------------------------------------------------------
1069          unsigned char Old_Proto_Paste_Null(unsigned char *buf,unsigned char len)//т.к. старый протокол прибавляет 
             -к длине количество 0 после D7 то обрабатываем вне прерывания
1070          {
1071   1              volatile unsigned char xdata i=0,j=0;
1072   1      
1073   1              for(i=3;i<len;i++) //пропустим заголовок 0x00 0xD7 0x28
1074   1              {
1075   2                       if(buf[i]==0xD7)
1076   2                       {
1077   3                               for(j=(len-1);j>i;j--)
1078   3                               {
1079   4                                      buf[j+1]=buf[j];//сдвигаем элементы буфера вправо на одну позицию до D7
1080   4                               }
1081   3                               buf[i+1]=0x0;//вставляем 0x00 после 0xD7
1082   3                               buf[5]++;//длина кадра увеличилась на 1
1083   3                               len++;
1084   3                               i++;//не проверяем 0 спереди
1085   3                       }
1086   2              }
1087   1              return len;
1088   1      }
1089          //-----------------------------------------------------------------------------
1090          void ProtoBufHandling(void) //using 0 //процесс обработки принятого запроса
C51 COMPILER V9.00   PROTO_USO                                                             06/20/2014 14:22:33 PAGE 19  

1091          {
1092   1              switch(protocol_type)
1093   1              {
1094   2                      case PROTO_TYPE_NEW:
1095   2                      {
1096   3                                channels[11].settings.set.state_byte_1=0x40; //восстановим байты статуса дола
1097   3                                channels[11].settings.set.state_byte_2=0x0A;
1098   3                                switch(RecieveBuf[4])
1099   3                                {
1100   4                              //---------------------------------------
1101   4                                      case GET_DEV_INFO_REQ:
1102   4                                      {
1103   5                                              buf_len=Send_Info();    
1104   5                                      }
1105   4                                      break;
1106   4                              //---------------------------------------
1107   4                                      case NODE_FULL_INIT_REQ:
1108   4                                      {
1109   5                                              buf_len=Node_Full_Init();
1110   5                                      }
1111   4                                      break;
1112   4                              //---------------------------------------
1113   4                                      case CHANNEL_LIST_INIT_REQ:
1114   4                                      {       
1115   5                                              buf_len=Channel_List_Init();    
1116   5                                      }
1117   4                                      break;
1118   4                              //---------------------------------------
1119   4                                      case CHANNEL_GET_DATA_REQ:
1120   4                                      {
1121   5                                              buf_len=Channel_Get_Data();     
1122   5                                      }
1123   4                                      break;
1124   4                                      //-----------------------------------
1125   4                                      case CHANNEL_SET_PARAMETERS_REQ:
1126   4                                      {
1127   5                                              buf_len=Channel_Set_Parameters();
1128   5                                      }
1129   4                                      break;
1130   4                                      //-----------------------------------
1131   4                                      case CHANNEL_SET_ORDER_QUERY_REQ:
1132   4                                      {
1133   5                                              buf_len=Channel_Set_Order_Query();
1134   5                                      }
1135   4                                      break;
1136   4                              //----------------------------------------
1137   4                                      case CHANNEL_GET_DATA_ORDER_REQ:
1138   4                                      {
1139   5                                               buf_len=Channel_Get_Data_Order();
1140   5                                      }
1141   4                                      break;
1142   4                              //----------------------------------------
1143   4                                      case CHANNEL_SET_STATE_REQ:
1144   4                                      {
1145   5                                               buf_len=Channel_Set_State();
1146   5                                      }
1147   4                                      break;
1148   4                              //----------------------------------------
1149   4                                      case CHANNEL_GET_DATA_ORDER_M2_REQ:
1150   4                                      {
1151   5                                               buf_len=Channel_Get_Data_Order_M2();
1152   5                                      }
C51 COMPILER V9.00   PROTO_USO                                                             06/20/2014 14:22:33 PAGE 20  

1153   4                                      break;
1154   4                              //------------------------------------------
1155   4                                      case CHANNEL_SET_RESET_STATE_FLAGS_REQ:
1156   4                                      {
1157   5                                              buf_len=Channel_Set_Reset_State_Flags();
1158   5                                      }
1159   4                                      break;
1160   4                              //------------------------------------------
1161   4                                      case CHANNEL_ALL_GET_DATA_REQ:
1162   4                                      {
1163   5                                               buf_len=Channel_All_Get_Data();
1164   5                                      }
1165   4                                      break;
1166   4                              //------------------------------------------
1167   4                                      case CHANNEL_SET_ADDRESS_DESC:
1168   4                                      {
1169   5                                               buf_len=Channel_Set_Address_Desc();
1170   5                                      }
1171   4                                      break;
1172   4                              //------------------------------------------
1173   4                                      case CHANNEL_SET_CALIBRATE:
1174   4                                      {
1175   5                                               buf_len=Channel_Set_Calibrate();
1176   5                                      }
1177   4                                      break;
1178   4                              //------------------------------------------
1179   4                                      case CHANNEL_SET_ALL_DEFAULT:
1180   4                                      {
1181   5                                               buf_len=Channel_Set_All_Default();
1182   5                                      }
1183   4                                      break;
1184   4                              //------------------------------------------
1185   4                                      case CHANNEL_GET_CALIBRATE_REQ:
1186   4                                      {
1187   5                                               buf_len=Channel_Get_Calibrate_Value();
1188   5                                      }
1189   4                                      break;
1190   4                              //------------------------------------------
1191   4                                  default:
1192   4                                      {
1193   5                                         buf_len=Request_Error(FR_COMMAND_NOT_EXIST);
1194   5                                  }                                                              
1195   4                                }
1196   3                      }
1197   2                      break;
1198   2      
1199   2                      case PROTO_TYPE_OLD: //старый протокол
1200   2                      {
1201   3                                switch((RecieveBuf[5]>>5)&0x7)
1202   3                                {
1203   4                              //---------------------------------------
1204   4                                      case OLD_CHANNEL_REINIT_BLOCK:
1205   4                                      {
1206   5                                              buf_len=Old_Reinit_Block();     
1207   5                                      }
1208   4                                      break;
1209   4                              //---------------------------------------
1210   4                                      case OLD_CHANNEL_SET_ADC_RANGE:
1211   4                                      {
1212   5                                              buf_len=Old_Channel_Set_ADC_Range();
1213   5                                      }
1214   4                                      break;
C51 COMPILER V9.00   PROTO_USO                                                             06/20/2014 14:22:33 PAGE 21  

1215   4                              //---------------------------------------
1216   4                                      case OLD_CHANNEL_GET_STATE:
1217   4                                      {       
1218   5                                              buf_len=Old_Channel_Get_State();        
1219   5                                      }
1220   4                                      break;
1221   4                              //---------------------------------------
1222   4                                      case OLD_CHANNEL_GET_DATA:
1223   4                                      {
1224   5                                              buf_len=Old_Channel_Get_Data(); 
1225   5                                      }
1226   4                                      break;
1227   4                                      //-----------------------------------
1228   4                                      case OLD_CHANNEL_GET_DATA_STATE:
1229   4                                      {
1230   5                                              buf_len=Old_Channel_Get_Data_State();
1231   5                                      }
1232   4                                      break;
1233   4                                      //-----------------------------------
1234   4                                  default:
1235   4                                      {
1236   5                                         
1237   5                                  }                                                              
1238   4                                }     
1239   3                       }
1240   2                       break;
1241   2                       
1242   2                       case PROTO_TYPE_MODBUS_ASCII:
1243   2                       {
1244   3                                switch(MBCHAR2BIN(RecieveBuf[3])<<4| MBCHAR2BIN(RecieveBuf[4]))
1245   3                                {
1246   4                                      //---------------------------------------
1247   4                                              case MB_FUNC_READ_HOLDING_REGISTER:
1248   4                                              {
1249   5                                                      buf_len=ReadHoldingReg();       
1250   5                                              }
1251   4                                              break;
1252   4                                      //------------------------------------------
1253   4                                          default:
1254   4                                              {
1255   5                                                 buf_len=0x0;
1256   5                                          }                                                              
1257   4                                }
1258   3                       }
1259   2                       break; 
1260   2              }
1261   1      
1262   1        return;
1263   1      }
1264          //-----------------------------------------------------------------------------------
1265          //#pragma OT(0,Speed) 
1266          PT_THREAD(ProtoProcess(struct pt *pt))
1267           {
1268   1       static unsigned char  CRC=0x0, LRC=0x0;
1269   1        PT_BEGIN(pt);
1270   3      
1271   3        while(1) 
1272   3        {
1273   4        //----------restart------------
1274   4                      recieve_count=0x0;//??
1275   4                      REN=1;//recieve enqble
1276   4                      DE_RE=0;//линия на прием
C51 COMPILER V9.00   PROTO_USO                                                             06/20/2014 14:22:33 PAGE 22  

1277   4                      ES=1;
1278   4        //-----------------------------
1279   4                // PT_WAIT_UNTIL(pt,RECIEVED); //ждем команды на старт
1280   4                 wdt_count[Proto_Proc].process_state=IDLE;
1281   4      
1282   4                 PT_YIELD_UNTIL(pt,RECIEVED); //ждем команды на старт 
1283   4                 wdt_count[Proto_Proc].count++;
1284   4                // WDT_Clear();//если посылка не приходит-сбрасываем
1285   4      
1286   4                
1287   4                  RECIEVED=0;
1288   4                      
1289   4      
1290   4                      switch(protocol_type)
1291   4                      {
1292   5                              case PROTO_TYPE_NEW:
1293   5                              {
1294   6                                      if(RecieveBuf[3]!=ADRESS_DEV)//если адрес совпал          
1295   6                                      {
1296   7                                              PT_RESTART(pt);//если адрес не сошелся-перезапустим протокол                    
1297   7                                      }
1298   6      
1299   6                                      CRC=RecieveBuf[recieve_count-1];
1300   6      
1301   6                                  if(CRC_Check(&RecieveBuf,(recieve_count-CRC_LEN))!=CRC)
1302   6                                      {
1303   7                                              PT_RESTART(pt);//если CRC не сошлось-перезапустим протокол       
1304   7                                      }
1305   6                              }
1306   5                              break;
1307   5              
1308   5                              case PROTO_TYPE_OLD:
1309   5                              {
1310   6                                      CRC=RecieveBuf[recieve_count-1];
1311   6      
1312   6                                      if(Old_CRC_Check(&RecieveBuf,(recieve_count-CRC_LEN))!=CRC)
1313   6                                      {
1314   7                                              PT_RESTART(pt);//если CRC не сошлось-перезапустим протокол       
1315   7                                      }
1316   6                              }
1317   5                              break;
1318   5              
1319   5                              case PROTO_TYPE_MODBUS_ASCII:
1320   5                              {
1321   6                                      if((unsigned char)(MBCHAR2BIN(RecieveBuf[1])<<4| MBCHAR2BIN(RecieveBuf[2]))!=ADRESS_DEV)
1322   6                                      {
1323   7                                              PT_RESTART(pt); 
1324   7                                      }       
1325   6                                      
1326   6                      
1327   6                                      LRC=((MBCHAR2BIN(RecieveBuf[recieve_count-LRC_LEN])<<4)|(MBCHAR2BIN(RecieveBuf[recieve_count-LRC_LEN+1
             -])));
1328   6                                              
1329   6                                      if(LRC_Check(&RecieveBuf,(recieve_count-LRC_LEN))!=LRC)
1330   6                                      {
1331   7                                              PT_RESTART(pt);//если LRC не сошлось-перезапустим протокол                       
1332   7                                      }
1333   6                              }
1334   5                              break;
1335   5                      }
1336   4      
1337   4              //      PT_YIELD(pt);//дадим другим процессам время
C51 COMPILER V9.00   PROTO_USO                                                             06/20/2014 14:22:33 PAGE 23  

1338   4        //-----------------------------
1339   4                      ProtoBufHandling();//процедура обработки сообщения      
1340   4                      if(buf_len==0)//если в буфере пусто
1341   4                      {
1342   5                              PT_RESTART(pt);//перезапустим протокол  
1343   5                      }
1344   4                      else
1345   4                      {
1346   5                              DE_RE=1; //переключаем RS485 в режим передачи
1347   5                                                              
1348   5                              REN=0;  //запрет приема-только передача
1349   5                              transf_count=0;
1350   5                              CUT_OUT_NULL=0;
1351   5                              SBUF=TransferBuf[transf_count];//передача байта, остальным займется автомат
1352   5                              transf_count++;//инкрементируем счетчик переданных
1353   5                              ES=1; //включим прерывание уарт 
1354   5      
1355   5                          if(protocol_type==PROTO_TYPE_NEW)
1356   5                              {
1357   6                                      PT_DELAY(pt,10);
1358   6                              }
1359   5                              else
1360   5                              {
1361   6                                      PT_DELAY(pt,3);
1362   6                              }                       
1363   5                      }               
1364   4        //-----------------------------
1365   4        }
1366   3      
1367   3       PT_END(pt);
1368   1      }
1369          //-----------------------------------------------------------------------------------------------
1370          void Store_Dev_Address_Desc(unsigned char addr,void* name,void* ver,void* desc,unsigned char desc_len)//со
             -хранить в ППЗУ новый адрес устройства, имя, версию, описание
1371          {
1372   1      //небезопасная
1373   1              
1374   1              unsigned int blocks=0;//здесь будет количество блоков, нужных дя сохранения комментария
1375   1              
1376   1              EEPROM_Write(&addr,1,DEVICE_ADDR_EEPROM);        //1 блок
1377   1              EEPROM_Write(name,DEVICE_NAME_LENGTH,DEVICE_NAME_EEPROM); //5 блоков
1378   1              memcpy(DEV_NAME,name,DEVICE_NAME_LENGTH_SYM);//копируем полученное имя в буфер
1379   1      
1380   1              EEPROM_Write(ver,DEVICE_VER_LENGTH,DEVICE_VER_EEPROM);          //2 блока
1381   1              memcpy(VERSION,ver,DEVICE_VER_LENGTH_SYM);//копируем версию в буфер
1382   1      
1383   1              blocks=desc_len>>2;//в блоке 4 байта, делим на 4
1384   1              if(desc_len&0xFC)//если есть остаток, то берем еще один блок
1385   1                      blocks++;
1386   1              
1387   1              if(blocks>DEVICE_DESC_MAX_LENGTH) //ограничение на количество блоков для комментария
1388   1                      blocks=DEVICE_DESC_MAX_LENGTH;
1389   1      
1390   1              EEPROM_Write(desc,(unsigned int)blocks,DEVICE_DESC_EEPROM);
1391   1              dev_desc_len=desc_len;
1392   1              EEPROM_Write(&desc_len,1,DEVICE_DESC_LEN_EEPROM);//сохраним длину комментария
1393   1              
1394   1              memcpy(NOTICE,desc,desc_len);//копируем описание в буфер
1395   1              
1396   1              return;
1397   1      }
1398          //-----------------------------------------------------------------------------------------------
C51 COMPILER V9.00   PROTO_USO                                                             06/20/2014 14:22:33 PAGE 24  

1399          void Restore_Dev_Address_Desc(void)//восстановить из ппзу адрес и информацию об устройстве
1400          {
1401   1              unsigned int blocks=0;//здесь будет количество блоков, нужных дя сохранения комментария
1402   1              
1403   1              EEPROM_Read(&ADRESS_DEV,1,DEVICE_ADDR_EEPROM);   //1 блок восстанавливаем адрес из ППЗУ
1404   1      
1405   1              if(ADRESS_DEV<1 || ADRESS_DEV>15)
1406   1                      ADRESS_DEV=1; 
1407   1      
1408   1              EEPROM_Read(DEV_NAME,DEVICE_NAME_LENGTH,DEVICE_NAME_EEPROM); //5 блоков
1409   1          EEPROM_Read(VERSION,DEVICE_VER_LENGTH,DEVICE_VER_EEPROM);
1410   1      
1411   1              EEPROM_Read(&dev_desc_len,1,DEVICE_DESC_LEN_EEPROM);//длина описания устройства в байтах
1412   1      
1413   1              if(dev_desc_len>DEVICE_DESC_MAX_LENGTH_SYM)
1414   1                      dev_desc_len=DEVICE_DESC_MAX_LENGTH_SYM;
1415   1      
1416   1              blocks=dev_desc_len>>2;//в блоке 4 байта, делим на 4
1417   1              if(dev_desc_len&0xFC)//если есть остаток, то берем еще один блок
1418   1                      blocks++;
1419   1      
1420   1              if(blocks>DEVICE_DESC_MAX_LENGTH) //ограничение на количество блоков для комментария     ???
1421   1                      blocks=DEVICE_DESC_MAX_LENGTH;
1422   1      
1423   1              EEPROM_Read(NOTICE,(unsigned int)blocks,DEVICE_DESC_EEPROM);
1424   1              return;
1425   1      }
1426          //-----------------------------------------------------------------------------------------------


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   7702    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    673       1
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      1       2
   IDATA SIZE       =      3    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
